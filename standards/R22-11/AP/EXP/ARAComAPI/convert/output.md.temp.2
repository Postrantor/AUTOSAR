---
tip: translate by openai@2023-06-22 23:17:08
...


The Adaptive AUTOSAR Communication Management is based on Service Oriented communication. This is good for implementing platform independent and dynamic ap- plications with a service-oriented design.

> 适应性AUTOSAR通信管理基于服务导向通信。这有助于实现平台无关和动态应用程序的服务导向设计。


For ADAS applications, it is important to be able to transfer raw binary data streams over Ethernet efficiently between applications and sensors, where service oriented communication (e.g. SOME/IP, DDS) either creates unnecessary overhead for efficient communication, or the sensors do not even have the possibility to send anything but raw binary data.

> 对于ADAS应用，能够有效地在应用程序和传感器之间通过以太网传输原始二进制数据流非常重要，其中面向服务的通信（例如SOME / IP，DDS）要么会为有效通信带来不必要的开销，要么传感器甚至没有可能发送除原始二进制数据以外的任何内容的可能性。


The Raw Data Binary Stream API provides a way to send and receive Raw Binary Data Streams, which are sequences of bytes, without any data type. They enable efficient communication with external sensors in a vehicle (e.g. sensor delivers video and map data in \"Raw data\" format). The communication is performed over a network using sockets.

> 原始数据二进制流API提供了一种发送和接收原始二进制流的方式，这些二进制流没有任何数据类型。它们可以高效地与车辆中的外部传感器进行通信（例如，传感器以“原始数据”格式提供视频和地图数据）。该通信是通过套接字在网络上完成的。


From the ara::com architecture point of view, Raw Data Streaming API is static, i.e. its is not generated. It is part of the ara::com namespace, but is independent of the ara::com middleware services.

> 从ara::com架构的角度来看，原始数据流API是静态的，即它不是自动生成的。它是ara::com命名空间的一部分，但与ara::com中间件服务无关。

### Functional description


The Raw Data Binary Stream API can be used in both the client or the server side. The functionality of both client and server allow to send and receive. The only difference is that the server can wait for connections but cannot actively connect to a client. On the other side, the client can connect to a server (that is already waiting for connections) but the client cannot wait for connections.

> 原始数据二进制流API可以在客户端或服务器端使用。客户端和服务器的功能都可以发送和接收。唯一的区别是服务器可以等待连接，但不能主动连接到客户端。另一方面，客户端可以连接到一个已经等待连接的服务器，但客户端不能等待连接。


The usage of the Raw Data Binary Streams API from Adaptive Autosar must follow this sequence:

> Adaptive Autosar的Raw Data Binary Streams API的使用必须遵循以下顺序：

- As client


  1. Connect: Establishes connection to sensor (not needed for UDP)

> 连接：建立到传感器的连接（UDP不需要）

  2. ReadData/WriteData: Receives or sends data

> 2. 读取数据/写入数据：接收或发送数据

  3. Shutdown: Connection is closed.

> 3.关机：连接已关闭。
- As server


  1. WaitForConnection: Waits for incoming connections from clients (not needed for UDP)

> 等待连接：等待来自客户端的传入连接（UDP不需要）

  2. ReadData/WriteData: Receives or sends data

> 2. 读取数据/写入数据：接收或发送数据

  3. Shutdown: Connection is closed and stops waiting for connections.

> 3.关机：连接已关闭，不再等待连接。

     1. ### Class and Model

        1. ### Class and signatures


The class [ara::com::raw](#_bookmark16) defines a RawDataStream class for reading and writing binary data streams over a network connection using sockets. The client side is an object of the class [ara::com::raw::RawDataStreamClient](#_bookmark17) and the server side is [ara::com::raw::-](#_bookmark18) [RawDataStreamServer](#_bookmark18)

> 类[ara::com::raw](#_bookmark16)定义了一个RawDataStream类，用于通过套接字在网络连接上读写二进制数据流。客户端是[ara::com::raw::RawDataStreamClient](#_bookmark17)类的一个对象，服务端是[ara::com::raw::-](#_bookmark18) [RawDataStreamServer](#_bookmark18)类的一个对象。

### Constructor


The constructor takes as input the instance specifier qualifying the network binding and parameters for the instance.

> 构造函数需要输入实例规范来限定网络绑定和实例的参数。

```
 RawDataStreamClient(const ara::com::InstanceSpecifier\\& instance); RawDataStreamServer(const ara::com::InstanceSpecifier\\& instance);
```

### Destructor


Destructor of RawDataStream. If the connection is still open, it will be shut down before destroying the RawDataStream object.Destructor of RawDataStream. If the connection is still open, it will be shut down before destroying the RawDataStream object.

> 毁灭RawDataStream的析构函数。如果连接仍然打开，它将在销毁RawDataStream对象之前关闭。

```
 \~RawDataStreamClient();

 \~RawDataStreamServer();

```

### Manifest Model


The manifest defines the parameters of the Raw Data Stream deployment on the net- work.

> 清单定义了网络上原始数据流部署的参数。


The [RawDataStreamMapping](#_bookmark19) defines the actual transport that raw data uses in the sub-classes of [EthernetRawDataStreamMapping](#_bookmark20). It also defines which local- and re- mote network endpoints (IP addresses) and ports to use for the communication, and if unicast or multicast is used.

> [RawDataStreamMapping](#_bookmark19) 定义了 [EthernetRawDataStreamMapping](#_bookmark20) 的子类中原始数据使用的实际传输方式。它还定义了用于通信的本地和远程网络端点（IP地址）和端口，以及是使用单播还是多播。


In principle, Raw Data Streaming can use any transport protocol but currently only TCP and UDP are supported.

> 原则上，原始数据流可以使用任何传输协议，但目前只支持TCP和UDP。


The local IP address is defined in the attribute communicationConnector (type EthernetCommunicationConnector), and the protocol and port is defined in the following attributes of the sub-class [EthernetRawDataStreamMapping](#_bookmark20) with type Pos- itiveInteger:

> 本地IP地址定义在communicationConnector属性（类型EthernetCommunicationConnector）中，协议和端口定义在子类EthernetRawDataStreamMapping的以下属性中，类型为PositiveInteger：

- localTcpPort
- localUdpPort


At least one of the two previous attributes has to be defined. The socketOption attribute allows to specify non-formal socket options that might only be valid for specific platforms. This is defined as an array of strings and the possible values are platform and vendor specific.

> 至少有一个前面的属性必须被定义。socketOption属性允许指定可能只对特定平台有效的非正式套接字选项。这是定义为一个字符串数组，可能的值是特定于平台和供应商的。


Remote credentials for the different use cases are defined in attributes RawDataS- treamUdpCredentials and RawDataStreamUdpTcpCredentials. See TPS Manifest \[[2](#_bookmark1)\] for details.

> 远程凭据用于不同的用例定义在属性RawDataStreamUdpCredentials和RawDataStreamUdpTcpCredentials中。有关详细信息，请参阅TPS清单[[2]](#_bookmark1)。


The [EthernetRawDataStreamMapping](#_bookmark20) also has an attribute regarding security, where TLS secure communication properties for the Raw Data Stream connection can be defined:

> [EthernetRawDataStreamMapping](#_bookmark20)也具有一个关于安全性的属性，可以在其中定义原始数据流连接的TLS安全通信属性：

- tlsSecureComProps


  1. ### Methods of class RawDataStream

> ### RawDataStream类的方法


Detailed information about the methods of [ara::com::raw::RawDataStream](#_bookmark16) can be found in chapter Raw Data Stream API of \[[1](#_bookmark0)\].

> 详细信息关于ara::com::raw::RawDataStream（#_bookmark16）的方法可以在参考文献[1](#_bookmark0)中的原始数据流API章节中找到。

### Timeout parameter


All Connect/WaitForConnection/Read/Write methods of RawDataStream clients and servers have an optional input parameter for the timeout. This argument defines the timeout of the method in milliseconds. The type is std::chrono::milliseconds.

> 所有RawDataStream客户端和服务器的Connect/WaitForConnection/Read/Write方法都有一个可选的输入参数超时。此参数以毫秒为单位定义该方法的超时时间。类型为std::chrono::milliseconds。


If timeout is 0 or not specified the operation will block until it returns.

> 如果超时设置为0或未指定，操作将阻塞直到它返回。


If timeout is specified is \> 0 the method call will return a timeout error if the time to perform the operation exceeds the timeout limit.

> 如果指定了超时时间大于0，如果执行操作超过超时限制，该方法调用将返回超时错误。

### Methods


The API methods are synchronous, so they will block until the method returns or until timeout is reached.

> API 方法是同步的，因此它们会一直阻塞，直到方法返回或超时为止。

### WaitForConnection


This method is available only in the server side of the Raw Data Stream.

> 这种方法只能在原始数据流的服务器端使用。


The server side of the Raw Data Stream is ready to be connected from a client. No connection from clients can be established until this method is called in the server. It is only used if TCP is used. For UDP this operation will do nothing.

> 服务器端的原始数据流已经准备好可以从客户端连接。在调用服务器的此方法之前，不能建立客户端的连接。仅在使用TCP时才使用此操作。对于UDP，此操作无效。

### Connect


This method is available only in the client side of the Raw Data Stream.

> 这种方法只能在原始数据流的客户端中使用。


This method initializes the socket and establishes a connection to the TCP server. In the case of UDP, no connection needs to be established, and the operation will do nothing. Incoming and outgoing packets are restricted to the specified local and remote

> 这种方法初始化套接字并建立到TCP服务器的连接。在UDP的情况下，不需要建立连接，操作将不执行任何操作。传入和传出的数据包受限于指定的本地和远程。


The socket configurations are specified in the manifest which is accessed through the InstanceSpecifer provided in the constructor.

> 配置套接字的信息存储在清单中，可以通过构造函数提供的InstanceSpecifer访问这个清单。

```
 ara::core:Result\<void\> Connect();

 ara::core:Result\<void\> Connect(std::chrono::milliseconds timeout);
```

### Shutdown


This method shuts down communication. It is available from both client and server sides of the Raw Data Stream.

> 这种方法关闭通信。它可以从原始数据流的客户端和服务器端获得。

```
 ara::core:Result\<void\> Shutdown();
```

### ReadData


This method reads bytes from the socket connection. The maximum number of bytes to read is provided with the parameter length. The timeout parameter is optional.

> 这种方法从套接字连接读取字节。最大读取字节数由参数length提供。超时参数是可选的。

```

 ara::core::Result\<ReadDataResult\> ReadData(size_t length); ara::core::Result\<ReadDataResult\> ReadData(

 size_t length, std::chrono::milliseconds timeout);

```


If the operation worked, it returns a struct with a pointer to the memory containing the read data and the actual number of read bytes.

> 如果操作成功，它会返回一个带有指向包含读取数据的内存的指针和实际读取字节数的结构。

```

 struct ReadDataResult{

 std::unique_ptr\<ara::core::Byte\[\]\> data; size_t numberOfBytes;

 }

```


In case of an error it retuns an ara::Core::ErrorCode from ara::com::RawEr- rorDomain:

> 在发生错误的情况下，它会从ara :: com :: RawErrorDomain返回ara :: Core :: ErrorCode。

- Stream Not Connected: If the connection is not yet established (TCP only).
- Interrupted By Signal: The operation was interrupted by the system.
- Communication Timeout: No data was read until the timeout expiration.

  1. ### WriteData


This method writes bytes to the socket connection. The data is provided as a buffer with the data parameter. The number of bytes to write is provided in the length parameter. An optional timeout parameter can also be used.

> 这种方法将字节写入套接字连接。数据以数据参数提供的缓冲区提供。要写入的字节数由length参数提供。也可以使用可选的超时参数。


ara::core:Result\<size_t\> WriteData( std::unique_ptr\<ara::core::Byte\[\]\> data, size_t length);

> ara::core:Result<size_t> 写入数据（std::unique_ptr<ara::core::Byte[]> 数据，size_t 长度）;


ara::core:Result\<size_t\> WriteData( std::unique_ptr\<ara::core::Byte\[\]\> data, size_t length, std::chrono::milliseconds timeout);

> ara::core:Result<size_t> WriteData（std::unique_ptr<ara::core::Byte[]> 数据，大小_t 长度，std::chrono::milliseconds 超时）；


If the operation worked, it will return the actual number of bytes written. In case of an error, it will return a ara::Core::ErrorCode:

> 如果操作成功，它将返回实际写入的字节数。如果发生错误，它将返回ara :: Core :: ErrorCode：

- Stream Not Connected: If the connection is not yet established (TCP only).
- Interrupted By Signal: The operation was interrupted by the system.
- Communication Timeout: No data was written until the timeout expiration.

### Security


Raw Data Stream communication can be transported using TCP and UDP. Therefore different security mechanisms have to be available to secure the stream communica- tion. Currently the security protocols TLS, DTLS, IPSec and MACsec are available.

> 数据流通信可以使用TCP和UDP进行传输。因此，必须有不同的安全机制来保护流通信。目前，安全协议TLS、DTLS、IPSec和MACsec可用。


Access control to Raw Data Streams can also be defined by the IAM.

> 访问控制对原始数据流也可以由IAM定义。


All security functions are configurable in the deployment and mapping model of Raw Data Streaming Interface.

> 所有安全功能都可以在原始数据流接口的部署和映射模型中进行配置。


If sensor data must fulfill security requirements, security extensions have to be used.

> 如果传感器数据必须满足安全要求，则必须使用安全扩展。

### Safety


The RawDataStream interface only transmits raw data without any data type informa- tion. Therefore Raw Data Stream interface cannot provide any data protection, such as E2E protection. If it is required it must be implemented in the application that uses the RawDataStream interface.

> 接口RawDataStream只传输原始数据，没有任何数据类型信息。因此，Raw Data Stream接口不能提供任何数据保护，比如端到端保护。如果需要，必须在使用RawDataStream接口的应用程序中实施。

### Hints for implementers


Implementation of Raw Data Streaming interface should be independent from the un- derlying Sockets API (e.g. POSIX Sockets).

> 实施原始数据流界面应该独立于底层套接字API（例如POSIX套接字）。


1. ## Communication Groups

> 1. 通信组

   1. ### Objective


The Communication Group (CG) is a composite service template defined by AUTOSAR. It provides a communciation framework which allows to communicate peer to peer and in broadcast mode between AUTOSAR applications. The Communication Group has one server and multiple clients. The server sends messages to the clients in peer to peer and or in broadcast mode. The clients can response to a message. The server of a Communication Groups knows all clients connected to the Communication Group by any time. Therefore, the server can directly communicate to a certain client.

> 集成服务模板“通信组（CG）”由AUTOSAR定义，它提供了一个通信框架，可以在AUTOSAR应用程序之间进行点对点和广播模式的通信。通信组有一个服务器和多个客户端。服务器以点对点和/或广播模式发送消息给客户端。客户端可以回复消息。通信组的服务器随时知道所有连接到通信组的客户端。因此，服务器可以直接与某个客户端通信。

![](./media/image13.png)

**Figure 5.3: Communication Group Abstract for State Management**

### Realization


The Communication Group provides two ServiceInterfaces.

> 通信小组提供两个服务接口。


- A dedicated Server ServiceInterface with the category value [COMMUNI-](#_bookmark21) [CATION_GROUP_SERVER](#_bookmark21), implemented as Skeleton.

> 一个专用服务器服务接口，类别值为COMMUNICATION_GROUP_SERVER，实现为骨架。

- A dedicated Client ServiceInterface with the category value [COMMUNI-](#_bookmark22) [CATION_GROUP_CLIENT](#_bookmark22), implemented as Proxy.

> 一个具有类别值[COMMUNI-](#_bookmark22) [CATION_GROUP_CLIENT](#_bookmark22)的专用客户服务接口，实现为代理。


A Communcation Group server connects to the Communcation Group using the Ser- vice Proxy of the Server ServiceInterface and a Communcation Group client con- nects to the Communication Group using the Service Skeleton of the Client Servi- ceInterface. See also the figure below.

> 一个通信组服务器使用服务器服务接口的服务代理连接到通信组，而客户端则使用客户端服务接口的服务骨架连接到通信组。另请参见下图。

![](./media/image27.png)

**Figure 5.4: Communication Group**

Note: Message types of a Communciation Group are defined with the Communciation Group meta-model, see also following chapters.

### Usage Scope


The initial usage of the Communcation Group has been Adaptive State Management applications. The SWS_StateManagement \[[4](#_bookmark3)\] specification has defined two Com- munication Groups, named: [PowerMode](#_bookmark72) and [DiagnosticReset](#_bookmark73). The usage scope of the State Management Communication Groups are applications within a machine only. But from design point of view, a Communication Group supports the connection of local and remote applications (CP and AP). The figure below presents a local and remote scenarios for Communication Groups.

> 初始使用的通信组已经是自适应状态管理应用程序。SWS_StateManagement [[4]](#_bookmark3) 规范定义了两个名为PowerMode和DiagnosticReset的通信组。状态管理通信组的使用范围仅限于机器内的应用程序。但从设计角度来看，通信组支持本地和远程应用程序（CP和AP）之间的连接。下图显示了通信组的本地和远程场景。

![](./media/image28.png){width="5.2858967629046365in" height="2.487082239720035in"}

**Figure 5.5: Communication Group within a Vehicle**

2. ### Special Topics


   1. []{#5.7.4.1_Architecture .anchor}**Architecture**

> **建筑**


As before described the Communcation Group contains

> 正如之前描述的，通信小组包含


- only one Service Skeleton instantiation of type Communication Group server ( ServiceInterface with the category value [COMMUNICATION_GROUP\_-](#_bookmark21) [SERVER](#_bookmark21)).

> 只有一个类型为Communication Group Server的Service Skeleton实例（ServiceInterface的category值为[COMMUNICATION_GROUP\_-]（#_bookmark21）[SERVER]（#_bookmark21））。

Note: Today there is the constraint that only one Communication server can con- nect to the Communication Group server ServiceInterface.


- multiple Service Proxy instantiations of type Communication Group client( ServiceInterface with the category value [COMMUNICATION_GROUP\_-](#_bookmark22) [CLIENT](#_bookmark22)).

> 多个类型为Communication Group client的Service Proxy实例（ServiceInterface，其类别值为[COMMUNICATION_GROUP\_-] [CLIENT]）。

Note: The number of Service Proxy instantiations is implementation and use case dependent. The theoretical limit (not considering for memory space re- quirements) is the available number of Communication client *Client_IDs*. On the other side there might be Safety requirements which force the design to support a limited known number of Communication Group clients.

### Remote Connection


As mentioned before the Communication Group server or clients can be remote from the Communication Group instance. This is supported since the Communication Group is designed as composite service. Therefore also no limit in terms of AUTOSAR Classic and Adaptive platforms.

> 提到过，通信组服务器或客户端可以远程访问通信组实例。这是可行的，因为通信组被设计为复合服务。因此，对于AUTOSAR Classic和Adaptive平台也没有限制。

### Service Versioning


Service contract versioning is supported by the Communication Group by the according

> 通信小组支持服务合同版本控制。

ServiceInterfaces.

# Tutorials


This selection of tutorials shows some minimal examples on how to use the fundamen- tals and features of ara::com.

> 这个教程选择展示了一些关于如何使用ara::com的基础和特性的最小示例。

## Usage of Service Interfaces


The [ara::com](#_bookmark15) model elements related to both design and deployment are included in the Manifest. Since not all the model elements are relevant in all the development phases, the Manifest can be divided in different partitions:

> 清单中包含了与设计和部署相关的[ara::com](#_bookmark15)模型元素。由于不是所有的模型元素都与所有的开发阶段相关，因此清单可以分为不同的分区。


- **Machine Manifest:** Specifies where the Adaptive AUTOSAR Software Stack is running. In the MachineDesign the Communication System structure is speci- fied. This includes CommunicationConnectors and NetworkEndpoints.

> - **机器清单：** 指定Adaptive AUTOSAR软件堆栈运行的位置。在MachineDesign中指定通信系统结构。这包括通信连接器和网络端点。
- [**SI**](#_bookmark71) **Manifest:** Specifies the events, methods and fields that a Service provides.

- **Execution Manifest:** Specifies the information related to the deployment of the applications. This includes Executables and Processes. The executable refer- ences an rootSwComponentPrototype.

> 执行清单：指定与应用程序部署相关的信息。这包括可执行文件和进程。可执行文件引用rootSwComponentPrototype。

- **RPortPrototypes and PPortPrototypes:** The rootSwComponentPrototype has an Application Type that defines PPortPrototypes and RPortProto- types and they reference the corresponding [SI](#_bookmark71)

> - **RPortPrototypes 和 PPortPrototypes：** rootSwComponentPrototype 有一个应用类型，它定义了 PPortPrototypes 和 RPortPrototypes，它们引用相应的[SI](#_bookmark71)。


For all the details about the manifest specification please see the \[[2](#_bookmark1)\].

> 请参阅[[2](#_bookmark1)]获取有关清单规范的所有详细信息。


Assuming that the previously mentioned partitions of the Manifest exist, the following sections describe the deployment of [SI](#_bookmark71) and ServiceInstance. Finally the most relevant aspects related with the implementation are also introduced.

> 假设之前提到的Manifest的分区存在，以下部分描述了[SI](#_bookmark71)和ServiceInstance的部署。最后还介绍了与实施相关的最相关的方面。

### Service Interface Deployment


The [SI](#_bookmark71) Deployment describes how the [SI](#_bookmark71) will communicate over the network. The following information must be provided:

> SI部署描述了SI如何通过网络进行通信。必须提供以下信息：

- Reference to the network binding used in the [SI](#_bookmark71) Deployment (e.g. SOME/IP, DDS)
- [SI](#_bookmark71) ID

- Deployment information for the Events, Methods and Fields. This includes IDs and any Network Binding specific information (e.g. Transport Protocol)

> 部署事件、方法和字段的信息，包括ID和任何网络绑定特定信息（例如传输协议）。

```

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**ServiceInterfaceDeployments**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<SOMEIP-SERVICE-INTERFACE-DEPLOYMENT\>**

 **\<EVENT-DEPLOYMENTS\>**

 **\<SOMEIP-EVENT-DEPLOYMENT\>**

 **\<SHORT-NAME\>**Counter_SOMEIP**\</SHORT-NAME\>**

 **\<EVENT-REF DEST=**\"VARIABLE-DATA-PROTOTYPE\"**\>**/myExample/

 ServiceInterfaces/myInterface/Counter**\</EVENT-REF\>**

 **\<EVENT-ID\>**1**\</EVENT-ID\>**

 **\<TRANSPORT-PROTOCOL\>**UDP**\</TRANSPORT-PROTOCOL\>**

 **\</SOMEIP-EVENT-DEPLOYMENT\>**

 **\</EVENT-DEPLOYMENTS\>**

 **\<SERVICE-INTERFACE-REF DEST=**\"SERVICE-INTERFACE\"**\>**/myExample/

 ServiceInterfaces/myInterface**\</SERVICE-INTERFACE-REF\>**

 **\<SERVICE-INTERFACE-ID\>**99**\</SERVICE-INTERFACE-ID\>**

 **\<SERVICE-INTERFACE-VERSION\>**

 **\<MAJOR-VERSION\>**1**\</MAJOR-VERSION\>**

 **\<MINOR-VERSION\>**0**\</MINOR-VERSION\>**

 **\</SERVICE-INTERFACE-VERSION\>**

 **\</SOMEIP-SERVICE-INTERFACE-DEPLOYMENT\>**

 **\</ELEMENTS\>**

 **\</AR-PACKAGE\>**

 **Listing 6.1: Example Service Interface Deployment**

```

![](./media/image29.png)![](./media/image29.png)+methodDeployment

![](./media/image30.png)![](./media/image33.png)+fieldDeployment

![](./media/image34.png)+eventDeployment

![](./media/image35.png)0..\*

**Figure 6.1:** []{#_bookmark175 .anchor}**SOME/IP Service Insterface Deployment**

### Service Instance Deployment


The Service Instance Deployment consists of Service Instance mapping to Application Endpoints and to Machine.

> 服务实例部署包括将服务实例映射到应用程序端点和机器。


The mapping to ApplicationEndpoints connects a ServiceInstance to a

> 映射到ApplicationEndpoints将服务实例连接起来


PortPrototype and Process.

> 端口原型和流程

```

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**ServiceInstanceToPortPrototypeMappings**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<SHORT-NAME\>**ProvidedServiceInstance_toPort**\</SHORT-NAME\>**

 **\<PORT-PROTOTYPE-IREF\>**

 **\<CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF DEST=**\"ROOT-SW-COMPONENT-

 PROTOTYPE\"**\>**/myExample/Executables/myExecutable/ mySwComponentPrototype**\</CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF\>**

 **\<TARGET-PORT-PROTOTYPE-REF DEST=**\"P-PORT-PROTOTYPE\"**\>**/apd/

 AdaptiveApplicationSwComponentTypes/Publisher/myInterface_PPort**\<**

 **/TARGET-PORT-PROTOTYPE-REF\>**

 **\</PORT-PROTOTYPE-IREF\>**

 **\<PROCESS-REF DEST=**\"PROCESS\"**\>**/apd/Machines/PublisherMachine/ Processes/myProcess**\</PROCESS-REF\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"PROVIDED-SOMEIP-SERVICE-INSTANCE\"**\>**/

 myExample/Machines/myMachine/ServiceInstances/ ProvidedSomeipServiceInstance**\</SERVICE-INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\</ELEMENTS\>**

 **\</AR-PACKAGE\>**

 **Listing 6.2: Example Service Interface Manifest**

 +portPrototype

 «instanceRef,atpUriDef»

 0..1

 +processDesign

«atpUriDef»

 0..1

 0..1

+serviceInstance

0..1

+serviceInterfaceDeployment

0..1

 **Figure 6.2: Service Instance to Port Prototype Mapping**

 The mapping to a Machine connects the ServiceInstance to a Communication- Connector.

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**ServiceInstanceToMachineMappings**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<SOMEIP-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\<SHORT-NAME\>**ProvidedServiceInstance_toMachine**\</SHORT-NAME\>**

 **\<COMMUNICATION-CONNECTOR-REF DEST=**\"ETHERNET-COMMUNICATION-CONNECTOR

 \"**\>**/myExample/MachineDesigns/myMachineDesign/myConnector**\</ COMMUNICATION-CONNECTOR-REF\>**

 **\<SERVICE-INSTANCE-REFS\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"PROVIDED-SOMEIP-SERVICE-INSTANCE\"**\>**/

 myExample/Machines/myMachine/ServiceInstances/ ProvidedSomeipServiceInstance**\</SERVICE-INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-REFS\>**

 **\</SOMEIP-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\</ELEMENTS\>**

 **\</AR-PACKAGE\>**

 **Listing 6.3: Example Service Instance to Machine Mapping**

![](./media/image32.png)

+serviceInstance

0..\*

+serviceInterfaceDeployment

0..1

 **Figure 6.3: Service InstanceToMachineMapping**

 The CommunicationConnector references a NetworkEndpoint that includes Ad- dress, Network Mask and Gateway.

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**CommunicationClusters**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<ETHERNET-CLUSTER\>**

 **\<SHORT-NAME\>**myNet**\</SHORT-NAME\>**

 **\<ETHERNET-CLUSTER-VARIANTS\>**

 **\<ETHERNET-CLUSTER-CONDITIONAL\>**

 **\<PHYSICAL-CHANNELS\>**

 **\<ETHERNET-PHYSICAL-CHANNEL\>**

 **\<SHORT-NAME\>**myChannel**\</SHORT-NAME\>**

 **\<COMM-CONNECTORS\>**

 **\<COMMUNICATION-CONNECTOR-REF-CONDITIONAL\>**

 **\<COMMUNICATION-CONNECTOR-REF DEST=**\"ETHERNET-COMMUNICATION-

 CONNECTOR\"**\>**/myExample/MachineDesigns/myMachineDesign/ myConnector**\</COMMUNICATION-CONNECTOR-REF\>**

 **\</COMMUNICATION-CONNECTOR-REF-CONDITIONAL\>**

 **\</COMM-CONNECTORS\>**

 **\<NETWORK-ENDPOINTS\>**

 **\<NETWORK-ENDPOINT\>**

 **\<SHORT-NAME\>**myMachineEndpoint**\</SHORT-NAME\>**

 **\<FULLY-QUALIFIED-DOMAIN-NAME/\>**

 **\<NETWORK-ENDPOINT-ADDRESSES\>**

 **\<IPV-4-CONFIGURATION\>**

 **\<DEFAULT-GATEWAY\>**192.168.7.1**\</DEFAULT-GATEWAY\>**

 **\<IPV-4-ADDRESS\>**192.168.7.2**\</IPV-4-ADDRESS\>**

 **\<NETWORK-MASK\>**255.255.255.0**\</NETWORK-MASK\>**

 **\</IPV-4-CONFIGURATION\>**

 **\</NETWORK-ENDPOINT-ADDRESSES\>**

 **\</NETWORK-ENDPOINT\>**

 **\<SHORT-NAME\>**mySDEndpoint**\</SHORT-NAME\>**

 **\<FULLY-QUALIFIED-DOMAIN-NAME/\>**

 **\<NETWORK-ENDPOINT-ADDRESSES\>**

 **\<IPV-4-CONFIGURATION\>**

 **\<IPV-4-ADDRESS\>**224.244.224.245**\</IPV-4-ADDRESS\>**

 **\</IPV-4-CONFIGURATION\>**

 **\</NETWORK-ENDPOINT-ADDRESSES\>**

 **\</NETWORK-ENDPOINT\>**

 **\</NETWORK-ENDPOINTS\>**

 **\</ETHERNET-PHYSICAL-CHANNEL\>**

 **\</PHYSICAL-CHANNELS\>**

 **\</ETHERNET-CLUSTER-CONDITIONAL\>**

 **\</ETHERNET-CLUSTER-VARIANTS\>**

 **\</ETHERNET-CLUSTER\>**

 **\</ELEMENTS\>**

 **\</AR-PACKAGE\>**

 ![](./media/image38.png){width="0.154086832895888in" height="7.999890638670167e-2in"}**Listing 6.4: Example Service Interface Manifest**

+----------------------------------------------+---------------------------+------------------------------------------------------------+
| *AtpStructureElement*                        | > +communicationConnector | > *Identifiable*                                           |
|                                              |                           | >                                                          |
| *FibexElement*                               |                           | > *CommunicationConnector*                                 |
|                                              |                           |                                                            |
| > MachineDesign                              |                           |                                                            |
+==============================================+===========================+============================================================+
|                                              |                           | \+ createEcuWakeupSource: Boolean \[0..1\]                 |
|                                              |                           |                                                            |
|                                              |                           | \+ pncFilterArrayMask: PositiveInteger \[0..\*\] {ordered} |
+----------------------------------------------+---------------------------+------------------------------------------------------------+
| \+ accessControl: AccessControlEnum \[0..1\] | > «atpSplitable» 0..\*    |                                                            |
|                                              |                           |                                                            |
| \+ pncPrepareSleepTimer: TimeValue \[0..1\]  |                           |                                                            |
|                                              |                           |                                                            |
| \+ pnResetTimer: TimeValue \[0..1\]          |                           |                                                            |
+----------------------------------------------+---------------------------+------------------------------------------------------------+

 ![](./media/image39.png)![](./media/image43.png)EthernetCommunicationConnector

 \+ maximumTransmissionUnit: PositiveInteger \[0..1\]

 \+ neighborCacheSize: PositiveInteger \[0..1\]

 \+ pathMtuEnabled: Boolean \[0..1\]

 \+ pathMtuTimeout: TimeValue \[0..1\]

 ![](./media/image44.png)«atpVariation,atpSplitable»

 +physicalChannel 1..\*

 *Identifiable*

+unicastNetworkEndpoint

NetworkEndpoint

 0..\*

 *Identifiable*

*PhysicalChannel*

 \+ fullyQualifiedDomainName: String \[0..1\]

 \+ priority: PositiveInteger \[0..1\]

0..\*

 +networkEndpoint

 «atpSplitable»

 +networkEndpointAddress 1..\*

 EthernetPhysicalChannel *NetworkEndpointAddress*

Ipv4Configuration

 \+ assignmentPriority: PositiveInteger \[0..1\]

 \+ defaultGateway: Ip4AddressString \[0..1\]

 \+ dnsServerAddress: Ip4AddressString \[0..\*\]

 \+ ipAddressKeepBehavior: IpAddressKeepEnum \[0..1\]

 \+ ipv4Address: Ip4AddressString \[0..1\]

 \+ ipv4AddressSource: Ipv4AddressSourceEnum \[0..1\]

 \+ networkMask: Ip4AddressString \[0..1\]

 \+ ttl: PositiveInteger \[0..1\]

 Ipv6Configuration

 \+ assignmentPriority: PositiveInteger \[0..1\]

 \+ defaultRouter: Ip6AddressString \[0..1\]

 \+ dnsServerAddress: Ip6AddressString \[0..\*\]

 \+ enableAnycast: Boolean \[0..1\]

 \+ hopCount: PositiveInteger \[0..1\]

 \+ ipAddressKeepBehavior: IpAddressKeepEnum \[0..1\]

 \+ ipAddressPrefixLength: PositiveInteger \[0..1\]

 \+ ipv6Address: Ip6AddressString \[0..1\]

 \+ ipv6AddressSource: Ipv6AddressSourceEnum \[0..1\]

 **Figure 6.4: Network Connection**

```

### Service Implementation


Services are implemented in an application layer and are also used by the other applications. To enable the communication be- tween both applications the Service Discovery protocol is used.

> 服务在应用层实现，也被其他应用程序使用。为了实现两个应用之间的通信，使用服务发现协议。

**Figure 6.5: Service Discovery**


The Communication Management provides a method in the Service Skeleton class to offer the service:

> 通信管理在服务骨架类中提供了一种方法，以提供服务。

```
 ara::core::Result\<void\> OfferService();
```


After the method OfferService() has been called, the service can be found by the applications. The Communication Management provides in the Service Proxy class a methods to find a service according to the [InstanceIdentifier](#_bookmark31) or InstanceSpecifier:

> 在调用OfferService（）方法之后，应用程序可以找到该服务。通信管理在Service Proxy类中提供了根据[InstanceIdentifier]（#_bookmark31）或InstanceSpecifier查找服务的方法：

```

 static ara::core::Result\<ara::com::ServiceHandleContainer\<

 \<ProxyClassName\>::HandleType\>\> FindService(ara::com::InstanceIdentifier instance);

 static ara::core::Result\<ara::com::ServiceHandleContainer\<

 \<ProxyClassName\>::HandleType\>\> FindService(ara::core::InstanceSpecifier instance);

```


These methods return a ServiceHandleContainer that can have different number of elements:

> 这些方法返回一个可以具有不同数量元素的ServiceHandleContainer。

- Empty: No Service Instance was found
- One: A single Service instance was found
- Several: Multiple Service instances were found


The example in [5.5](#_bookmark115) (lines 52 - 60) shows how to create a Service Proxy using

> [5.5](#_bookmark115) 中（52-60 行）的示例展示了如何创建服务代理。

FindService().


A Service Handler gives access to all the events, methods and fields of the service. For the events, the application has to subscibe to the events using the corresponding method setting also the size of the cache for this event :

> 服务处理程序提供对服务的所有事件、方法和字段的访问。对于事件，应用程序必须使用相应的方法订阅事件，同时还要为该事件设置缓存大小。

```

 ara::core:Result\<void\> Event::Subscribe(size_t maxSampleCount);

```


To unsubscribe to an event the Unsubscribe method must be used:

> 要取消订阅某个事件，必须使用取消订阅方法。

```

 void Event::Unsubscribe();

```


The example in [5.5](#_bookmark115) (lines 62 - 64) shows how to subscribe for an event.

> 例子[5.5](#_bookmark115)（行62-64）展示了如何订阅一个事件。


The application code for the Service Proxy and Skeleton is generated according to the [SI](#_bookmark71) defined in the Manifest. An example of the generated code for the Proxy Class can be found in the [5.2](#_bookmark104) and for the Skeleton Class in [5.12](#_bookmark127)

> 应用程序代码根据清单中定义的[SI](#_bookmark71)为服务代理和骨架生成。 代理类的生成代码的示例可以在[5.2](#_bookmark104)中找到，而骨架类在[5.12](#_bookmark127)中找到。

## Usage of InstanceSpecifier


InstanceSpecifier is a core concept defined in \[[3](#_bookmark2)\], representing a \"/\"-separated list of shortNames of model elements conforming an absolute path to an specific model element. In less formal terms, Instance Specifiers bridge Adaptive Platform models and applications, allowing application code to unequivocally reference resource instances defined by the system model.

> 实例指示符是在[[3]](#_bookmark2)中定义的核心概念，它表示一个"/"分隔的模型元素的简称列表，构成一个到特定模型元素的绝对路径。用不太正式的话说，实例指示符桥接自适应平台模型和应用程序，允许应用程序代码明确引用系统模型定义的资源实例。


The instances referenced by Instance Specifiers may be of many different kinds: pro- vided or required service instances, key/value or file stores, or cryptographic resources, to name a few.

> 实例规范所指的实例可以是多种不同类型的：提供的或所需的服务实例、键/值或文件存储，或者加密资源，这只是其中的一些。


In the C++ language binding of the Adaptive Platform, the InstanceSpecifier class has several common traits:

> 在Adaptive Platform的C++语言绑定中，InstanceSpecifier类具有几个常见特征：

- It is **not** default constructible.
- It is copiable and movable.
- It is comparable against StringView and other InstanceSpecifier objects.
- It is explicitly convertible to StringView.


See listing [4.2](#_bookmark93) in chapter [subsection](#instance-identifiers-and-instance-specifiers) [4.8.1](#instance-identifiers-and-instance-specifiers) for more detailed information.

> 请参阅第4.8.1节（实例标识符和实例规范）中的4.2列表，以获取更详细的信息。


Considering these characteristics, the only way to create a new InstanceSpecifier object that's not a copy or a move of an existing one is to do so from a StringView object.

> 考虑到这些特征，创建一个新的InstanceSpecifier对象而不是复制或移动现有对象的唯一方法是从StringView对象中进行。


In practice, the contents of such StringView are syntactically but not semantically checked upon construction. This means that construction succeeds as long as the source StringView object contains a \"/\"-separated list of names conformed only of

> 在实践中，这种StringView的内容在构建时只进行了语法检查，而没有进行语义检查。这意味着，只要源StringView对象包含了一个仅由“/”分隔的名称列表，构建就会成功。


from which the application derives, is something that will be checked by the different functional clusters when attempting to access or instantiate resources pointed by the InstanceSpecifier in question.

> 此应用所派生的内容，将在尝试访问或实例化由问题中的InstanceSpecifier指向的资源时，由不同的功能集群进行检查。


The following examples show the way in which, according to \[[1](#_bookmark0)\], InstanceSpeci- fiers might be used to instantiate and access services via skeleton and proxy classes.

> 以下示例展示了根据[1]，使用InstanceSpeci-fiers实例化和通过骨架和代理类访问服务的方式。


Instance specifiers point to instances of port prototypes associated with a service. Therefore multiple instance specifiers for each PortPrototype can be created. In the examples below, *SwComponentInstance_0* and *SwComponentInstance_1* are 2 instantiations of the the same SwComponentPrototype, containing the RPortPro- totype *RPort_3*:

> 实例说明符指向与服务关联的端口原型的实例。因此，可以为每个PortPrototype创建多个实例说明符。在下面的示例中，* SwComponentInstance_0 *和* SwComponentInstance_1 *是同一个SwComponentPrototype的两个实例，其中包含RPortPro- totype * RPort_3 *：

```

#include \"ara/core/instance_specifier.h\"

#include \"ara/com/sample/tire_skeleton.h\"

class TireSkeletonImplementation : public ara::com::sample::skeleton:: TireSkeleton

{

using TireSkeleton::TireSkeleton;

// Implement service interface methods, if any

};

int main()

{

const ara::core::InstanceSpecifier tire0_Instance{\"/ServerExe/ RootSWCP_0/Comp_Lvl1/Comp_Lvl2/SwComponentInstance_0/PPort_3\"};

const ara::core::InstanceSpecifier tire1_Instance{\"/ServerExe/ RootSWCP_0/Comp_Lvl1/Comp_Lvl2/SwComponentInstance_1/PPort_3\"};

TireSkeletonImplementation tire0(tire0_Instance);

TireSkeletonImplementation tire1(tire1_Instance);

// Sleep while Skeleton instances run, process requests, etc.

return 0;

}

 **Listing 6.5: Example Usage of Instance Specifiers with Skeletons**

#include \"ara/core/instance_specifier.h\"

#include \"ara/com/sample/tire_proxy.h\"

int main()

{

using Proxy = ara::com::sample::proxy::TireProxy;

const ara::core::InstanceSpecifier tire0_Instance{\"/ClientExe/ RootSWCP_0/Comp_Lvl1/Comp_Lvl2/SwComponentInstance_0/RPort_3\"};

const ara::core::InstanceSpecifier tire1_Instance{\"/ClientExe/ RootSWCP_0/Comp_Lvl1/Comp_Lvl2/SwComponentInstance_1/RPort_3\"};

auto tire0_handles = Proxy::FindService(tire0_Instance).ValueOrThrow();

auto tire1_handles = Proxy::FindService(tire1_Instance).ValueOrThrow();

Proxy tire0(tire0_handles\[0\]);

Proxy tire1(tire1_handles\[0\]);

// Call methods, subscribe to events, etc.

return 0;

}

```


**Listing 6.6: Example Usage of Instance Specifiers with Proxies**

> 例6.6：使用代理的实例指定示例


In these examples the AUTOSAR Adaptive implementation manages process-specific manifests with isolated contexts. These can be dictated on process startup via e.g. command line arguments, environment variables, working directory contents or any other implementation-specific means.

> 在这些示例中，AUTOSAR Adaptive实施管理具有隔离上下文的特定进程清单。这些可以通过例如命令行参数、环境变量、工作目录内容或任何其他实施特定的方式在进程启动时指定。

### Modeling and configuration/mapping over Manifest from user perspective


The InstanceSpecifier used for finding a service maps to the particular instance of the port associated with that service.

> 实例指定符用于查找服务映射到与该服务关联的端口的特定实例。

```

#include \"ara/core/instance_specifier.h\"

#include \"ara/com/sample/radar_proxy.h\"

 4

int main() {

using Proxy = ara::com::sample::proxy::radarProxy;

// \...

ara::core::InstanceSpecifier portSpecifier{\"fusionExe/fusion/ radar_RPort\"};

auto res = Proxy::FindService(portSpecifier);

//\....

}

```


**Listing 6.7: CPP Example Usage with FindService**

> **列表6.7：使用FindService的CPP示例**


In the Application Design, the Executable node specifies its RootSwCompo- nentPrototype. In turn the SwComponentPrototype defines one or more Port- Prototype.

> 在应用程序设计中，可执行节点指定其根SwComponentPrototype。反过来，SwComponentPrototype定义一个或多个端口原型。

```

 **\<?xml version=**\"1.0\" **encoding=**\"UTF-8\"**?\>**

 **\<AUTOSAR xmlns=**[\"http://autosar.org/schema/r4.0\"](http://autosar.org/schema/r4.0) **xmlns:xsi=**\"http://www.w3. org/2001/XMLSchema-instance\" **xsi:schemaLocation=**[\"http://autosar.org/](http://autosar.org/) schema/r4.0 AUTOSAR_00049.xsd\"**\>**

 **\<AR-PACKAGES\>**

 **\<AR-PACKAGE\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**apd**\</SHORT-NAME\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**da**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<EXECUTABLE\>**

 **\<SHORT-NAME\>**fusionExe**\</SHORT-NAME\>**

 **\<CATEGORY\>**APPLICATION_LEVEL**\</CATEGORY\>**

 **\<SHORT-NAME\>**fusion**\</SHORT-NAME\>**

 **\<APPLICATION-TYPE-TREF DEST=**\"ADAPTIVE-APPLICATION-SW- COMPONENT-TYPE\"**\>**/apd/da/fusion**\</APPLICATION-TYPE-TREF\>**

 **\</ROOT-SW-COMPONENT-PROTOTYPE\>**

 **\</EXECUTABLE\>**

 **\<ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE\>**

 **\<SHORT-NAME\>**fusion**\</SHORT-NAME\>**

 **\<PORTS\>**

 **\<R-PORT-PROTOTYPE\>**

 **\<SHORT-NAME\>**radar_RPort**\</SHORT-NAME\>**

 **\<REQUIRED-INTERFACE-TREF DEST=**\"SERVICE-INTERFACE\"**\>**/apd/da

 /radar**\</REQUIRED-INTERFACE-TREF\>**

 **\</R-PORT-PROTOTYPE\>**

 **\</PORTS\>**

 **\</ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE\>**

 **\<SOMEIP-SERVICE-INTERFACE-DEPLOYMENT\>**

 **\<SHORT-NAME\>**radar_Someip**\</SHORT-NAME\>**

 **\<!*\-- \...\... \--*\>**

 **\</SOMEIP-SERVICE-INTERFACE-DEPLOYMENT\>**

**\</ELEMENTS\>**

**\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGES\>**

 **\</AUTOSAR\>**

 **Listing 6.8: Path towards port instance**

```


See [Figure](#_bookmark175) [6.1](#_bookmark175) for the SOME/IP Service Interface Deployment.

> 见[图6.1](#_bookmark175)，了解SOME / IP服务接口部署情况。


The mapping between a RequiredServiceInstance and an InstanceSpeci- fier is done via the *Service Instance Manifest*. In the Service Instance Man- ifest the ServiceInstanceToPortPrototypeMapping defines which *Service Instance* is associated with a certain port inside a specific RootSwComponentProto- type. The RequiredServiceInstance specifies the InstanceId as Require- ServiceInstanceId, in the example below this value is 19.

> 在服务实例清单中，ServiceInstanceToPortPrototypeMapping定义了哪个服务实例与特定RootSwComponentPrototype中的特定端口相关联。RequiredServiceInstance指定InstanceId作为RequiredServiceInstanceId，在下面的示例中，该值为19，这就完成了RequiredServiceInstance和InstanceSpecifier之间的映射。

```

 **\<?xml version=**\"1.0\" **encoding=**\"UTF-8\"**?\>**

 **\<AUTOSAR xmlns=**[\"http://autosar.org/schema/r4.0\"](http://autosar.org/schema/r4.0) **xmlns:xsi=**\"http://www.w3. org/2001/XMLSchema-instance\" **xsi:schemaLocation=**[\"http://autosar.org/](http://autosar.org/) schema/r4.0 AUTOSAR_00049.xsd\"**\>**

 **\<AR-PACKAGES\>**

 **\<AR-PACKAGE\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**apd**\</SHORT-NAME\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**da**\</SHORT-NAME\>**

 **\<AR-PACKAGE\>**

 **\<ELEMENTS\>**

 **\<SHORT-NAME\>**instance**\</SHORT-NAME\>**

 **\<SHORT-NAME\>**radar_RequiredServiceInstance_toMachine**\</ SHORT-NAME\>**

 **\<COMMUNICATION-CONNECTOR-REF DEST=**\"ETHERNET-

 COMMUNICATION-CONNECTOR\"**\>**/apd/da/fusionMachineDesign

 /fusionCommunicationConnector**\</COMMUNICATION- CONNECTOR-REF\>**

 **\<SERVICE-INSTANCE-REFS\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"REQUIRED-SOMEIP-SERVICE-

 INSTANCE\"**\>**/apd/da/instance/ radar_RequiredSomeipServiceInstance**\</SERVICE- INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-REFS\>**

 **\<UDP-PORT\>**33111**\</UDP-PORT\>**

 **\</SOMEIP-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\<SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<SHORT-NAME\>**radar_RequiredServiceInstance_toPort**\</SHORT**

 **-NAME\>**

 **\<PORT-PROTOTYPE-IREF\>**

 **\<CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF DEST=**\"ROOT-

 SW-COMPONENT-PROTOTYPE\"**\>**/apd/da/fusionExe/fusion**\</ CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF\>**

 **\<TARGET-PORT-PROTOTYPE-REF DEST=**\"R-PORT-PROTOTYPE\"**\>**/

 apd/da/fusion/radar_RPort**\</TARGET-PORT-PROTOTYPE- REF\>**

 **\</PORT-PROTOTYPE-IREF\>**

 **\<PROCESS-REF DEST=**\"PROCESS\"**\>**/apd/da/fusion_instance1**\</ PROCESS-REF\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"REQUIRED-SOMEIP-SERVICE-

 INSTANCE\"**\>**/apd/da/instance/ radar_RequiredSomeipServiceInstance**\</SERVICE- INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<REQUIRED-SOMEIP-SERVICE-INSTANCE\>**

 **\<SHORT-NAME\>**radar_RequiredSomeipServiceInstance**\</SHORT- NAME\>**

 **\<SERVICE-INTERFACE-DEPLOYMENT-REF DEST=**\"SOMEIP-SERVICE-

 INTERFACE-DEPLOYMENT\"**\>**/apd/da/deployment/ radar_Someip**\</SERVICE-INTERFACE-DEPLOYMENT-REF\>**

 **\<!*\-- \...\... \--*\>**

 **\<REQUIRED-MINOR-VERSION\>**0**\</REQUIRED-MINOR-VERSION\>**

 **\<REQUIRED-SERVICE-INSTANCE-ID\>**19**\</REQUIRED-SERVICE- INSTANCE-ID\>**

 **\</REQUIRED-SOMEIP-SERVICE-INSTANCE\>**

**\</ELEMENTS\>**

**\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGES\>**

 **\</AUTOSAR\>**

```


**Listing 6.9: Service Instance Manifest specification of RequiredServiceInstance**

> 列表6.9：RequiredServiceInstance服务实例清单规格

![](./media/image45.png)

![](./media/image49.png)**Figure 6.6: SOME/IP Required Service Instance Deployment**


**Note**: An executable can be started multiple times. Each of the processes is started with a different Service Instance Manifest, therefore the mapping between an In- stanceSpecifier and a RequiredServiceInstance will be different between the separate processes.

> **注意**：可执行文件可以被多次启动。每个进程都使用不同的服务实例清单启动，因此InstanceSpecifier和RequiredServiceInstance之间的映射在不同的进程之间会有所不同。

### Instance IDs only for provided Services


The InstanceSpecifier and the [InstanceIdentifier](#_bookmark31) can be used to uniquely identify a provided service. This means that clients know which particular service instance they are communicating with. This information is lacking for provided services. Clients can't be uniquely identified with an [InstanceIdentifier](#_bookmark31), therefore the server can't know for sure with which client it communicates with. For most cases this is not a problem, however we envision that for safety this can be a problem. For these cases we recommend using the E2E parameter dataID of the method E2E_check (see \[PRS_E2E_00323\] of \[[10](#_bookmark9)\]).

> 实例规范和[实例标识符](#_bookmark31)可用于唯一标识提供的服务。这意味着客户端知道它们正在与哪个特定服务实例通信。但是，提供的服务缺少此信息。无法使用[实例标识符](#_bookmark31)来唯一标识客户端，因此服务器无法确定它正在与哪个客户端通信。在大多数情况下，这不是问题，但我们认为，为了安全起见，这可能是一个问题。对于这些情况，我们建议使用方法E2E_check的E2E参数dataID（请参见\[[10](#_bookmark9)\]中的\[PRS_E2E_00323\]）。

## Usage in context of MultiBinding


The following section revamps the example shown in [6.2.1](#modeling-and-configurationmapping-over-manifest-from-user-perspective), depicting how multiple network bindings for a single PPortPrototype can be defined in the Application and Instance Manifests without altering the Adaptive Application's source code. In this case, we will add an additional DDS-based instatiation of the /apd/da/radar [SI](#_bookmark71).

> 以下部分重新编排了[6.2.1](#modeling-and-configurationmapping-over-manifest-from-user-perspective)中示例所示，描述了如何在应用程序和实例清单中为单个PPortPrototype定义多个网络绑定，而不改变自适应应用程序的源代码。在这种情况下，我们将添加另一个基于DDS的/apd/da/radar [SI](#_bookmark71)实例。


To begin with, the Application Manifest is extended with an DdsServiceInter- faceDeployment, named radar_Dds, portraying DDS-specific deployment ele- ments of the [SI](#_bookmark71):

> 首先，应用程序清单被扩展了一个叫做radar_Dds的DdsServiceInterfaceDeployment，描述了[SI](#_bookmark71)的DDS特定部署元素。

```

 **\<?xml version=**\"1.0\" **encoding=**\"UTF-8\"**?\>**

 **\<AUTOSAR xmlns=**[\"http://autosar.org/schema/r4.0\"](http://autosar.org/schema/r4.0) **xmlns:xsi=**\"http://www.w3. org/2001/XMLSchema-instance\" **xsi:schemaLocation=**[\"http://autosar.org/](http://autosar.org/) schema/r4.0 AUTOSAR_00049.xsd\"**\>**

 **\<AR-PACKAGES\>**

 **\<AR-PACKAGE\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**apd**\</SHORT-NAME\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**da**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<EXECUTABLE\>**

 **\<SHORT-NAME\>**fusionExe**\</SHORT-NAME\>**

 **\<CATEGORY\>**APPLICATION_LEVEL**\</CATEGORY\>**

 **\<ROOT-SW-COMPONENT-PROTOTYPE\>**

 **\<SHORT-NAME\>**fusion**\</SHORT-NAME\>**

 **\<APPLICATION-TYPE-TREF DEST=**\"ADAPTIVE-APPLICATION-SW- COMPONENT-TYPE\"**\>**/apd/da/fusion**\</APPLICATION-TYPE-TREF\>**

 **\</ROOT-SW-COMPONENT-PROTOTYPE\>**

 **\</EXECUTABLE\>**

 **\<ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE\>**

 **\<SHORT-NAME\>**fusion**\</SHORT-NAME\>**

 **\<PORTS\>**

 **\<P-PORT-PROTOTYPE\>**

 **\<SHORT-NAME\>**radar_PPort**\</SHORT-NAME\>**

 **\<PROVIDED-INTERFACE-TREF DEST=**\"SERVICE-INTERFACE\"**\>**/apd/da

 /radar**\</PROVIDED-INTERFACE-TREF\>**

 **\</P-PORT-PROTOTYPE\>**

 **\</PORTS\>**

 **\</ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE\>**

 **\<SOMEIP-SERVICE-INTERFACE-DEPLOYMENT\>**

 **\<SHORT-NAME\>**radar_Someip**\</SHORT-NAME\>**

 **\<!*\-- \...\... \--*\>**

 **\</SOMEIP-SERVICE-INTERFACE-DEPLOYMENT\>**

 **\<DDS-SERVICE-INTERFACE-DEPLOYMENT\>**

 **\<SHORT-NAME\>**radar_Dds**\</SHORT-NAME\>**

 **\<!*\-- \...\... \--*\>**

 **\</DDS-SERVICE-INTERFACE-DEPLOYMENT\>**

**\</ELEMENTS\>**

**\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGES\>**

 **\</AUTOSAR\>**

```


**Listing 6.10: Path towards port instance**

> 列表6.10：前往端口实例的路径


See [Figure](#_bookmark175) [6.1](#_bookmark175) for the SOME/IP Service Interface Deployment.

> 请参考图6.1，了解SOME/IP服务接口部署情况。

![](./media/image50.png)+fieldDeployment

![](./media/image51.png)![](./media/image52.png)![](./media/image53.png)+eventDeployment

0..\*

![](./media/image54.png){width="8.022747156605424e-2in" height="0.15312445319335083in"}

```

 +fieldTopicsAccessRule

 +eventTopicAccessRule 0..1

0..1

```

**Figure 6.7: DDS Service Interface Deployment**


In the Instance Manifest, separate sets of ServiceInstanceToMachineMap- ping, ServiceInstanceToPortPrototypeMapping and ProvidedService- Instance are listed, each defining SOME/IP and DDS-specific deployment param- eters.

> 在实例清单中，列出了单独的ServiceInstanceToMachineMapping、ServiceInstanceToPortPrototypeMapping和ProvidedServiceInstance集合，每个集合定义了SOME/IP和DDS特定的部署参数。

```

 **\<?xml version=**\"1.0\" **encoding=**\"UTF-8\"**?\>**

 **\<AUTOSAR xmlns=**[\"http://autosar.org/schema/r4.0\"](http://autosar.org/schema/r4.0) **xmlns:xsi=**\"http://www.w3. org/2001/XMLSchema-instance\" **xsi:schemaLocation=**[\"http://autosar.org/](http://autosar.org/) schema/r4.0 AUTOSAR_00049.xsd\"**\>**

 **\<AR-PACKAGES\>**

 **\<AR-PACKAGE\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**apd**\</SHORT-NAME\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**da**\</SHORT-NAME\>**

 **\<AR-PACKAGE\>**

 **\<SHORT-NAME\>**instance**\</SHORT-NAME\>**

 **\<ELEMENTS\>**

 **\<!*\-- For SOME/IP \--*\>**

 **\<SOMEIP-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\<SHORT-NAME\>**

 radar_ProvidedServiceInstance_toMachine_Someip**\</ SHORT-NAME\>**

 **\<COMMUNICATION-CONNECTOR-REF DEST=**\"ETHERNET-

 COMMUNICATION-CONNECTOR\"**\>**/apd/da/fusionMachineDesign

 /fusionCommunicationConnector**\</COMMUNICATION- CONNECTOR-REF\>**

 **\<SERVICE-INSTANCE-REFS\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"PROVIDED-SOMEIP-SERVICE-

 INSTANCE\"**\>**/apd/da/instance/ radar_ProvidedSomeipServiceInstance**\</SERVICE- INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-REFS\>**

 **\<UDP-PORT\>**33111**\</UDP-PORT\>**

 **\</SOMEIP-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\<SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<SHORT-NAME\>**radar_ProvidedServiceInstance_toPort_Someip

 **\</SHORT-NAME\>**

 **\<PORT-PROTOTYPE-IREF\>**

 **\<CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF DEST=**\"ROOT-

 SW-COMPONENT-PROTOTYPE\"**\>**/apd/da/fusionExe/fusion**\</ CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF\>**

 **\<TARGET-PORT-PROTOTYPE-REF DEST=**\"P-PORT-PROTOTYPE\"**\>**/

 apd/da/fusion/radar_PPort**\</TARGET-PORT-PROTOTYPE- REF\>**

 **\</PORT-PROTOTYPE-IREF\>**

 **\<PROCESS-REF DEST=**\"PROCESS\"**\>**/apd/da/fusion_instance1**\</ PROCESS-REF\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"PROVIDED-SOMEIP-SERVICE-

 INSTANCE\"**\>**/apd/da/instance/ radar_ProvidedSomeipServiceInstance**\</SERVICE- INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<SOMEIP-PROVIDED-SERVICE-INSTANCE\>**

 **\<SHORT-NAME\>**radar_ProvidedSomeipServiceInstance**\</SHORT- NAME\>**

 **\<SERVICE-INTERFACE-DEPLOYMENT-REF DEST=**\"SOMEIP-SERVICE-

 INTERFACE-DEPLOYMENT\"**\>**/apd/da/deployment/ radar_Someip**\</SERVICE-INTERFACE-DEPLOYMENT-REF\>**

 **\<!*\-- \...\... \--*\>**

 **\<SERVICE-INSTANCE-ID\>**19**\</SERVICE-INSTANCE-ID\>**

 **\</SOMEIP-PROVIDED-SERVICE-INSTANCE\>**

 **\<!*\-- For DDS \--*\>**

 **\<DDS-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\<SHORT-NAME\>**radar_ProvidedServiceInstance_toMachine_Dds

 **\</SHORT-NAME\>**

 **\<COMMUNICATION-CONNECTOR-REF DEST=**\"ETHERNET-

 COMMUNICATION-CONNECTOR\"**\>**/apd/da/fusionMachineDesign

 /fusionCommunicationConnector**\</COMMUNICATION- CONNECTOR-REF\>**

 **\<SERVICE-INSTANCE-REFS\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"DDS-PROVIDED-SERVICE-

 INSTANCE\"**\>**/apd/da/instance/ radar_ProvidedSomeipServiceInstance**\</SERVICE- INSTANCE-REF\>**

 **\</SERVICE-INSTANCE-REFS\>**

 **\</DDS-SERVICE-INSTANCE-TO-MACHINE-MAPPING\>**

 **\<SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<SHORT-NAME\>**radar_ProvidedServiceInstance_toPort_Dds**\</**

 **\<PORT-PROTOTYPE-IREF\>**

 **\<CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF DEST=**\"ROOT-

 SW-COMPONENT-PROTOTYPE\"**\>**/apd/da/fusionExe/fusion**\</ CONTEXT-ROOT-SW-COMPONENT-PROTOTYPE-REF\>**

 **\<TARGET-PORT-PROTOTYPE-REF DEST=**\"P-PORT-PROTOTYPE\"**\>**/

 apd/da/fusion/radar_PPort**\</TARGET-PORT-PROTOTYPE- REF\>**

 **\</PORT-PROTOTYPE-IREF\>**

 **\<PROCESS-REF DEST=**\"PROCESS\"**\>**/apd/da/fusion_instance1**\</ PROCESS-REF\>**

 **\<SERVICE-INSTANCE-REF DEST=**\"PROVIDED-DDS-SERVICE-

 INSTANCE\"**\>**/apd/da/instance/ radar_ProvidedDdsServiceInstance**\</SERVICE-INSTANCE- REF\>**

 **\</SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING\>**

 **\<DDS-PROVIDED-SERVICE-INSTANCE\>**

 **\<SHORT-NAME\>**radar_ProvidedDdsServiceInstance**\</SHORT- NAME\>**

 **\<SERVICE-INTERFACE-DEPLOYMENT-REF DEST=**\"DDS-SERVICE-

 INTERFACE-DEPLOYMENT\"**\>**/apd/da/deployment/radar_Dds**\</ SERVICE-INTERFACE-DEPLOYMENT-REF\>**

 **\<!*\-- \...\... \--*\>**

 **\<SERVICE-INSTANCE-ID\>**19**\</SERVICE-INSTANCE-ID\>**

 **\</DDS-PROVIDED-SERVICE-INSTANCE\>**

**\</ELEMENTS\>**

**\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGE\>**

 **\</AR-PACKAGES\>**

 **\</AUTOSAR\>**

 **Listing 6.11: Service Instance Manifest specification of ProvidedServiceInstance**

![](./media/image55.png)

 **Figure 6.8: SOME/IP Provided Service Instance Deployment**

![](./media/image33.png)+serviceInterfaceDeployment

![](./media/image60.png)![](./media/image61.png)0..1

 +event

0..1

 ![](./media/image33.png)+field 0..1

 0..\*

```

**Figure 6.9: DDS Provided Service Instance Deployment**


Adaptive Applications looking to bind against instances of the /apd/da/radar [SI](#_bookmark71) will now have to properly configure ServiceInstanceToMachineMapping, Servi- ceInstanceToPortPrototypeMapping and ProvidedServiceInstance sub- classes in their Instance Manifests, according to their Network Binding (DDS or SOME/IP) preference.

> 适应性应用程序希望绑定到/apd/da/雷达[SI]（#_bookmark71）实例的实例，现在必须根据其网络绑定（DDS或SOME/IP）偏好，在其实例清单中正确配置ServiceInstanceToMachineMapping，Servi- ceInstanceToPortPrototypeMapping和ProvidedServiceInstance子类。

## Usage of RawDataStreaming


This chapter describes how RawDataStreams can be used in an AUTOSAR Adaptive application.

> 本章节描述了如何在AUTOSAR Adaptive应用中使用RawDataStreams。


RawDataStreaming currently supports four use cases regarding configuration of uni- cast/multicast and UDP/TCP connections. These use cases are described in chapter Raw Data Streaming of \[[1](#_bookmark0)\].

> 目前，RawDataStreaming支持四种关于配置单播/多播和UDP/TCP连接的用例。这些用例在[1]中的Raw Data Streaming章节中有描述。


The most common use case is \"'1:1 TCP unicast\"', so that is used as example in this tutorial.

> 最常见的用例是“1:1 TCP单播”，因此它被用作本教程的示例。

### Sequence diagrams


The diagram [6.10](#_bookmark184) shows the sequence when using the Raw Data Streaming API on the client side.

> 图6.10显示了客户端使用原始数据流API时的序列。

![](./media/image63.png){width="3.040363079615048in" height="3.8228116797900262in"}

**Figure 6.10:** []{#_bookmark184 .anchor}**Client sequence diagram**


The diagram [6.11](#_bookmark185) shows the sequence when using the Raw Data Streaming API on the server side.

> 图6.11显示了在服务器端使用原始数据流API时的序列。

![](./media/image64.png){width="3.030624453193351in" height="3.81875in"}

**Figure 6.11:** []{#_bookmark185 .anchor}**Client sequence diagram**

Note that the sequences with a client that sends data and a server that reads data are also valid.

### Usage


Since the Raw Data Streaming provides an API it is required to have the instances of the RawDataStreamServer or RawDataStreamClient and call the methods according to the sequences described in [6.4.1](#sequence-diagrams)

> 由于Raw Data Streaming提供了一个API，因此需要实例化RawDataStreamServer或RawDataStreamClient，并按照[6.4.1]（#序列图）中描述的顺序调用方法。

### Example of usage as server


The code [6.12](#_bookmark188) shows how to use the RawDataStreamServer for sending and receiving data.

> 代码[6.12](#_bookmark188)展示了如何使用RawDataStreamServer来发送和接收数据。

```

[]{#_bookmark188 .anchor}// NOTE! For simplicity the example does not use ara::core::Result.

#include \"ara/core/instance_specifier.h\"

#include \"raw_data_stream.h\"

int main() {

size_t rval;

ara::com::raw::RawDataStream::ReadDataResult result;

// Instance Specifier from model

ara::core::InstanceSpecifier instspec

{\...}

// Create RawDataStream Server instance

ara::com::raw::RawDataStreamServer server{instspec};

// Wait for incoming connections

server.WaitForConnection();

// Read data from the RawData stream in chunks of 10 bytes

do{

result = server.ReadData(10);

rval = result.numberOfBytes;

if (rval \> 0) {

// assumes the data is printable

std::cout \<\< \"\--\>\" \<\< result.data.get() \<\< std::endl;

}

} while (rval \> 0);

// Write data to the RawData stream in chunks of 16 bytes

int i=0;

do{

std::unique_ptr\<uint8_t\> write_buf (new uint8_t\[1024\] \\{. });

rval = server.WriteData(std::move(write_buf), 16);

++i;

}while (i\<1000);

// Shutdown RawDataStream connection

server.Shutdown(); return 0;

}

 **Listing 6.12: Example of usage as server**

### Example of usage as client

 The code [6.13](#_bookmark190) shows how to use the RawDataStreamClient for sending and receiving data.

[]{#_bookmark190 .anchor}// NOTE! For simplicity the example does not use ara::core::Result.

#include \"ara/core/instance_specifier.h\"

#include \"raw_data_stream.h\"

int main() {

size_t rval;

ara::com::raw::RawDataStream::ReadDataResult result;

// Instance Specifier from model

ara::core::InstanceSpecifier instspec

{\...}

// Create a RawDataStreamClient instance

ara::com::raw::RawDataStreamClient client {instspec};

// Connect to RawDataStream Server

client.Connect();

// Write data to RawData stream in chunks of 40 bytes

int i=0;

do {

std::unique_ptr\<uint8_t\> write_buf (new uint8_t\[1024\]{. });

rval = client.WriteData(std::move(write_buf), 40);

++i;

} while (i\<1000);

// Read data from the RawData stream in chunks of 4 bytes

do {

result = client.ReadData(4);

rval = result.numberOfBytes;

if (rval \> 0){

// assumes the data is printable

std::cout \<\< \"\--\>\" \<\< result.data.get() \<\< std::endl;

}

} while (rval \> 0);

// Shutdown RawDataStream connection

client.Shutdown(); return 0;

}

```


**Listing 6.13: Example of usage as client**

> 例 6.13: 作为客户端的使用示例


3. ## Usage of CommunicationGroups

> 3. ## 使用通訊群組

   1. ### Setup


This section describes the configuration steps to define a Communication Group by using the Communication Group Template (category = COMMUNICA- TION_GROUP). There are three items which need to be specified to define a Com- munication Group:

> 本节描述了使用通讯组模板（类别=COMMUNICA- TION_GROUP）定义通讯组的配置步骤。需要指定三个项目来定义通讯组：

- The name of the Communication Group = SHORT-NAME.
- The data type of messages sent to the clients.
- The data type of response message sent by the clients.


The figure below presents the Communication Group Template.

> 下图展示了通信组模板。

![](./media/image65.jpeg)


response message definition

> 回复消息定义

**Figure 6.12: CG Template Service Interface Descritpion, example PowerMode**

### Service Interface Description Generation


To create Communication Group server and client ServiceInterface description files, the Communication Group Template need to be setup (see chapter be- fore). Based on the Communication Group Template the ServiceInterface description files of the Communication Group server and client can be generated. See figures below.

> 为了创建通信组服务器和客户端服务接口描述文件，需要先设置通信组模板（参见前面的章节）。基于通信组模板，可以生成通信组服务器和客户端的服务接口描述文件。请参见下图。

Note: The Communication Group Template is a ServiceInterface which is only used for generation of Communication Group ServiceInterfaces and it has else no usage.

\<\<derive\>\>

**Figure 6.13: Communication Group Service Interfaces Relationship**

![](./media/image67.png){width="6.238988407699038in" height="2.410311679790026in"}

**Figure 6.14: Communication Group Service Interfaces Generation**

### Proxy and Skeleton Generation


Using the ServiceInterface descriptions for the Communication Group server and client the according Proxy and Skeleton Service classes can be genrated (hint: stan- dard ara::com [SI](#_bookmark71) generation flow). See figures below.

> 使用Communication Group服务器和客户端的ServiceInterface描述，可以生成相应的Proxy和Skeleton Service类（提示：标准ara :: com [SI]（#_bookmark71）生成流程）。请参见下图。

![](./media/image68.jpeg)

**Figure 6.15: CG Server Service Interface Description, example PowerMode**

![](./media/image69.jpeg)

**Figure 6.16: CG Client Service Interface Description, example PowerMode**

### Example


The following chapter outlines the steps to define and create the Communication Group [PowerMode](#_bookmark72).

> 以下章节概述了定义和创建[PowerMode]（＃_bookmark72）通信组的步骤。


- Define the CG name and add this name as SHORT-NAME into the ServiceIn- terface description of the Communication Group Template.

> 定义通信组模板的CG名称，并将此名称添加为SHORT-NAME到服务接口描述中。


\+ SHORT-NAME = [PowerMode](#_bookmark72)

> \+简称 = [PowerMode](#_bookmark72)


- Define the message data type for peer to peer and broadcast message according to \[SWS_CM_99001\], \[SWS_CM_99002\], \[SWS_CM_99008\] and edit it into the ServiceInterface description of the Communication Group Template.

> 根据[SWS_CM_99001]、[SWS_CM_99002]、[SWS_CM_99008]定义点对点和广播消息的消息数据类型，并将其编辑到通信组模板的服务接口描述中。

```

 \+ message definition \<typename T\>

 PowerModeMsg = \[On, Off, Suspend\] according to \[SWS_SM_91011\] background info:

 sample CG code for \[SWS_CM_99001\]:

 template \<typename T\>

 ara::core::Future\<void\> broadcast (const T& msg);

 sample CG code for \[SWS_CM_99002\]:

 template \<typename T\>

 ara::core::Future\<void\> message (uint32_t clientID, const T& msg);

 sample CG code for \[SWS_CM_99008\]:

 template \<typename T\>

 ara::core::Future\<void\> message (const T& msg);

```


- Define the response message data type according to \[SWS_CM_99014\], \[SWS\_- CM_99009\] and edit it into the ServiceInterface description of the Commu- nication Group Template.

> 根据[SWS_CM_99014]、[SWS_- CM_99009]定义响应消息数据类型，并将其编辑到通信组模板的服务接口描述中。

```

 \+ response message definition \<typename R\>

 PowerModeRspMsg = \[Done, Failed, Busy, NotSupported\] accord- ing to \[SWS_SM_91012\]

 background info:

 sample CG code for \[SWS_CM_99014\]:

 template \<typename R\> struct Response {

 uint32_t clientID;

 const R& responseMsg }

 sample CG code for \[SWS_CM_99009\]:

 template \<typename R\> const R& responseMsg;

```


- Generate the Server and Client ServiceInterface descriptions out of the setup Communication Group Template.

> 生成服务器和客户端服务接口描述，从设置的通信组模板中。
- Generate the Server and Client ServiceInterface Proxy and Skeleton Ser- vice class templates.

- Instatiate the Communication Group Server and Client Proxy and Skeleton Ser- vice classes into the application code. See examples below.

> 实例化通信组服务器和客户端代理和骨架服务类到应用代码中。参见下面的示例。

![](./media/image71.png){width="4.173254593175853in" height="3.429757217847769in"}**Figure 6.17: Usage Example Communication Group PowerMode**

Confidential C

![](./media/image72.png){width="6.222201443569554in" height="3.158124453193351in"}

**Figure 6.18: Usage Example 2 x Communication Groups diagnosticReset**

![](./media/image73.png)

**Figure 6.19: Usage Example Communication Group PowerMode and diagnosticReset**

7. # Appendix

   1. ## Serialization


Serialization (see \[[11](#_bookmark10)\]) is the process of transforming certain data structures into a standardized format for exchange between a sender and a (possibly different) receiver. You typically have this notion if you transfer data from one network node to another. When putting data on the wire and reading it back, you have to follow exact, agreed-on rules to be able to correctly interpret the data on the receiver side. For the network communication use case the need for a defined approach to convert an in-process data representation into a wire-format and back is very obvious: The boxes doing the communication might be based on different micro-controllers with different endianness and different data-word sizes (16-bit, 32-bit, 64-bit) and therefore employing totally different alignments. In the AUTOSAR CP serialization typically plays no role for platform internal/node internal communication! Here the internal in-memory data representation can be directly copied from a sender to a receiver. This is possible, because three assumptions are made in the typical CP product:

> 序列化（参见[[11]]）是将某些数据结构转换为供发送者和（可能不同的）接收者交换的标准格式的过程。如果您在一个网络节点和另一个网络节点之间传输数据，您通常会有这种概念。当将数据放在电线上并读取它时，您必须遵循精确的、约定的规则，才能正确地在接收端解释数据。对于网络通信用例，将内存中的数据表示转换为线格式并返回所需的定义方法的需求非常明显：进行通信的盒子可能基于不同的微控制器，具有不同的字节序和不同的数据字大小（16位，32位，64位），因此采用完全不同的对齐方式。在AUTOSAR CP中，序列化通常对于平台内部/节点内部通信而言没有作用！在这里，可以直接从发送者复制到接收者的内部内存数据表示。这是可能的，因为在典型的CP产品中做出了三个假设：

- Endianness is identical among all local SWCs.
- Alignment of certain data structures is homogeneous among all local SWCs.
- Data structures exchanged are contiguous in memory.


The first point is maybe a bit pathological as it is most common, that "internal" com- munication generally means communication on a single- or multi-core MCU or even a multi-processor system, where endianness is identical everywhere. Only if we look at a system/node composed of CPUs made of different micro-controller families this assumption may be invalid, but then you are already in the discussion, whether this communication is still "internal" in the typical sense. The second assumption is valid/ac- ceptable for CP as here a static image for the entire single address space system is built from sources and/or object files, which demands that compiler settings among the different parts of the image are somewhat aligned anyway. The third one is also as- sured in CP. It is not allowed/possible to model non contiguous data types, which get used in inter-SWC communication.

> 第一点可能有点病态，因为最常见的情况是，“内部”通信通常指在单核或多核MCU甚至多处理器系统上的通信，其中字节序在所有地方都是相同的。只有当我们看到由不同微控制器家族组成的系统/节点时，才可能使这个假设无效，但是你已经在讨论中，这种通信在典型意义上是否仍然是“内部”的。第二个假设对CP是有效/可接受的，因为这里从源代码和/或对象文件中为整个单地址空间系统构建静态图像，这要求图像的不同部分之间的编译器设置在某种程度上是一致的。第三个也是CP的。不允许/不可能模拟用于SWC间通信的非连续数据类型。


For the AP things look indeed different. Here the loading of executables during run- time, which have been built independently at different times and have been uploaded to an AP ECU at different times, is definitely a supported use case. The chance, that compiler settings for different [ara::com](#_bookmark15) applications were different regarding align- ment decisions is consequently high. Therefore an AP product (more concrete its [IPC](#_bookmark70)binding implementation) has to use/support serialization of exchanged event/field-

> 就AP而言，情况确实有所不同。在运行时加载独立构建的可执行文件，并在不同时间上传到AP ECU，这绝对是一个支持的用例。因此，不同[ara :: com]（#_bookmark15）应用程序的编译器设置在对齐决策方面可能不同。因此，AP产品（更具体地说，其[IPC]（#_bookmark70）绑定实现）必须使用/支持交换的事件/字段的序列化。


/method data. How serialization for AP internal[IPC](#_bookmark70)is done (i.e. to what generalized format) is fully up to the AP vendor. Also regarding the 3rd point, the AP is less re- strictive. So for example the AP supports exchange of std::map data types or record like datatypes, which contain variable-length members. These datatypes are generally NOT contiguous in-memory (depending on the allocation strategy). So even if the data

> 数据的/方法。AP内部[IPC]（＃_bookmark70）的序列化完全取决于AP供应商。此外，关于第三点，AP不那么受限制。因此，例如，AP支持交换std :: map数据类型或包含可变长度成员的记录类型。这些数据类型通常不是内存中连续的（取决于分配策略）。因此，即使数据


copy (meaning collecting contained elements and their references from various mem- ory regions --- see \[[12](#_bookmark11)\]) must be done during transfer. Of course the product vendor could apply optimization strategies to get rid of the serialization and de-serialization stages within a communication path:

> 在传输过程中必须进行复制（意思是从各种内存区域收集元素及其引用，参见[12]）。当然，产品供应商可以采用优化策略来消除通信路径中的序列化和反序列化阶段。


- Regarding alignment issues, the most simple one could be to allow the integrator of the system to configure, that alignment for certain communication relations can be considered compatible (because he has the needed knowledge about the involved components).

> 关于对齐问题，最简单的方法可以是允许系统集成人员配置，可以认为某些通信关系的对齐是兼容的（因为他有涉及到的组件的必要知识）。

- Another approach common to middleware technology is to verify, whether align- ment settings on both sides are equal by exchanging a check-pattern as kind of a init-sequence before first [ara::com](#_bookmark15) communication call.

> 另一种常见的中间件技术方法是在首次[ara::com](#_bookmark15)通信调用之前，通过交换检查模式作为初始序列来验证双方的对齐设置是否相等。

- The problem regarding need for deep-copying because of non-contiguous mem- ory allocation could be circumvented by providing vector implementations which care for continuity.

> 问题涉及由于非连续内存分配而需要深度复制可以通过提供关注连续性的向量实现来规避。


  1. ### Zero-Copy implications

> ### 零复制意义


One thing which typically is at the top of the list of performance optimizations in IPC/middleware implementations is the avoidance of unnecessary copies between sender and the receiver of data. So the buzzword "zero-copy" is widely used to de- scribe this pattern. When we talk about AP, where we have architectural expectations like applications running in separate processes providing memory protection, the typi- cal communication approach needs at least ONE copy of the data from source address space to target address space. Highly optimizing middleware/IPC implementations could even get rid of this single copy step by setting up shared memory regions be- tween communicating [ara::com](#_bookmark15) components. If you look at [5.19](#_bookmark138), you see, that we directly encourage such implementation approaches in the API design. But the not so good news is, that if the product vendor does NOT solve the serialization problem, he barely gets benefit from the shared memory approach: If conversions (aka de/se- rialization) have to be done between communication partners, copying must be done anyhow --- so tricky shared memory approaches to aim for "zero-copy" do not pay.

> 一般来说，IPC/中间件实现中性能优化的第一位通常是避免数据发送者和接收者之间的不必要的拷贝。因此，常见的“零拷贝”一词用于描述这种模式。当我们谈论AP时，我们有像应用程序运行在单独进程中提供内存保护的架构期望，典型的通信方法至少需要从源地址空间到目标地址空间的数据的一个副本。高度优化的中间件/IPC实现可以通过在通信[ara::com](#_bookmark15)组件之间设置共享内存区域，甚至可以消除这个单一拷贝步骤。如果您查看[5.19](#_bookmark138)，您会发现，我们在API设计中直接鼓励这种实施方法。但不好的消息是，如果产品供应商没有解决序列化问题，他几乎不会从共享内存方法中受益：如果在通信合作伙伴之间需要进行转换（也称为序列化/反序列化），则无论如何都必须进行复制-因此，旨在实现“零拷贝”的棘手共享内存方法不会有任何收益。

## Service Discovery Implementation Strategies


As laid out in the preceding chapters, [ara::com](#_bookmark15) expects the functionality of a ser- vice discovery being implemented by the product vendor. As the service discovery functionality is basically defined at the API level with the methods for FindService, OfferService and StopOfferService, the protocol and implementation details are partially open.

> 根据前面几章所述，[ara::com](#_bookmark15)期望产品供应商实施服务发现功能。由于服务发现功能基本上是在API级别定义的，具有FindService、OfferService和StopOfferService方法，因此协议和实现细节部分是开放的。


When an AP node (more concretely an AP SWC) offers a service over the network or requires a service from another network node, then service discovery/service registry

> 当一个AP节点（更具体地说是AP SWC）在网络上提供服务或者从另一个网络节点需要服务时，就需要服务发现/服务注册。


obviously takes place over the wire. The protocol for service discovery over the wire needs to be completely specified by the used communication protocol. For SOME/IP, this is done in the SOME/IP Service Discovery Protocol Specification \[[13](#_bookmark12)\]. But if an [ara::com](#_bookmark15) application wants to communicate with another [ara::com](#_bookmark15) application on the same node within the AP of the same vendor there has to be a local variant of a ser- vice discovery available. Here the only difference is, that the protocol implementation for service discovery taking place locally is totally up to the AP product vendor.

> 显然是通过线路进行的。服务发现的协议必须完全由所使用的通信协议来指定。对于SOME/IP，这在SOME/IP服务发现协议规范中完成\[[13]（#_bookmark12）\]。但是，如果[ara :: com]（#_bookmark15）应用程序想要与同一节点上的另一个[ara :: com]（#_bookmark15）应用程序在同一供应商的AP上进行通信，则必须有一个本地的服务发现变体。这里唯一的不同之处在于，本地发现协议的实现完全取决于AP产品供应商。

### Central vs Distributed approach


From an abstract perspective a AP product vendor could choose between two ap- proaches: The first one is a centralist approach, where the vendor decides to have one central entity (f.i. a daemon process), which:

> 从抽象的角度来看，AP产品供应商可以选择两种方法：第一种是集中式方法，供应商决定拥有一个中央实体（例如，一个守护进程），其中：

- maintains a registry of all service instances together with their location informa- tion

- serves all FindService, OfferService and StopOfferService re- quests from local [ara::com](#_bookmark15) applications, thereby either updating the registry (OfferService, StopOfferService) or querying the registry ( FindSer- vice)

> 它为本地[ara::com](#_bookmark15)应用程序提供所有FindService、OfferService和StopOfferService请求，从而更新注册表（OfferService、StopOfferService）或查询注册表（FindService）。

- serves all SOME/IP SD messages from the network either updating its registry (SOME/IP Offer Service received) or querying the registry (SOME/IP Find Service received)

> 它可以从网络接收所有SOME/IP SD消息，无论是更新其注册表（收到SOME/IP Offer Service）还是查询注册表（收到SOME/IP Find Service）。
- propagates local updates to its registry to the network by sending out SOME/IP SD messages.


The following figure roughly sketches this approach.

> 下图大致勾勒了这种方法。

![](./media/image74.png)ECU with AP/CP product

**Figure 7.1: Centralized discovery approach**


A slightly different --- more distributed --- approach would be, to distribute the service registry information (availability and location information) among the [ara::com](#_bookmark15) appli- cations within the node. So for the node local communication use case no prominent discovery demon would be needed. That could be technically reached by having a broadcast-like communication. That means any service offering and finding is prop- agated to all local [ara::com](#_bookmark15) applications, so that each application has a local (in process) view of the service registry. There might be a benefit with this approach as local communication might be more flexible/stable as it is not dependent from a single registry demon. However, for the service discovery communication to/from the network a single responsible instance is needed anyhow. Here the distributed approach is not feasible as SOME/IP SD requires a fixed/defined set of ports, which just can be pro- vided (in typical operating systems / with typical network stacks) by a single application process.

> 一种略有不同的——更分布式的——方法是，将服务注册信息（可用性和位置信息）分布在节点中的[ara :: com]（#_bookmark15）应用程序中。因此，对于节点本地通信用例，不需要显着的发现恶魔。这可以通过具有广播般的通信来技术上实现。这意味着任何服务提供和发现都传播到所有本地[ara :: com]（#_bookmark15）应用程序，因此每个应用程序都具有服务注册表的本地（进程中）视图。这种方法可能具有好处，因为本地通信可能更灵活/稳定，因为它不依赖于单一的注册恶魔。但是，对于与网络的服务发现通信，仍然需要单一的负责实例。在这里，分布式方法不可行，因为SOME / IP SD需要固定/定义的端口集，这只能由单个应用程序进程提供。


At the end we also do have a singleton/central instance, with the slight difference, that it is responsible for taking the role as a service discovery protocol bridge between node local discovery protocol and network SOME/IP SD protocol. On top of that --- since registry is duplicated/distributed among all [ara::com](#_bookmark15) applications within the node --- this bridge also holds a local registry.

> 最后，我们也有一个单例/中央实例，略有不同之处在于，它负责在节点本地发现协议和网络SOME / IP SD协议之间扮演服务发现协议桥梁的角色。此外，由于注册表在节点中的所有[ara :: com]（＃_bookmark15）应用程序之间被复制/分布，因此该桥梁还拥有本地注册表。

![](./media/image74.png)ECU with AP/CP product

**Figure 7.2: Distributed discovery approach**

## Multi-Binding implications


As shortly discussed in [subsection](#instantiation-constructors) [5.4.3](#instantiation-constructors) Multi-Binding describes the solution to support setups, where the technical transport/connection between different instances of a certain proxy class/skeleton class are different. There might be various technical reasons for that:

> 在[小节](#instantiation-constructors) [5.4.3](#instantiation-constructors)中所讨论的多绑定描述了支持特定代理类/骨架类的不同实例之间的技术传输/连接的解决方案。可能有各种技术原因：


- proxy class uses different transport/IPC to communicate with different skeleton instances. Reason: Different service instances support different transport mech- anisms because of deployment decisions.

> 代理类使用不同的传输/IPC与不同的骨架实例进行通信。原因：由于部署决策，不同的服务实例支持不同的传输机制。

- symmetrically it may also be the case, that different proxy instances for the same skeleton instance uses different transport/IPC to communicate with this instance: The skeleton instance supports multiple transport mechanisms to get contacted.

> 可以对称地认为，对于同一个骨架实例，不同的代理实例使用不同的传输/IPC来与此实例通信：骨架实例支持多种传输机制来被联系。


  1. ### Simple Multi-Binding use case

> ### 简单的多绑定使用案例


The following figure depicts an obvious and/or rather simple case. In this example, which only deals with node local (inside one AP product/ECU) communication between service consumers (proxy) and service providers (skeleton), there are two instances of the same proxy class on the service consumer side. You see in the picture, that the service consumer application has triggered a "FindService" first, which returned two handles for two different service instances of the searched service type. The service consumer application has instantiated a proxy instance for each of those handles. Now in this example the instance 1 of the service is located inside the same adaptive ap- plication (same process/address space) as the service consumer (proxy instance 1), while the service instance 2 is located in a different adaptive application (different pro- cess/address space).

> 以下图示描绘了一个明显而且相当简单的情况。在这个只涉及节点本地（在一个AP产品/ECU内）服务消费者（代理）和服务提供者（骨架）之间通信的例子中，服务消费者端有两个相同的代理类实例。您可以在图片中看到，服务消费者应用程序首先触发了“FindService”，它返回了两个不同服务类型的服务实例的句柄。服务消费者应用程序为每个句柄实例化了一个代理实例。现在，在这个例子中，服务实例1位于与服务消费者（代理实例1）相同的自适应应用程序（同一进程/地址空间）中，而服务实例2位于不同的自适应应用程序（不同进程/地址空间）中。

ECU with AP product

![](./media/image80.png)

**Figure 7.3: Simple Multi-Binding intra AP example**


The line symbolizing the transport layer between proxies and skeletons are colored differently in this picture: The instance of the proxy class for instance 1 has a red colored transport layer (binding implementation), while the transport layer for instance 2 is colored blue. They are colored differently because the used technology will be different already on the level of the proxy implementation. At least if you expect that the AP product vendor (in the role as[IPC](#_bookmark70)binding implementer) strives for a well performing product!

> 这张图片中，代理和骨架之间的传输层用不同的颜色来符号化：实例1的代理类的实例具有红色的传输层（绑定实现），而实例2的传输层则为蓝色。它们之间的颜色不同，是因为代理实现的使用技术已经在代理实现的层面上就不同了。如果你期望AP产品供应商（以IPC绑定实施者的角色）努力实现一个性能良好的产品，那么至少这是必须的！


The communication between proxy instance 1 and the service instance 1 (red) should in this case be optimized to a plain method call, since proxy instance and skeleton instance 1 are contained in ONE process.

> 在这种情况下，代理实例1和服务实例1（红色）之间的通信应优化为简单的方法调用，因为代理实例和骨架实例1都包含在一个进程中。


The communication between proxy instance 2 and the service instance 2 (blue) is a real IPC. So the actions taken here are of much higher costs involving most likely a variety of syscalls/kernel context switches to transfer calls/data from process of ser- vice consumer application to service application (typically using basic technologies like pipes, sockets or shared mem with some signaling on top for control).

> 在代理实例2和服务实例2（蓝色）之间的通信是一种真正的IPC。因此，在这里采取的行动的成本要高得多，涉及到大量系统调用/内核上下文切换，以将来自服务消费应用程序的调用/数据传输到服务应用程序（通常使用基本技术，如管道、套接字或共享内存，以及用于控制的信号）。


So from the service consumer side application developer it is totally transparent: From the vendors ProxyClass::FindService implementation he gets two opaque han- dles for the two service instances, from which he creates two instances of the same

> 从服务消费者端应用程序开发者的角度来看，完全透明：从供应商ProxyClass::FindService实现中，他获得两个不透明的句柄，用于两个服务实例，从中他创建了两个相同的实例。


proxy class. But "by magic" both proxies behave totally different in the way, they con- tact their respective service instances. So --- somehow there must be some information contained inside this handle, from which the proxy class instance knows which tech- nical transport to choose. Although this use case looks simple at the first look it isn't on the second \... The question is: *Who* writes *When* into the handle, that the proxy in- stance created from it shall use a direct method/function call instead of a more complex [IPC](#_bookmark70)mechanism or vice versa?

> 代理类。但是，“凭借魔法”，这两个代理在接触它们各自的服务实例的方式上表现出完全不同的行为。因此---某种程度上，这个句柄中必须包含一些信息，让代理类实例知道选择哪种技术传输。虽然这个用例在第一眼看起来很简单，但在第二眼看来却不是这样......问题是：*谁*在*什么时候*写入句柄，以便从中创建的代理实例使用直接的方法/函数调用而不是更复杂的[IPC]（＃_bookmark70）机制或者相反？


At the point in time when instance 1 of the service does register itself via Skele- tonClass::OfferService at the registry/service discovery, this cannot be decided! Since it depends on the service consumer which uses it later on. So most likely the SkeletonClass::OfferService implementation of the AP vendor takes the needed information from the argument (skeleton generated by the AP vendor) and no- tifies via AP vendor specific[IPC](#_bookmark70)the registry/service discovery implementation of the AP vendor. The many "AP vendor" in the preceding sentence were intentional. Just show- ing, that all those mechanisms going on here are not standardized and can therefore deliberately designed and optimized by the AP vendors. However, the basic steps will remain. So what typically will be communicated from the service instance side to the registry/discovery in the course of SkeletonClass::OfferService is the technical addressing information, how the instance could be reached via the AP products local [IPC](#_bookmark70)implementation.

> 在服务实例1通过SkeletonClass :: OfferService注册到注册表/服务发现时，无法决定！因为这取决于后来使用它的服务消费者。因此，AP供应商的SkeletonClass :: OfferService实现可能从参数（AP供应商生成的骨架）中获取所需的信息，并通过AP供应商特定的[IPC]（＃_bookmark70）通知注册表/服务发现实现。前面句子中的“AP供应商”是有意的。只是表明，这里发生的所有机制都没有标准化，因此可以被故意设计和优化。但是，基本步骤将保持不变。因此，在SkeletonClass :: OfferService过程中，服务实例端通常会传递技术地址信息，即通过AP产品的本地[IPC]（＃_bookmark70）实现如何访问实例。


Normally there will be only ONE IPC-mechanism used inside one AP product/AP node! If the product vendor already has implemented a highly optimized/efficient local [IPC](#_bookmark70)implementation between adaptive applications, which will then be generally used. So --- in our example let"s say the underlying IPC-mechanism is unix domain sockets

> 一般情况下，在一个AP产品/AP节点中只会使用一种IPC机制！如果产品供应商已经实现了一种高度优化/高效的本地[IPC](#_bookmark70)实现，它将被普遍使用。因此 - 在我们的例子中，假设底层的IPC机制是Unix域套接字。

--- the skeleton instance 1 would get/create some file descriptor to which its socket endpoint is connected and would communicate this descriptor to the registry/service discovery during SkeletonClass::OfferService. Same goes for the skeleton in- stance 2, just the descriptor is different. When later on the service consumer applica- tion part does a ProxyClass::FindService, the registry will send the addressing information for both service instances to the service consumer, where they are visible as two opaque handles.


So in this example obviously the handles look exactly the same --- with the small dif- ference, that the contained filedescriptor values would be different as they reference distinctive unix domain sockets. So in this case it somehow has to be detected inside the proxy for instance 1, that there is the possibility to optimize for direct method/func- tion calls. One possible trivial trick could be, that inside the addressing information, which skeleton instance 1 gives to the registry/discovery, also the ID of the process (pid) is contained; either explicitly or by including it into the socket descriptor filename. So the service consumer side proxy instance 1 could simply check, whether the PID inside the handle denotes the same process as itself and could then use the optimized path. By the way: Detection of process local optimization potential is a triviality, which almost every existing middleware implementation does today --- so no further need to stress this topic.

> 在这个例子中，句柄看起来完全一样，只有包含的文件描述符值不同，因为它们引用不同的Unix域套接字。因此，在这种情况下，代理实例1中必须检测出有可能优化直接方法/函数调用的可能性。一种可能的简单技巧是，骨架实例1给注册/发现的地址信息中，也包含进程的ID（PID），或者显式地包含它，或者将其包含在套接字描述符文件名中。因此，服务消费者端代理实例1可以简单地检查句柄中的PID是否指定为与自身相同的进程，然后可以使用优化的路径。顺便说一句：检测进程本地优化潜力几乎是每个现有中间件实现今天都要做的琐事，因此不需要进一步强调这个主题。


Now, if we step back, we have to realize, that our simple example here does NOT fully reflect what Multi-Binding means. It does indeed describe the case, where two instances of the same proxy class use different transport layers to contact the service instance, but as the example shows, this is NOT reflected in the handles denoting the different instances, but is simply an optimization! In our concrete example, the service consumer using the proxy instance 1 to communicate with the service instance 1 could have used also the Unix domain socket transport like the proxy instance 2 without any functional losings --- only from a non-functional performance viewpoint it would be obviously bad. Nonetheless this simple scenario was worth being mentioned here as it is a real-world scenario, which is very likely to happen in many deployments and therefore must be well supported!

> 现在，如果我们退后一步，我们必须意识到，我们这里的简单示例并不能完全反映多绑定的意义。它确实描述了同一代理类的两个实例使用不同的传输层来联系服务实例的情况，但是正如示例所示，这并不反映在表示不同实例的句柄上，而只是一种优化！在我们的具体示例中，使用代理实例1与服务实例1通信的服务消费者也可以使用像代理实例2一样的Unix域套接字传输，而不会有任何功能损失-仅从非功能性性能角度来看，这显然是不好的。尽管如此，这个简单的场景值得在这里提及，因为它是很可能发生在许多部署中的真实场景，因此必须得到很好的支持！

### Local/Network Multi-Binding use case


After we have seen a special variant of Multi-Binding in the preceding section, we now look at a variant, which can also be considered as being a real-world case. Let"s suppose, we have have a setup quite similar to the one of the preceding chapter. The only difference is now, that the instance 2 of the service is located on a different ECU attached to the same Ethernet network as our ECU with the AP product, where the service consumer (with its proxies for instance 1 and 2) resides. As the standard protocol on Ethernet for AP is SOME/IP, it is expected, that the communication between both ECUs is based on SOME/IP. For our concrete example this means, that proxy 1 talks to service 1 via unix domain sockets (which might be optimized for process local communication to direct method calls, if the AP vendor/IPC implementer did his homework), while the proxy 2 talks to service 2 via network sockets in a SOME/IP compliant message format.

> 在前一节中看到了多重绑定的一个特殊变体后，我们现在来看一个变体，可以被认为是一个真实世界的案例。假设我们有一个与前一章相当相似的设置。唯一的不同之处在于，服务的第二个实例位于与具有AP产品的ECU相同的以太网网络上的另一个ECU上，其中服务消费者（具有实例1和2的代理）所在。由于AP的标准协议是SOME / IP，因此预计两个ECU之间的通信是基于SOME / IP的。对于我们的具体示例，这意味着代理1通过Unix域套接字（如果AP供应商/ IPC实施者做了他的家庭作业，这可能被优化为进程本地通信以直接方法调用）与服务1进行通信，而代理2则通过网络套接字以SOME / IP兼容的消息格式与服务2进行通信。


*Before someone notes, that this is not true for the typical SOME/IP deployment, be- cause there adaptive SWCs will not directly open network socket connections to remote nodes: We will cover this in more detail here (* [subsection](#typical-someip-multi-binding-use-case) [7.3.3](#typical-someip-multi-binding-use-case)*), but for now suppose, that this is a realistic scenario. (For other network protocols it might indeed be realistic)*

> 在有人注意到这对典型的SOME/IP部署不正确之前，因为自适应SWC不会直接打开与远程节点的网络套接字连接：我们将在这里（[子节](#typical-someip-multi-binding-use-case) [7.3.3](#typical-someip-multi-binding-use-case)*）中更详细地介绍，但现在假设这是一个现实的情景（对于其他网络协议可能确实是现实的）。

![](./media/image82.png)ECU with AP product

**Figure 7.4: Multi-Binding local and network example**


So in this scenario the registry/service discovery demon on our AP ECU has seen a service offer of instance 2 and this offer contained the addressing information on IP network endpoint basis. Regarding the service offer of the instance 1 nothing changed: This offer is still connected with some Unix domain socket name, which is essentially a filename. In this example the two handles for instance 1 and 2 returned from ProxyClass::FindService internally look very different: Handle of instance 1 contains the information, that it is a Unix domain socket and a name, while han- dle 2 contains the information, that it is a network socket and an IP address and port number. So --- in contrast to our first example ([subsection](#simple-multi-binding-use-case) [7.3.1](#simple-multi-binding-use-case)) here we do really have a full blown Multi-Binding, where our proxy class [ctor](#_bookmark23) instantiates/creates two completely different transport mechanisms from handle 1 and handle 2! How this dynamic decision, which transport mechanism to use, made during call of the [ctor](#_bookmark23), is technically solved is --- again --- up to the middleware implementer: The generated proxy class implementation could already contain any supported mechanism and the information contained in the handle is just used to switch between different behavior or the needed transport functionality aka binding could be loaded during runtime after a certain need is detected from the given handle via shared library mechanisms.

> 在这种情况下，我们AP ECU上的注册/服务发现恶魔已经看到了实例2的服务报价，该报价包含了基于IP网络端点的地址信息。关于实例1的服务报价没有任何改变：这个报价仍然与某个Unix域套接字名称相关联，这实际上是一个文件名。在这个例子中，从ProxyClass::FindService内部返回的实例1和2的两个句柄看起来非常不同：句柄1包含的信息是它是一个Unix域套接字和一个名称，而句柄2包含的信息是它是一个网络套接字和一个IP地址和端口号。因此，与我们的第一个示例（[7.3.1]（#simple-multi-binding-use-case））相比，这里我们确实有一个完整的多绑定，我们的代理类[ctor]（#_bookmark23）实例化/创建了两个完全不同的传输机制，从句柄1和句柄2！在调用[ctor]（#_bookmark23）时如何动态决定使用哪种传输机制，技术上的解决方案是：生成的代理类实现可能已经包含任何支持的机制，句柄中包含的信息只是用于在不同的行为之间切换，或者在检测到给定句柄的某种需要后，通过共享库机制加载所需的传输功能，即绑定。

### Typical SOME/IP Multi-Binding use case


In the previous section we briefly mentioned, that in a typical deployment scenario with SOME/IP as network protocol, it is highly unlikely that an adaptive SWC (i.e. the language and network binding which runs in its context) opens socket connections itself to communicate with a remote service. Why is it unlikely? Because SOME/IP was explicitly designed to use as few ports as possible. The reason for that requirement

> 在前一节中，我们简要提到，在典型的部署场景中，使用SOME/IP作为网络协议，自适应SWC（即运行其上下文的语言和网络绑定）本身开放套接字连接以与远程服务通信是极不可能的。为什么不可能？因为SOME/IP被明确设计为尽可能使用少量的端口。这个要求的原因是什么？


comes from low power/low resources embedded ECUs: Managing a huge amount of IP sockets in parallel means huge costs in terms of memory (and runtime) resources. So somehow our AUTOSAR CP siblings which will be main communication partner in an inside vehicle network demand this approach, which is uncommon, compared to non-automotive IT usage pattern for ports.

> 来自低功耗/低资源嵌入式ECU：并行管理大量的IP套接字意味着在内存（和运行时）资源方面的巨大成本。因此，我们的AUTOSAR CP兄弟将成为车辆内部网络中的主要通信伙伴，这种方法与非汽车IT使用模式的端口相比是不同寻常的。


Typically this requirement leads to an architecture, where the entire SOME/IP traffic of an ECU / network endpoint is routed through one IP port! That means SOME/IP messages originating from/dispatched to many different local applications (service providers or service consumers) are (de)multiplexed to/from one socket connection. In Classic AUTOSAR (CP) this is a straight forward concept, since there is already a shared communication stack through which the entire communication flows. The multiplexing of different upper layer PDUs through one socket is core functionality inte- grated in CPs SoAd basic software module. For a typical POSIX compatible OS with POSIX socket API, multiplexing SOME/IP communication of many applications to/from one port means the introduction of a separate/central (demon) process, which man- ages the corresponding port. The task of this process is to bridge between SOME/IP network communication and local communication and vice versa.

> 通常，此要求导致一种架构，即ECU /网络端点的整个SOME / IP流量通过一个IP端口路由！这意味着来自/发送到许多不同本地应用程序（服务提供者或服务消费者）的SOME / IP消息被（去）多路复用到/从一个套接字连接。在Classic AUTOSAR（CP）中，这是一个直接的概念，因为已经有一个共享的通信堆栈，通过该堆栈流动整个通信。将不同的上层PDU多路复用到一个端口是CP的SoAd基本软件模块集成的核心功能。对于具有POSIX套接字API的典型POSIX兼容操作系统，将许多应用程序的SOME / IP通信多路复用到/从一个端口意味着引入一个单独/中央（恶魔）进程，该进程管理相应的端口。此过程的任务是在SOME / IP网络通信和本地通信之间桥接，反之亦然。

![](./media/image85.png)ECU with AP product

**Figure 7.5: SOME/IP Bridge**


In the above figure you see, that the service proxy within our [ara::com](#_bookmark15) enabled appli- cation communicates through (green line) a SOME/IP Bridge with the remote service instance 2. Two points which may pop out in this figure:

> 在上图中，您可以看到，我们启用ara :: com的服务代理在（绿线）SOME / IP桥接器上与远程服务实例2进行通信。此图中可能引起注意的两点是：


- we intentionally colored the part of the communication route from app to bridge (green) differently than the part from the bridge to the service instance 2 (blue).

> 我们有意将应用程序到桥梁（绿色）的通信路由与桥梁到服务实例2（蓝色）的部分颜色不同。
- we intentionally drew a box around the function block service discovery and SOME/IP bridge.

