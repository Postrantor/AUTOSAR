---
tip: translate by openai@2023-06-24 10:16:13
...


**[SWS_CM_10458] Handling of an ServiceInterface that does not contain any events, methods, or fields** *[*If a SomeipServiceInterfaceDeployment is defined for a ServiceInterface that does not contain any events, methods, or fields and a ProvidedSomeipServiceInstance is defined in the ServiceInstanceManifest that points to the SomeipServiceInterfaceDeployment in the role serviceInterface then:

> 如果为没有任何事件、方法或字段的ServiceInterface定义了SomeipServiceInterfaceDeployment，并且在ServiceInstanceManifest中定义了ProvidedSomeipServiceInstance，指向以serviceInterface角色的SomeipServiceInterfaceDeployment，那么：


- the ServiceInterface shall be offered over SOME/IP as defined by [[SWS_CM_00203](#_bookmark45)] which means that the Endpoint Option shall include the IP-Address, Port Number and Protocol as defined by the ProvidedSomeipServiceInstance

> 服务接口将按照[[SWS_CM_00203](#_bookmark45)]定义的SOME/IP提供，这意味着端点选项将包括按照提供的SomeipServiceInstance定义的IP地址、端口号和协议。

- the Server shall not create a UDP/TCP socket and shall not bind any socket to the configured server address

> 服务器不应创建UDP/TCP套接字，也不应将任何套接字绑定到配置的服务器地址。

*♩(RS_CM_00101)*

### Signal-Based Network binding


The applications on the adaptive platform communicate with each other in a serviceoriented manner. When exchanging information with software components executed on an AUTOSAR classic platform which make use of signal-based communication, a conversion between this signal-based communication and the service-oriented communication needs to take place. Hereby the signals of a received signal-based communication is being made available as elements of a provided ServiceInterface. The signals of a sent signal-based communication are being made available as elements of a required ServiceInterface. The conversion between signal-based communication and service-oriented communication may be performed by a software component on an AUTOSAR classic platform gateway ECU or by an adaptive application on an AUTOSAR adaptive platform Machine.

> 应用程序在自适应平台上以服务导向的方式进行通信。当与在AUTOSAR经典平台上执行的使用信号通信的软件组件交换信息时，需要进行信号通信和服务导向通信之间的转换。因此，接收到的信号通信的信号将作为提供的服务接口的元素提供。发送的信号通信的信号将作为所需的服务接口的元素提供。信号通信和服务导向通信之间的转换可以由AUTOSAR经典平台网关ECU上的软件组件或AUTOSAR自适应平台机器上的自适应应用程序执行。


There are two approaches how the signal-based information is made available at the adaptive AUTOSAR Machine:

> 在Adaptive AUTOSAR机器上提供基于信号的信息有两种方法：

- Network binding (see section [7.5.2.1](#signal-based-someip-network-binding))
- Network binding (see section [7.5.2.2](#signal-based-static-network-binding))

  1. ### Signal-Based SOME/IP Network binding


The [Signal-Based SOME/IP](#_bookmark159) network binding is currently a specialization of the SOME/IP network binding and many aspects of the SOME/IP network binding are re-used. Instead of replicating many specification items from the SOME/IP network binding the approach of this [Signal-Based SOME/IP](#_bookmark159) network binding chapter is to replicate the chapter structure. Specification items which are applicable to the [Sig-](#_bookmark159) [nal-Based SOME/IP](#_bookmark159) network binding are just referenced, specification items which are NOT applicable to the [Signal-Based SOME/IP](#_bookmark159) network binding are explicitly ex-

> 信号基于SOME/IP的网络绑定目前是SOME/IP网络绑定的一种专业化，许多SOME/IP网络绑定的方面都被重用。本章节的信号基于SOME/IP的网络绑定方法不是复制SOME/IP网络绑定的许多规范项，而是复制章节结构。适用于信号基于SOME/IP的网络绑定的规范项只需要引用，不适用于信号基于SOME/IP的网络绑定的规范项则需要明确排除。


cluded (via reference), and changed specification items are marked and the origin is referenced.

> 包括（通过参考），改变的规格项目被标记，并且参考了原始的内容。


One major difference between the SOME/IP network binding and the [Signal-Based](#_bookmark159) [SOME/IP](#_bookmark159) network binding is the serialization technology. While the SOME/IP network binding only supports SOME/IP serialized payload the [Signal-Based SOME/IP](#_bookmark159) network binding supports the signal-based serialization of Classic platform COM-Stack as well as the SOME/IP serialization of payload (in order to support mixed use-cases).

> 一个主要的不同之处在于SOME/IP网络绑定和基于信号的SOME/IP网络绑定之间的序列化技术。而SOME/IP网络绑定只支持SOME/IP序列化的有效负载，基于信号的SOME/IP网络绑定支持经典平台COM-Stack的基于信号的序列化以及SOME/IP序列化的有效负载（以支持混合用例）。


**[SWS_CM_11269]**{DRAFT} **Definition of serialization technology** *[*The serialization technology is defined by the attribute SomeipEventDeployment.serializer. If the attribute is set to signalBased then the signal-service-translation is responsible for the handling of the serialization. If the attribute is set to someip then the SOME/IP serializer is responsible for the handling of the serialization.*♩(RS_CM_00204)*

> **[SWS_CM_11269]**{草稿} **序列化技术的定义** *[*序列化技术由SomeipEventDeployment.serializer属性定义。如果该属性设置为signalBased，则信号服务转换负责处理序列化。如果该属性设置为someip，则SOME/IP序列化器负责处理序列化。*♩(RS_CM_00204)*


See also chapter [7.5.2.1.8](#serialization-of-payload-1) and chapter [7.5.1.9](#serialization-of-payload).

> 另请参阅第7.5.2.1.8节（#序列化有效负载1）和第7.5.1.9节（#序列化有效负载）。


In figure [7.18](#_bookmark162) an example of a mixed serialized service is illustrated. The event *x* is defined to use someip serializer while event *y* is defined to use signalBased serializer. Both are part of one service and share the service discovery and general event handling.

> 在图7.18中展示了一个混合序列化服务的例子。事件*x*被定义为使用someip序列化器，而事件*y*被定义为使用基于信号的序列化器。它们都是同一个服务的一部分，共享服务发现和一般事件处理。


![](./media/image33.png)**Figure 7.18:** **Example serialization settings**


The modeling of the signal-based communication and the mapping between the individual elements of a ServiceInterface to the corresponding ISignalTriggerings is defined in the chapter "Signal-based communication" in [6].

> 信号基础通信的建模和服务接口的各个元素与相应的ISignalTriggerings之间的映射在[6]中的“基于信号的通信”一章中定义。


**[SWS_CM_10174]**{DRAFT} **Mix of signal-based and SOME/IP communication** *[*A combination of signal-based network binding and SOME/IP network binding shall be possible in a way to support the reception of a mix of signal-based communication and SOME/IP communication within a single UDP datagram or a single TCP stream on one UDP/TCP socket. Such a mix can occur when using [17] with enabled PDU-header option on the sender side.*♩(RS_CM_00204)*

> **[SWS_CM_10174]**{草案} **信号基础和SOME/IP通信的混合** *[*信号基础网络绑定和SOME/IP网络绑定的组合应该能够以支持在单个UDP数据报或单个TCP流上的一个UDP/TCP套接字上接收混合的信号基础通信和SOME/IP通信的方式。当使用[17]并在发送端启用PDU头选项时，可能会出现这种混合情况。*♩(RS_CM_00204)*


This allows to define the transport of messages from several services on the same socket, regardless of the serialization setting. Thus messages using the pure SOME/IP network binding can be transported together with messages using the signal-based network binding on the same socket.

> 这允许在同一个套接字上定义来自多个服务的消息传输，而不管序列化设置如何。因此，使用纯SOME / IP网络绑定的消息可以与使用基于信号的网络绑定的消息一起在同一个套接字上传输。


Also one service which consists of events with different serialization technologies (i.e. someip and signalBased) shall be able to be transported on the same socket (this is covered by the signal-based network binding).

> 也有一项服务，它由具有不同序列化技术（即someip和基于信号的）的事件组成，可以在同一个套接字上传输（这由基于信号的网络绑定涵盖）。

Based on [[SWS_CM_10000](#_bookmark37)]:


**[SWS_CM_80001]**{DRAFT} *[*The signal-based network binding shall implement the SOME/IP Service Discovery Protocol defined in [12] and the SOME/IP Protocol defined in [5] (except for the serialization of signal-based payload).*♩(RS_CM_00204, RS_CM_00205, RS_CM_00004)*

> **[SWS_CM_80001]**{草案} *[*信号基础网络绑定应实施由[12]定义的SOME/IP服务发现协议和由[5]定义的SOME/IP协议（除了信号基础有效负载的序列化）。*♩(RS_CM_00204, RS_CM_00205, RS_CM_00004)*

[[SWS_CM_10013](#_bookmark38)] applies.


This means that Length and Type fields shall be always in network byte order. Based on [[SWS_CM_10172](#_bookmark39)]:

> 这意味着长度和类型字段应始终以网络字节顺序表示。根据[[SWS_CM_10172](#_bookmark39)]：


**[SWS_CM_80003]**{DRAFT} **Byte order for signal-based network binding with SOME/IP serialization** *[*If SomeipEventDeployment.serializer is set to someip then the byte order of the parameters inside the payload shall be defined by byteOrder of ApSomeipTransformationProps.*♩(RS_CM_00204, RS_SOMEIP_00026, RS_CM_00004)*

> **[SWS_CM_80003]**{草案} **基于信号的网络绑定使用 SOME/IP 序列化的字节顺序** *[*如果SomeipEventDeployment.serializer被设置为someip，则有效负载中的参数的字节顺序应由ApSomeipTransformationProps的byteOrder定义。*♩（RS_CM_00204，RS_SOMEIP_00026，RS_CM_00004）*


**[SWS_CM_80004]**{DRAFT} **Byte order for signal-based network binding with signal-based serialization** *[*If SomeipEventDeployment.serializer is set to signalBased then the byte order of the parameters inside the payload shall be defined by the respective packingByteOrder of ISignalToIPduMapping and by the packingByteOrder of PduToFrameMapping.*♩(RS_CM_00004)*

> **[SWS_CM_80004]**{草案}**基于信号的网络绑定和基于信号的序列化的字节顺序** *[*如果SomeipEventDeployment.serializer设置为signalBased，则支付负载中的参数的字节顺序由ISignalToIPduMapping的相应packingByteOrder和PduToFrameMapping的packingByteOrder定义。*♩(RS_CM_00004)*

[[SWS_CM_10240](#_bookmark40)] applies.

### Service Discovery


The section [7.5.1.2](#service-discovery) is fully applicable to the signal-based network binding.

> 部分[7.5.1.2](#service-discovery)完全适用于基于信号的网络绑定。

### Accumulation of messages

Based on [[SWS_CM_10387](#_bookmark50)]:


**[SWS_CM_80017]**{DRAFT} **Data accumulation for UDP data transmission** *[*To allow for the transmission of multiple messages (SOME/IP event, SOME/IP method request, SOME/IP method response, signal-based event, and signal-based field notifier) within a single UDP datagram, data accumulation for UDP data transmission shall be supported.*♩(RS_CM_00204, RS_CM_00004)*

> **[SWS_CM_80017]**{草稿} **UDP 数据传输的数据积累** *[*为了允许在单个 UDP 数据报中传输多个消息（SOME/IP 事件、SOME/IP 方法请求、SOME/IP 方法响应、基于信号的事件和基于信号的字段通知），应支持 UDP 数据传输的数据积累。*♩(RS_CM_00204, RS_CM_00004)*


[[SWS_CM_10388](#_bookmark51)] applies. Based on [[SWS_CM_10389](#_bookmark52)]:

> [[SWS_CM_10388](#_bookmark51)]适用。根据[[SWS_CM_10389](#_bookmark52)]：


**[SWS_CM_80019]**{DRAFT} **Configuration of a data accumulation on a ProvidedSomeipServiceInstance for transmission over UDP** *[*For a ProvidedSomeipServiceInstance all method responses and events for which the udpCollectionTrigger is set to never shall be aggregated in a buffer until a trigger arrives that starts the data transmission.

> **[SWS_CM_80019]**{草案} **配置在ProvidedSomeipServiceInstance上累积数据以通过UDP传输** *[*对于ProvidedSomeipServiceInstance，所有udpCollectionTrigger设置为never的方法响应和事件都应聚合在缓冲区中，直到触发器到达开始数据传输。

The following trigger options shall be supported:

- a message needs to be transmitted for which the udpCollectionTrigger is set to always.

- the udpCollectionBufferTimeout is reached for one of the message already aggregated in the buffer.

> 缓冲区中已聚合的消息之一已达到udpCollectionBufferTimeout。
- the buffer size defined by the attribute udpCollectionBufferSizeThreshold is reached.

- adding the method response or event to the buffer would lead to a message larger than the maximum possible size (e.g. MTU size). In this case the actual buffer shall be triggered before handling the new event or method response.

> 加入方法响应或事件到缓冲区会导致消息大小超过最大可能大小（例如MTU大小）。在这种情况下，应在处理新事件或方法响应之前触发实际缓冲区。

*♩(RS_CM_00204, RS_CM_00004)*

Based on [[SWS_CM_10390](#_bookmark53)]:


**[SWS_CM_80020]**{DRAFT} **Configuration of a data accumulation on a RequiredSomeipServiceInstance for transmission over UDP** *[*For a RequiredSomeipServiceInstance all method requests for which the udpCollectionTrigger is set to never shall be aggregated in a buffer until a trigger arrives that starts the data transmission.

> **[SWS_CM_80020]**{草案} **关于RequiredSomeipServiceInstance上的数据积累并通过UDP传输的配置** *[*对于RequiredSomeipServiceInstance，所有udpCollectionTrigger设置为从不的方法请求都应被缓存起来，直到触发器到达开始数据传输。

The following trigger options shall be supported:

- a message needs to be transmitted for which the udpCollectionTrigger is set to always.

- the udpCollectionBufferTimeout is reached for one of the message already aggregated in the buffer.

> 缓冲区中的一条消息的udpCollectionBufferTimeout已达到。
- the buffer size defined by the attribute udpCollectionBufferSizeThreshold is reached.

- adding the method request or event to the buffer would lead to a message larger than the maximum possible size (e.g. MTU size). In this case the actual buffer shall be triggered before handling the new event or method response.

> 如果将方法请求或事件添加到缓冲区，则消息大小将超过最大可能大小（例如MTU大小）。在这种情况下，应在处理新事件或方法响应之前触发实际缓冲区。

*♩(RS_CM_00204, RS_CM_00004)*


In the following sections the term \"sending of a message shall be requested\" will be used to describe the fact that the sending of the message is requested but may be deferred due to data accumulation for UDP data transmission according to [[SWS_CM_10388](#_bookmark51)], [[SWS_CM_80019](#_bookmark166)], and [[SWS_CM_80020](#_bookmark167)].

> 在接下来的章节中，术语“发送消息应该被请求”将被用于描述这样一个事实：根据[[SWS_CM_10388](#_bookmark51)], [[SWS_CM_80019](#_bookmark166)], 和[[SWS_CM_80020](#_bookmark167)]，发送消息被请求，但可能会因为数据累积而被推迟。

### Execution context of message reception actions


The section [7.5.1.4](#execution-context-of-message-reception-actions) is fully applicable to the signal-based network binding.

> 章节[7.5.1.4](#execution-context-of-message-reception-actions)完全适用于基于信号的网络绑定。

### Handling Events

Based on [[SWS_CM_10287](#_bookmark56)]:


**[SWS_CM_80021]**{DRAFT} **Conditions for sending of an event message** *[*The sending of an event message shall be requested by invoking the Send method of the respective Event class (see [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)] and [[SWS_CM_90437](#_bookmark532)]) if there is at least one active subscriber and the offer of the service containing the event has not been stopped (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called). An active subscriber is an adaptive application that has invoked the Subscribe method of the respective Event class (see [[SWS_CM_00141](#_bookmark559)]) and has not canceled the subscription by invoking the Unsubscribe method of the respective Event class (see [[SWS_CM_00151](#_bookmark560)]) and where the subscription has not yet expired since the TTL contained in the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has been exceeded.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_SOMEIP_00017, RS_CM_00004)*

> 发送事件消息的条件：如果至少有一个活跃的订阅者，并且包含事件的服务的提供尚未停止（要么是因为SOME/IP OfferService消息（参见[[SWS_CM_00203](#_bookmark45)）中包含的TTL已过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见[[SWS_CM_00111](#_bookmark523)）已被调用），则应调用各自事件类的Send方法（参见[[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)]和[[SWS_CM_90437](#_bookmark532)）来请求发送事件消息。活跃的订阅者是一个调用了各自事件类的Subscribe方法（参见[[SWS_CM_00141](#_bookmark559)）并且尚未通过调用各自事件类的Unsubscribe方法（参见[[SWS_CM_00151](#_bookmark560)）取消订阅，并且订阅尚未过期（因为SOME/IP SubscribeEventgroup消息（参见[[SWS_CM_00205](#_bookmark47)）中包含的TTL未超过）的自适应应用程序。（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00005，RS_SOMEIP_00017，RS_CM_00004）

Based on [[SWS_CM_10288](#_bookmark57)]:


**[SWS_CM_80022]**{DRAFT} **Transport protocol for sending of an event message** *[*The event message shall be transmitted using UDP if the threshold defined by the multicastThreshold attribute of the SomeipProvidedEventGroup that is aggregated by the ProvidedSomeipServiceInstance in the role eventGroup in the Manifest has been reached (see [PRS_SOMEIPSD_00134]).

> **[SWS_CM_80022]**{草案} **用于发送事件消息的传输协议** *[*如果在Manifest中以eventGroup角色聚合的SomeipProvidedEventGroup的multicastThreshold属性定义的阈值已达到，则事件消息应使用UDP传输（参见[PRS_SOMEIPSD_00134]）。


The event message shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.eventDeployment.transportProtocol in the Manifest if this threshold has not been reached (see [PRS_SOMEIPSD_00802]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00010, RS_CM_00004)*

> 事件信息应使用在清单中定义的属性SomeipServiceInterfaceDeployment.eventDeployment.transportProtocol定义的传输协议进行传输，如果未达到此阈值（请参见[PRS_SOMEIPSD_00802]）。*♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00010，RS_CM_00004）*

Based on [[SWS_CM_10289](#_bookmark58)]:


**[SWS_CM_80023]**{DRAFT} **Source of an event message** *[*The event message shall use the unicast IP address and port taken from the IPv4/v6 Endpoint Option (see [PRS_SOMEIPSD_00307] and [PRS_SOMEIPSD_00315]) of the SOME/IP OfferSer-

> **[SWS_CM_80023]**{草案} **事件消息的来源** *[*事件消息应使用从SOME/IP OfferSer的IPv4/v6端点选项（参见[PRS_SOMEIPSD_00307]和[PRS_SOMEIPSD_00315]）获取的单播IP地址和端口。


vice message ([[SWS_CM_00203](#_bookmark45)]) as source address and source port for the transmission.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00042, RS_CM_00004)*

> 将消息（[[SWS_CM_00203](#_bookmark45)）作为传输的源地址和源端口，（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00042，RS_CM_00004）。

Based on [[SWS_CM_10290](#_bookmark59)]:


**[SWS_CM_80024]**{DRAFT} **Destination of an event message** *[*The event message shall use the multicast IP address and the port taken from the IPv4/v6 Multicast Option (see [PRS_SOMEIPSD_00326] and [PRS_SOMEIPSD_00333]) of the SOME/IP SubscribeEventgroupAck message (see [[SWS_CM_00206](#_bookmark48)]) as destination address and destination port for the transmission if the threshold defined by the multicastThreshold attribute of the SomeipProvidedEventGroup that is aggregated by the ProvidedSomeipServiceInstance in the role eventGroup in the Manifest has been reached (see [PRS_SOMEIPSD_00134]). The event message shall use the unicast IP address and the port taken from the IPv4/v6 Endpoint Option (see [PRS_SOMEIPSD_00307] and [PRS_SOMEIPSD_00315]) of the SOME/IP SubscribeEventgroup message ([[SWS_CM_00205](#_bookmark47)]) as destination address and destination port for the transmission if this threshold has not been reached (see [PRS_SOMEIPSD_00134]). In case multiple Endpoint Options have been contained in the SOME/IP SubscribeEventgroup message, the one matching the selected transport protocol (see [[SWS_CM_80023](#_bookmark171)]) shall be used.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00042, RS_CM_00004)*

> **[SWS_CM_80024]**{草案} **事件消息的目的地** *[*如果聚合于Manifest中以eventGroup角色提供的SomeipProvidedEventGroup的multicastThreshold属性被触发（参见[PRS_SOMEIPSD_00134]），则事件消息应使用从SOME/IP SubscribeEventgroupAck消息（参见[[SWS_CM_00206](#_bookmark48)）的IPv4/v6多播选项中获取的多播IP地址和端口作为目的地址和目的端口进行传输（参见[PRS_SOMEIPSD_00326]和[PRS_SOMEIPSD_00333]）。如果未触发该阈值，则事件消息应使用从SOME/IP SubscribeEventgroup消息（参见[[SWS_CM_00205](#_bookmark47)）的IPv4/v6端点选项中获取的单播IP地址和端口作为目的地址和目的端口进行传输（参见[PRS_SOMEIPSD_00307]和[PRS_SOMEIPSD_00315]）。如果SOME/IP SubscribeEventgroup消息中包含多个端点选项，则应使用与所选传输协议匹配的一个（参见[[SWS_CM_80023](#_bookmark171)）。*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00042, RS_CM_00004)*


Based on the serviceInterfaceId and eventId the respective event is determined. If the serializer is defined as someip serializer the SOME/IP event handling applies.

> 根据服务接口ID和事件ID确定相应的事件。如果序列化器定义为someip序列化器，则应用SOME/IP事件处理。

Based on [[SWS_CM_10291](#_bookmark60)]:

### [SWS_CM_80025] {DRAFT} Content of the SOME/IP serialized event message *[*If


SomeipEventDeployment.serializer is set to someip then the entries in the SOME/IP serialized event message shall be as follows:

> 如果将SomeipEventDeployment.serializer设置为someip，则SOME/IP序列化事件消息的条目如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了eventDeployment.eventId，将0x8000加到eventDeployment.eventId上。


- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效负载的长度，以字节为单位增加8（SOME / IP头的第二部分由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) is unused for event messages (according to [PRS_SOMEIP_00702]) and thus shall be set to 0x0000.

> 客户端ID（参见[PRS_SOMEIP_00702]）对于事件消息没有使用（根据[PRS_SOMEIP_00702]），因此应设置为0x0000。

- In case of inactive Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID (see [PRS_SOMEIP_00703]) is unused for event messages and thus shall be set to 0x0000 (see [PRS_SOMEIP_00932]) and [PRS_SOMEIP_00925]).

> 在处理不活跃会话的情况下，请参阅[[SWS_CM_10240](#_bookmark40)]，会话ID（参见[PRS_SOMEIP_00703]）对于事件消息没有使用，因此应设置为0x0000（参见[PRS_SOMEIP_00932]和[PRS_SOMEIP_00925]）。


In case of active Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID is used for event messages and thus shall be incremented (with proper wrap around) upon every transmission of an event message (see [PRS_SOMEIP_00933], [PRS_SOMEIP_00934], [PRS_SOMEIP_00521], and [PRS_SOMEIP_- 00925]).

> 在活动会话处理的情况下，请参见[[SWS_CM_10240](#_bookmark40)]，会话ID用于事件消息，因此每次发送事件消息时，应该递增（适当地环绕）（参见[PRS_SOMEIP_00933]，[PRS_SOMEIP_00934]，[PRS_SOMEIP_00521]和[PRS_SOMEIP_-00925]）。


The information whether the Session Handling is activated or deactivated for an event can be derived from the sessionHandling attribute contained in the ApSomeipTransformationProps that is referenced by the TransformationPropsToServiceInterfaceElementMapping that in turn points to the event.

> 可以从指向事件的TransformationPropsToServiceInterfaceElementMapping中引用的ApSomeipTransformationProps中的sessionHandling属性中获取事件的会话处理是否已激活或停用的信息。

- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceVersion.majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to NOTIFICATION

(0x02).


- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for event messages and thus (according to [PRS_SOMEIP_00925]) shall be set to E_OK (0x00).

> 根据[PRS_SOMEIP_00925]，事件消息的返回代码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）未使用，因此应设置为E_OK（0x00）。

- The Payload shall contain the serialized payload (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) according to the SOME/IP serialization rules.

> 负载应根据SOME/IP序列化规则包含序列化的负载（即由角色事件中的ServiceInterface组成的序列化VariableDataPrototype）。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_CM_00004)*

> *♩(RS_CM_00204、RS_CM_00200、RS_CM_00201、RS_SOMEIP_00041、RS_SOMEIP_00022、RS_SOMEIP_00003、RS_SOMEIP_00004、RS_CM_00004)*


If the serializer is defined as signalBased the signal-based event handling applies. As the message containing the signal-based payload is going to be routed to the Classic platform (without the SOME/IP Transformation) the header just contains the Message Id (i.e. ServiceID and Method ID) (see [[SWS_CM_80026](#sws_cm_80026draft-content-of-the-signal-based-serialized-event-message)]).

> 如果序列化器定义为基于信号，则应用基于信号的事件处理。由于包含基于信号的有效载荷的消息将被路由到经典平台（无需SOME / IP转换），因此头部只包含消息ID（即服务ID和方法ID）（参见[[SWS_CM_80026]（#sws_cm_80026draft-content-of-the-signal-based-serialized-event-message）））。

### [SWS_CM_80026] {DRAFT} Content of the signal-based serialized event message


*[*If SomeipEventDeployment.serializer is set to signalBased then the entries in the signal-based event message shall be as follows:

> 如果SomeipEventDeployment.serializer设置为signalBased，那么基于信号的事件消息中的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从清单中派生，其中SomeipServiceInterfaceDeployment元素定义eventDeployment.eventId，并将0x8000加到eventDeployment.eventId上。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes

> 长度（参见[PRS_SOMEIP_00042]）应以字节为单位设置为序列化有效载荷的长度。

- The Payload shall contain the serialized payload (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) according to the signal-service-translation serialization rules defined in TPSManifestSpecification [6].

> 负载应根据TPSManifestSpecification [6]中定义的signal-service-translation序列化规则，包含序列化的负载（即由服务接口在角色事件中组成的序列化VariableDataPrototype）。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_CM_00004)*

> *♩(RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00041，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_CM_00004)*


If the serializer is defined as someip serializer the SOME/IP event handling applies.

> 如果序列化器定义为SOME/IP序列化器，则SOME/IP事件处理适用。

Based on [[SWS_CM_10292](#_bookmark61)]:


**[SWS_CM_80027]**{DRAFT} **Checks for a received SOME/IP serialized event message** *[*If SomeipEventDeployment.serializer is set to someip then upon reception of a SOME/IP serialized event message the following checks shall be conducted:

> **[SWS_CM_80027]** {草案} **检查接收的SOME / IP序列化事件消息** *[*如果SomeipEventDeployment.serializer设置为someip，则在接收到SOME / IP序列化事件消息后，将执行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.

- Use the Length being larger than 8 in combination with the Message type (see [PRS_SOMEIP_00055]) being set to NOTIFICATION to determine that the received SOME/IP message is actually an event.

> 使用长度大于8与消息类型（参见[PRS_SOMEIP_00055]）设置为NOTIFICATION，以确定接收到的SOME/IP消息实际上是一个事件。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches 0x8000 + eventId attribute of one of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment which have the attribute SomeipEventDeployment.serializer set to someip.

> 验证 Method ID（参见[PRS_SOMEIP_00245]）是否与某个SomeipEventDeployment的SomeipEventDeployment.serializer属性设置为someip的SomeipServiceInterfaceDeployment的eventId属性加上0x8000相匹配。
- Verify that the Client ID (see [PRS_SOMEIP_00702]) is set to 0x0000.

- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 确认接口版本（参见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion匹配。

- Verify that the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is set to E_OK (0x00).

> 验证返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为E_OK（0x00）。


If any of the above checks fails the received SOME/IP serialized event message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014, RS_CM_00004)*

> 如果上述任何一个检查失败，则应丢弃接收到的SOME/IP序列化事件消息，并记录事件（如果ara::com实现启用了日志记录）。♩（RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00019，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00008，RS_SOMEIP_00014，RS_CM_00004）


If the serializer is defined as signalBased the signal-based event handling applies. As the message containing the signal-based payload is coming from the Classic platform (without the SOME/IP Transformation) the header just contains the Message Id (i.e. ServiceID and Method ID) (see [[SWS_CM_80028](#_bookmark175)]).

> 如果序列化器定义为基于信号，则应用基于信号的事件处理。由于包含基于信号的有效负载的消息来自经典平台（未经SOME / IP转换），头部只包含消息ID（即服务ID和方法ID）（参见[[SWS_CM_80028]（#_bookmark175）]）。


**[SWS_CM_80028]**{DRAFT} **Checks for a received signal-based serialized event message** *[*If SomeipEventDeployment.serializer is set to signalBased then upon reception of a signal-based serialized event message the following checks shall be conducted:

> **[SWS_CM_80028]**{草案} **检查接收的基于信号的序列化事件消息** *[*如果SomeipEventDeployment.serializer设置为signalBased，则在接收到基于信号的序列化事件消息后，应进行以下检查：


- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches 0x8000  the eventId attribute of one of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment which have the attribute SomeipEventDeployment.serializer set to signalBased.

> 请验证方法ID（参见[PRS_SOMEIP_00245]）是否与具有SomeipEventDeployment.serializer属性设置为signalBased的SomeipServiceInterfaceDeployment的one of the SomeipEventDeployments的eventId属性匹配0x8000。

- Verify that the Length is larger than 0.


If any of the above checks fails the received signal-based event message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014, RS_CM_00004)*

> 如果上述任何一个检查失败，则应丢弃基于接收信号的事件消息，并且如果ara :: com实现启用了日志记录，则应记录事件（RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00019，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00008，RS_SOMEIP_00014，RS_CM_00004）。


[[SWS_CM_10293](#_bookmark62)] applies. Based on [[SWS_CM_10379](#_bookmark63)]:

> [[SWS_CM_10293](#_bookmark62)] 适用。根据 [[SWS_CM_10379](#_bookmark63)]：


**[SWS_CM_80030]**{DRAFT} **Silently discarding event messages for unsubscribed events** *[*If the event identified according to [[SWS_CM_10293](#_bookmark62)] does not have an active subscription because the Subscribe method (see [[SWS_CM_00141](#_bookmark559)]) of the specific Event class of the ServiceProxy class has not been called, or the Unsubscribe method (see [[SWS_CM_00151](#_bookmark560)]) of the specific Event class of the ServiceProxy class has been called, or the TTL of the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has expired, then the received event message shall be silently discarded (i.e., [[SWS_CM_80032](#sws_cm_80032draft-deserializing-the-someip-serialized-payload-if)], [[SWS_CM_80033](#_bookmark177)], [[SWS_CM_10295](#_bookmark66)], and [[SWS_CM_10296](#_bookmark64)] shall *not* be performed).*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_CM_00004)*

> 如果根据[[SWS_CM_10293](#_bookmark62)]确定的事件没有活动的订阅，因为没有调用ServiceProxy类的Subscribe方法（参见[[SWS_CM_00141](#_bookmark559)），或者已经调用了ServiceProxy类的Unsubscribe方法（参见[[SWS_CM_00151](#_bookmark560)），或者SOME / IP SubscribeEventgroup消息（参见[[SWS_CM_00205](#_bookmark47)）的TTL已过期，则收到的事件消息将被静默丢弃（即，[[SWS_CM_80032](#sws_cm_80032draft-deserializing-the-someip-serialized-payload-if)，[[SWS_CM_80033](#_bookmark177)，[[SWS_CM_10295](#_bookmark66)和[[SWS_CM_10296](#_bookmark64)）不会执行）。*♩（RS_CM_00204，RS_CM_00203，RS_SOMEIP_00004，RS_CM_00004）*


[[SWS_CM_10296](#_bookmark64)] applies. Based on [[SWS_CM_10294](#_bookmark65)]:

> [[SWS_CM_10296](#_bookmark64)] 适用。根据 [[SWS_CM_10294](#_bookmark65)]：

### [SWS_CM_80032] {DRAFT} Deserializing the SOME/IP serialized payload *[*If


SomeipEventDeployment.serializer is set to someip then based on the event determined according to [[SWS_CM_10293](#_bookmark62)] the Payload of the SOME/IP serialized event message (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00028, RS_CM_00004)*

> 如果SomeipEventDeployment.serializer设置为someip，那么根据[[SWS_CM_10293](#_bookmark62)]确定的事件，SOME/IP序列化事件消息的有效载荷（即由服务接口在事件角色中组成的序列化变量数据原型）应根据SOME/IP序列化规则进行反序列化。*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00028, RS_CM_00004)*


**Note:** [[SWS_CM_80032](#sws_cm_80032draft-deserializing-the-someip-serialized-payload-if)] supports the mix of signal-based and SOME/IP communication use case defined in [[SWS_CM_10174](#_bookmark163)].

> **注意：** [[SWS_CM_80032](#sws_cm_80032draft-deserializing-the-someip-serialized-payload-if)] 支持在[[SWS_CM_10174](#_bookmark163)]中定义的基于信号和SOME / IP通信用例的混合。


**[SWS_CM_80033]**{DRAFT} **Deserializing the signal-based serialized payload** *[*If SomeipEventDeployment.serializer is set to signalBased then based on the event determined according to [[SWS_CM_10293](#_bookmark62)] the Payload of the signal-based serialized event message (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) shall be deserialized according to the signalservice-translation serialization rules defined in TPS-ManifestSpecification [6].*♩(RS_CM_00004)*

> **[SWS_CM_80033]**{草案} **反序列化基于信号的序列化有效负载** *[*如果SomeipEventDeployment.serializer设置为signalBased，那么根据[[SWS_CM_10293](#_bookmark62)]确定的事件，基于信号的序列化事件消息的有效负载（即由角色事件中的ServiceInterface组成的序列化VariableDataPrototype）应按照TPS-ManifestSpecification [6]中定义的signalservice-translation序列化规则进行反序列化。*♩(RS_CM_00004)*


[[SWS_CM_10295](#_bookmark66)] applies. [[SWS_CM_10360](#_bookmark67)] applies.

> [[SWS_CM_10295](#_bookmark66)] 適用。[[SWS_CM_10360](#_bookmark67)] 適用。

### Handling Triggers


**[SWS_CM_10518]**{DRAFT} **Conditions for sending of a trigger** *[*The sending of an trigger shall be requested by invoking the Send method of the respective Trigger class (see [[SWS_CM_00721](#_bookmark535)] if there is at least one active subscriber and the offer of the service containing the trigger has not been stopped (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called). An active subscriber is an adaptive application that has invoked the Subscribe method of the respective Trigger class (see [[SWS_CM_00723](#_bookmark579)]) and has not canceled the subscription by invoking the Unsubscribe method of the respective Trigger class (see [[SWS_CM_00810](#_bookmark580)]) and where the subscription has not yet expired since the TTL contained in the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has been exceeded.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_SOMEIP_-00017, RS_CM_00004)*

> 发送触发器的条件：如果至少有一个活跃的订阅者，且包含触发器的服务没有被停止（要么是因为SOME/IP OfferService消息（参见[[SWS_CM_00203](#_bookmark45)）中包含的TTL已过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见[[SWS_CM_00111](#_bookmark523)）已被调用），则可以通过调用相应触发器类的Send方法来请求发送触发器。活跃的订阅者是指已经调用了相应触发器类的Subscribe方法（参见[[SWS_CM_00723](#_bookmark579)），且尚未通过调用相应触发器类的Unsubscribe方法（参见[[SWS_CM_00810](#_bookmark580)）取消订阅，且订阅尚未过期（即SOME/IP SubscribeEventgroup消息（参见[[SWS_CM_00205](#_bookmark47)）中包含的TTL尚未超时）的适应性应用程序。（参考RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00005，RS_SOMEIP_-00017，RS_CM_00004）


Please note that in the Manifest configuration the SomeipServiceInterfaceDeployment.eventDeployment is used to configure triggers in the same way as events. The only difference is that in case of a trigger the SomeipEventDeployment will reference the Trigger in the role trigger. Therefore the following specification items described in chapter [7.5.2.1.4](#handling-events-1) are also valid for Triggers since a trigger defines a special kind of an event.

> 请注意，在Manifest配置中，SomeipServiceInterfaceDeployment.eventDeployment用于以与事件相同的方式配置触发器。唯一的区别是，在触发器的情况下，SomeipEventDeployment将在角色触发器中引用触发器。因此，第7.5.2.1.4节中描述的以下规范项也适用于触发器，因为触发器定义了一种特殊类型的事件。

- [[SWS_CM_80022](#_bookmark170)]
- [[SWS_CM_80023](#_bookmark171)]
- [[SWS_CM_80024](#_bookmark172)]


Based on the serviceInterfaceId and eventId the respective trigger is determined. If the serializer is defined as someip serializer the SOME/IP trigger handling applies.

> 根据服务接口ID和事件ID确定相应的触发器。如果序列化器定义为someip序列化器，则应用SOME/IP触发器处理。

### [SWS_CM_10519] {DRAFT} Content of the SOME/IP serialized trigger message *[*If


SomeipEventDeployment.serializer is set to someip then the entries in the SOME/IP serialized trigger message shall be as follows:

> 如果将SomeipEventDeployment.serializer设置为someip，那么SOME / IP序列化触发消息中的条目将如下所示：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceId。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义eventDeployment.eventId，将0x8000加到eventDeployment.eventId上。
- The Length shall be set to 8

- The Client ID (see [PRS_SOMEIP_00702]) is unused for trigger (according to [PRS_SOMEIP_00702]) and thus shall be set to 0x0000.

> 客户端ID（参见[PRS_SOMEIP_00702]）未用于触发（根据[PRS_SOMEIP_00702]），因此应设置为0x0000。

- In case of inactive Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID (see [PRS_SOMEIP_00703]) is unused for trigger and thus shall be set to 0x0000 (see [PRS_SOMEIP_00932]) and [PRS_SOMEIP_00925]).

> 在处理不活动的会话时，参见[[SWS_CM_10240](#_bookmark40)]，会话ID（见[PRS_SOMEIP_00703]）不用于触发，因此应设置为0x0000（见[PRS_SOMEIP_00932]和[PRS_SOMEIP_00925]）。


In case of active Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID is used for trigger and thus shall be incremented (with proper wrap around) upon every transmission of an trigger (see [PRS_SOMEIP_00933], [PRS_SOMEIP_00934], [PRS_SOMEIP_00521], and [PRS_SOMEIP_00925]).

> 在活动会话处理的情况下，参见[[SWS_CM_10240](#_bookmark40)]，会话ID用于触发，因此每次发送触发器时都应增加（并适当进行环绕）（参见[PRS_SOMEIP_00933]，[PRS_SOMEIP_00934]，[PRS_SOMEIP_00521]和[PRS_SOMEIP_00925]）。


The information whether the Session Handling is activated or deactivated for a trigger can be derived from the sessionHandling attribute contained in the ApSomeipTransformationProps that is referenced by the TransformationPropsToServiceInterfaceElementMapping that in turn points to the trigger.

> 可以从引用触发器的ApSomeipTransformationProps中包含的sessionHandling属性中获取会话处理是否为触发器激活或停用的信息，该属性又指向TransformationPropsToServiceInterfaceElementMapping。

- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义服务接口版本的majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to NOTIFICATION

(0x02).


- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for trigger messages and thus (according to [PRS_SOMEIP_00925]) shall be set to E_OK (0x00).

> 返回代码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对触发消息不可用，因此（根据[PRS_SOMEIP_00925]）应设置为E_OK（0x00）。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_CM_00004)*

> *♩(RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00041，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_CM_00004)*


If the serializer is defined as signalBased the signal-based trigger handling applies. As the message containing the signal-based payload is going to be routed to the Classic platform (without the SOME/IP Transformation) the header just contains the Message Id (i.e. ServiceID and Method ID) (see [[SWS_CM_10520](#_bookmark179)]).

> 如果序列化器定义为基于信号，则应用基于信号的触发处理。由于包含基于信号的有效负载的消息将被路由到Classic平台（而不是SOME / IP转换），因此头部只包含消息ID（即ServiceID和Method ID）（参见[[SWS_CM_10520](#_bookmark179)]）。


**[SWS_CM_10520]**{DRAFT} **Content of the signal-based serialized trigger message** *[*If SomeipEventDeployment.serializer is set to signalBased then the entries in the signal-based trigger shall be as follows:

> **[SWS_CM_10520]**{草案} **信号基础序列化触发消息的内容** *[*如果SomeipEventDeployment.serializer设置为基于信号，则信号触发器中的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从清单中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从清单中导出，其中SomeipServiceInterfaceDeployment元素定义了eventDeployment.eventId，将0x8000加到eventDeployment.eventId上。
- The Length shall be set to 0.


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_CM_00004)*

> *♩(RS_CM_00204、RS_CM_00200、RS_CM_00201、RS_SOMEIP_00041、RS_SOMEIP_00022、RS_SOMEIP_00003、RS_SOMEIP_00004、RS_CM_00004)*


If the serializer is defined as someip serializer the SOME/IP trigger handling applies.

> 如果序列化器被定义为SOME/IP序列化器，则SOME/IP触发处理将应用。


**[SWS_CM_10521]**{DRAFT} **Checks for a received SOME/IP serialized trigger message** *[*If SomeipEventDeployment.serializer is set to someip then upon reception of a SOME/IP serialized trigger the following checks shall be conducted:

> **[SWS_CM_10521]**{草案}**检查接收到的SOME/IP序列化触发消息** *[*如果SomeipEventDeployment.serializer设置为someip，则在接收到SOME/IP序列化触发时，应进行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.

- Use the Length being equal to 8 in combination with the Message type (see [PRS_SOMEIP_00055]) being set to NOTIFICATION to determine that the received SOME/IP message is actually a trigger.

> 使用长度等于8，结合消息类型（参见[PRS_SOMEIP_00055]）设置为NOTIFICATION，可以确定收到的SOME/IP消息实际上是一个触发器。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。
- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches 0x8000


\+ the eventId attribute of one of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment which have the attribute SomeipEventDeployment.serializer set to someip.

> 请帮助我翻译：“某个SomeipServiceInterfaceDeployment的SomeipEventDeployment的eventId属性，其SomeipEventDeployment.serializer属性设置为someip。”为简体中文

- Verify that the Client ID (see [PRS_SOMEIP_00702]) is set to 0x0000.

- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 验证接口版本（见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion匹配。

- Verify that the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is set to E_OK (0x00).

> 验证返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为E_OK（0x00）。


If any of the above checks fails the received SOME/IP serialized trigger shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014, RS_CM_00004)*

> 如果上述任何一个检查失败，接收到的SOME/IP序列化触发器将被丢弃，并且事件将被记录（如果ara :: com实现启用了日志记录）。(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014, RS_CM_00004)


If the serializer is defined as signalBased the signal-based trigger handling applies. As the message containing the signal-based payload is coming from the Classic platform (without the SOME/IP Transformation) the header just contains the Message Id (i.e. ServiceID and Method ID) (see [[SWS_CM_10520](#_bookmark179)]).

> 如果序列化器定义为基于信号，则应用信号触发处理。由于消息包含基于信号的有效载荷，而来自经典平台（未经SOME / IP转换），因此消息头仅包含消息ID（即ServiceID和Method ID）（参见[[SWS_CM_10520](#_bookmark179)）。

### [SWS_CM_10522] {DRAFT} Checks for a received signal-based serialized trigger


*[*If SomeipEventDeployment.serializer is set to signalBased then upon reception of a signal-based serialized trigger the following checks shall be conducted:

> 如果SomeipEventDeployment.serializer设置为signalBased，那么在接收到基于信号的序列化触发器后，将进行以下检查：


- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。
- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches 0x8000


\+ the eventId attribute of one of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment which have the attribute SomeipEventDeployment.serializer set to signalBased.

> 其中拥有属性SomeipEventDeployment.serializer设置为signalBased的SomeipServiceInterfaceDeployment的SomeipEventDeployments之一的eventId属性。

- Verify that the Length is equal to 0.


If any of the above checks fails the received signal-based trigger shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014, RS_CM_00004)*

> 如果上述任何检查失败，接收到的基于信号的触发器将被丢弃，并且事件将被记录（如果ara::com实现启用了日志记录）。（RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00019，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00008，RS_SOMEIP_00014，RS_CM_00004）

[[SWS_CM_10514](#_bookmark69)] applies.


**[SWS_CM_10523]**{DRAFT} **Silently discarding trigger for unsubscribed triggers** *[*If the trigger identified according to [[SWS_CM_10514](#_bookmark69)] does not have an active subscription because the Subscribe method (see [[SWS_CM_00723](#_bookmark579)]) of the specific Trigger class of the ServiceProxy class has not been called, or the Unsubscribe method (see [[SWS_CM_00810](#_bookmark580)]) of the specific Trigger class of the ServiceProxy class has been called, or the TTL of the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has expired, then the received trigger shall be silently discarded (i.e., [[SWS_CM_00226](#_bookmark582)], and [[SWS_CM_00249](#_bookmark584)] shall *not* be performed).*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_CM_00004)* [[SWS_CM_00249](#_bookmark584)] applies.

> 如果根据[[SWS_CM_10514](#_bookmark69)]确定的触发器没有激活订阅，因为没有调用ServiceProxy类的Subscribe方法（参见[[SWS_CM_00723](#_bookmark579)），或者已经调用了ServiceProxy类的Unsubscribe方法（参见[[SWS_CM_00810](#_bookmark580)），或者SOME/IP SubscribeEventgroup消息的TTL（参见[[SWS_CM_00205](#_bookmark47)）已经过期，那么收到的触发器将被静默丢弃（即[[SWS_CM_00226](#_bookmark582)，和[[SWS_CM_00249](#_bookmark584)]不会执行）。 [[SWS_CM_00249](#_bookmark584)]适用。

### Handling Method Calls


As the signal service translation does not apply to methods the handling is identical to the SOME/IP method serialization, see chapter [7.5.1.7](#handling-method-calls).

> 随着信号服务翻译不适用于方法，处理与SOME/IP方法序列化相同，请参见第7.5.1.7章节。

### Handling Fields

Based on [[SWS_CM_10319](#_bookmark97)]:


**[SWS_CM_80063]**{DRAFT} **Conditions for sending of an event message** *[*The sending of an event message shall be requested by invoking the Update method of the respective Field class (see [[SWS_CM_00119](#_bookmark548)]) or if the Future returned by the SetHandler registered with RegisterSetHandler (see [[SWS_CM_00116](#_bookmark546)]) becomes ready if there is at least one active subscriber and the offer of the service containing the event has not been stopped (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called). An active subscriber is an adaptive application that has invoked the Subscribe method of the respective Field class (see [[SWS_CM_00120](#_bookmark440)]) and has not canceled the subscription by invoking the Unsubscribe method of the respective Field class (see [[SWS_CM_00120](#_bookmark440)]) and where the subscription has not yet expired since the TTL contained in the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has been exceeded.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00005, RS_SOMEIP_00017, RS_SOMEIP_00018, RS_CM_00004)*

> 发送事件信息的条件：通过调用相应字段类的Update方法（参见[[SWS_CM_00119](#_bookmark548)）或者通过调用RegisterSetHandler注册的SetHandler（参见[[SWS_CM_00116](#_bookmark546)）返回的Future来请求发送事件信息，前提是至少有一个活跃的订阅者，而且包含事件的服务未停止（要么是因为包含在SOME/IP OfferService消息（参见[[SWS_CM_00203](#_bookmark45)）中的TTL已经过期，要么是因为调用了ServiceSkeleton类的StopOfferService方法（参见[[SWS_CM_00111](#_bookmark523)））。活跃的订阅者是调用了相应字段类的Subscribe方法（参见[[SWS_CM_00120](#_bookmark440)）的自适应应用，并且未调用相应字段类的Unsubscribe方法（参见[[SWS_CM_00120](#_bookmark440)）取消订阅，而且订阅未过期，因为包含在SOME/IP SubscribeEventgroup消息（参见[[SWS_CM_00205](#_bookmark47)）中的TTL尚未超过。（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00009，RS_SOMEIP_00005，RS_SOMEIP_00017，RS_SOMEIP_00018，RS_CM_00004）

Based on [[SWS_CM_10320](#_bookmark98)]:


**[SWS_CM_80064]**{DRAFT} **Transport protocol for sending of an event message** *[*The event message shall be transmitted using UDP if the threshold defined by the multicastThreshold attribute of the SomeipProvidedEventGroup that is aggregated by the ProvidedSomeipServiceInstance in the role eventGroup in the Manifest has been reached (see [PRS_SOMEIPSD_00134]).

> **[SWS_CM_80064]**{草案} **传输协议用于发送事件消息** *[*如果在清单中以事件组角色聚合的SomeipProvidedEventGroup的multicastThreshold属性定义的阈值已达到，则事件消息将使用UDP传输（参见[PRS_SOMEIPSD_00134]）。


The event message shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.fieldDeployment.notifier. transportProtocol in the Manifest if this threshold has not been reached (see [PRS_SOMEIPSD_00802]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00010, RS_CM_00004)*

> 事件信息应使用Manifest中由SomeipServiceInterfaceDeployment.fieldDeployment.notifier.transportProtocol定义的传输协议进行传输，如果没有达到阈值（参见[PRS_SOMEIPSD_00802]）。*（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00009，RS_SOMEIP_00010，RS_CM_00004）*

Based on [[SWS_CM_10321](#_bookmark99)]:


**[SWS_CM_80065]**{DRAFT} **Source of an event message** *[*The source address and the source port of the event message shall set according to [[SWS_CM_80023](#_bookmark171)].*♩ (RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042, RS_CM_00004)*

> **[SWS_CM_80065]**{草案} **事件消息的来源** *[*事件消息的源地址和源端口应根据[[SWS_CM_80023](#_bookmark171)]设置。*♩ (RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042, RS_CM_00004)*

译：**[SWS_CM_80065]**{草案} **事件消息的来源** *[*事件消息的源地址和源端口应按照[[SWS_CM_80023](#_bookmark171)]设置。*♩ (RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042, RS_CM_00004)*

Based on [[SWS_CM_10322](#_bookmark100)]:


**[SWS_CM_80066]**{DRAFT} **Destination of an event message** *[*The destination address and the destination port of the event message shall be set according to [[SWS_CM_80024](#_bookmark172)].*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042, RS_CM_00004)*

> **[SWS_CM_80066]**{草稿} **事件消息的目标地址** *[*事件消息的目标地址和目标端口应根据[[SWS_CM_80024](#_bookmark172)]设置。*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042, RS_CM_00004)*


Based on the serviceInterfaceId and eventId the respective field notifier is determined. If the serializer is defined as someip serializer the SOME/IP serialized event handling applies.

> 根据服务接口ID和事件ID确定相应的通知者。如果序列化器定义为someip序列化器，则应用SOME/IP序列化事件处理。

Based on [[SWS_CM_10323](#_bookmark101)]:

### [SWS_CM_80067] {DRAFT} Content of the SOME/IP serialized event message *[*If


SomeipEventDeployment.serializer is set to someip then the entries in the SOME/IP serialized event message shall be as follows:

> 如果SomeipEventDeployment.serializer被设置为someip，那么SOME/IP序列化事件消息中的条目将如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中推导出来，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了eventDeployment.eventId，通过将0x8000加到eventDeployment.eventId来定义。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效负载的长度，单位为字节，增加8（SOME / IP头的第二部分由Length覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) is unused for event messages (according to [PRS_SOMEIP_00702]) and thus shall be set to 0x0000.

> 客户端ID（参见[PRS_SOMEIP_00702]）对于事件消息未使用（根据[PRS_SOMEIP_00702]），因此应设置为0x0000。

- In case of inactive Session Handling the Session ID (see [[SWS_CM_10240](#_bookmark40)]) the Session ID (see [PRS_SOMEIP_00703]) is unused for event messages and thus shall be set to 0x0000 (see [PRS_SOMEIP_00932]) and [PRS_SOMEIP_00925]).

> 在会话处理不活跃的情况下，会话ID（参见[[SWS_CM_10240](#_bookmark40)）会话ID（参见[PRS_SOMEIP_00703]）对于事件消息不使用，因此应设置为0x0000（参见[PRS_SOMEIP_00932]和[PRS_SOMEIP_00925]）。


In case of active Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID is used for event messages and thus shall be incremented (with proper wrap around) upon every transmission of an event message (see [PRS_SOMEIP_00933], [PRS_SOMEIP_00934], [PRS_SOMEIP_00521], and [PRS_SOMEIP_-00925]).

> 在活动会话处理的情况下，参见[[SWS_CM_10240](#_bookmark40)]，会话ID用于事件消息，因此每次发送事件消息时，应该递增（适当地回绕）会话ID（参见[PRS_SOMEIP_00933]、[PRS_SOMEIP_00934]、[PRS_SOMEIP_00521]和[PRS_SOMEIP_-00925]）。


The information whether the Session Handling is activated or deactivated for an event can be derived from the sessionHandling attribute contained in the ApSomeipTransformationProps that is referenced by the TransformationPropsToServiceInterfaceElementMapping that in turn points to the event.

> 可以从指向事件的TransformationPropsToServiceInterfaceElementMapping中引用的ApSomeipTransformationProps中的sessionHandling属性中推断出事件的会话处理是否激活或停用的信息。

- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceVersion.majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to NOTIFICATION

(0x02).


- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for event messages and thus (according to [PRS_SOMEIP_00925]) shall be set to E_OK (0x00).

> 返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对于事件消息没有使用，因此（根据[PRS_SOMEIP_00925]）应设置为E_OK（0x00）。

- The Payload shall contain the serialized payload (i.e., the serialized Field composed by the ServiceInterface in role field) according to the SOME/IP serialization rules.

> 负载应该包含序列化的负载（即，由角色字段中的ServiceInterface组成的序列化字段），按照SOME/IP序列化规则。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_CM_00004)*

> *♩(RS_CM_00204、RS_CM_00200、RS_CM_00201、RS_SOMEIP_00041、RS_SOMEIP_00022、RS_SOMEIP_00003、RS_SOMEIP_00004、RS_SOMEIP_00009、RS_CM_00004)*


If the serializer is defined as signalBased the signal-based event handling applies. As the message containing the signal-based payload is going to be routed to the Classic platform (without the SOME/IP Transformation) the header just contains the Message Id (i.e. ServiceID and Method ID) (see [[SWS_CM_80068](#sws_cm_80068draft-content-of-the-signal-based-serialized-event-message)]).

> 如果序列化器定义为基于信号，则应用信号基于事件处理。由于包含基于信号的有效载荷的消息将被路由到传统平台（而不是SOME/IP转换），因此头部仅包含消息ID（即ServiceID和Method ID）（请参见[[SWS_CM_80068](#sws_cm_80068draft-content-of-the-signal-based-serialized-event-message)））。

### [SWS_CM_80068] {DRAFT} Content of the signal-based serialized event message


*[*If SomeipEventDeployment.serializer is set to signalBased then the entries in the signal-based serialized event message shall be as follows:

> 如果SomeipEventDeployment.serializer被设置为signalBased，那么基于信号的序列化事件消息中的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义eventDeployment.eventId，并将0x8000加到eventDeployment.eventId上。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效负载的长度，单位为字节。

- The Payload shall contain the serialized payload (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) according to the signal-service-translation serialization rules defined in TPSManifestSpecification [6].

> 负载应按照TPSManifestSpecification [6]中定义的signal-service-translation序列化规则，包含序列化的负载（即由角色事件中的ServiceInterface组成的序列化VariableDataPrototype）。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_CM_00004)*

> *♩(RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00041，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00009，RS_CM_00004)*


If the serializer is defined as someip serializer the SOME/IP serialized event handling applies.

> 如果序列化器被定义为SOME/IP序列化器，则应用SOME/IP序列化事件处理。

Based on [[SWS_CM_10324](#_bookmark102)]:


**[SWS_CM_80069]**{DRAFT} **Checks for a received SOME/IP serialized event message** *[*If SomeipEventDeployment.serializer is set to someip then upon reception of a SOME/IP serialized event message the checks defined in [[SWS_CM_80027](#_bookmark174)] shall be conducted.

> 如果SomeipEventDeployment.serializer设置为someip，则在接收到SOME / IP序列化的事件消息时，应执行[[SWS_CM_80027](#_bookmark174)]中定义的检查。


If any of the above checks fails the received SOME/IP serialized event message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00019, RS_-*

> 如果上述任何一个检查失败，则应丢弃收到的SOME/IP序列化事件消息，并且（如果ara :: com实现已启用日志记录）应记录该事件。


*SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00014, RS_CM_00004)*

> *SOMEIP_00022、RS_SOMEIP_00003、RS_SOMEIP_00004、RS_SOMEIP_00009、RS_SOMEIP_00014、RS_CM_00004*


If the serializer is defined as signalBased the signal-based event handling applies. As the message containing the signal-based payload is coming from the Classic platform (without the SOME/IP Transformation) the header just contains the Message Id (i.e. ServiceID and Method ID) (see [[SWS_CM_80070](#sws_cm_80070draft-checks-for-a-received-signal-based-event-message-if)]).

> 如果序列化器被定义为基于信号，则应用基于信号的事件处理。由于包含基于信号的有效载荷的消息来自Classic平台（没有SOME/IP转换），头部只包含消息ID（即ServiceID和Method ID）（参见[[SWS_CM_80070](#sws_cm_80070draft-checks-for-a-received-signal-based-event-message-if)））。

### [SWS_CM_80070] {DRAFT} Checks for a received signal-based event message *[*If


SomeipEventDeployment.serializer is set to signalBased then upon reception of a signal-based event message the checks defined in [[SWS_CM_80028](#_bookmark175)] shall be conducted.

> 如果SomeipEventDeployment.serializer被设置为基于信号，那么在接收到基于信号的事件消息时，将按照[[SWS_CM_80028](#_bookmark175)]中定义的检查进行。


If any of the above checks fails the received signal-based event message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00004)*

> 如果以上任何一项检查失败，则应丢弃接收的基于信号的事件消息，并且应当记录该事件（如果ara::com实现已启用日志记录功能）。♩（RS_CM_00004）


[[SWS_CM_10325](#_bookmark103)] applies. Based on [[SWS_CM_10380](#_bookmark104)]:

> [[SWS_CM_10325](#_bookmark103)]适用。根据[[SWS_CM_10380](#_bookmark104)]：


**[SWS_CM_80072]**{DRAFT} **Silently discarding event messages for unsubscribed events** *[*If the event identified according to [[SWS_CM_10325](#_bookmark103)] does not have an active subscription because the Subscribe method (see [[SWS_CM_00141](#_bookmark559)]) of the specific Field class of the ServiceProxy class has not been called, or the Unsubscribe method (see [[SWS_CM_00151](#_bookmark560)]) of the specific Field class of the ServiceProxy class has been called, or the TTL of the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has expired, then the received event message shall be silently discarded (i.e., [[SWS_CM_80074](#sws_cm_80074draft-deserializing-the-someip-serialized-payload-if)], [[SWS_CM_80101](#_bookmark186)], [[SWS_CM_10327](#_bookmark107)],

> 如果根据[[SWS_CM_10325](#_bookmark103)]确定的事件没有活动的订阅，因为没有调用ServiceProxy类的特定Field类的Subscribe方法（参见[[SWS_CM_00141](#_bookmark559)），或者已经调用了特定Field类的Unsubscribe方法（参见[[SWS_CM_00151](#_bookmark560)），或者SOME / IP SubscribeEventgroup消息的TTL（参见[[SWS_CM_00205](#_bookmark47)）已过期，则收到的事件消息将被静默丢弃（即[[SWS_CM_80074](#sws_cm_80074draft-deserializing-the-someip-serialized-payload-if)], [[SWS_CM_80101](#_bookmark186)], [[SWS_CM_10327](#_bookmark107)],）。


and [[SWS_CM_10328](#_bookmark105)] shall *not* be performed).*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_CM_00004)*

> 而不应执行[[SWS_CM_10328](#_bookmark105)]。♩（RS_CM_00204，RS_CM_00203，RS_SOMEIP_00004，RS_SOMEIP_00009，RS_CM_00004）


[[SWS_CM_10328](#_bookmark105)] applies. Based on [[SWS_CM_10326](#_bookmark106)]:

> [[SWS_CM_10328](#_bookmark105)] 适用。基于[[SWS_CM_10326](#_bookmark106)]：

### [SWS_CM_80074] {DRAFT} Deserializing the SOME/IP serialized payload *[*If


SomeipEventDeployment.serializer is set to someip then based on the event determined according to [[SWS_CM_10325](#_bookmark103)] the Payload of the SOME/IP serialized event message (i.e., the serialized Field composed by the ServiceInterface in role field) shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00028, RS_CM_00004)*

> 如果SomeipEventDeployment.serializer被设置为SOME/IP，那么根据[[SWS_CM_10325](#_bookmark103)]确定的事件，SOME/IP序列化事件消息的有效载荷（即由ServiceInterface在角色字段组成的序列化字段）应按照SOME/IP序列化规则反序列化。*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00028, RS_CM_00004)*


**Note:** [[SWS_CM_80074](#sws_cm_80074draft-deserializing-the-someip-serialized-payload-if)] supports the mix of signal-based and SOME/IP communication use case defined in [[SWS_CM_10174](#_bookmark163)].

> **注意：**[[SWS_CM_80074](#sws_cm_80074draft-deserializing-the-someip-serialized-payload-if)]支持在[[SWS_CM_10174](#_bookmark163)]中定义的基于信号和SOME/IP通信用例的混合使用。

### [SWS_CM_80075] {DRAFT} Deserializing the signal-based payload *[*If


SomeipEventDeployment.serializer is set to signalBased then based on the event determined according to [[SWS_CM_10325](#_bookmark103)] the Payload of the signal-based serialized event message (i.e., the serialized Field composed by the ServiceInterface in role field) shall be deserialized according to the signalservice-translation serialization rules defined in TPS-ManifestSpecification [6].*♩(RS_CM_00004)*

> 如果SomeipEventDeployment.serializer被设置为基于信号，那么根据[[SWS_CM_10325](#_bookmark103)]确定的事件，基于信号的序列化事件消息的有效负载（即，由服务接口在角色字段中组成的序列化字段）应根据TPS-ManifestSpecification [6]中定义的signalservice-translation序列化规则进行反序列化。*♩（RS_CM_00004）*


[[SWS_CM_10327](#_bookmark107)] applies. [[SWS_CM_10329](#_bookmark108)] applies. [[SWS_CM_10443](#_bookmark109)] applies. [[SWS_CM_10330](#_bookmark110)] applies. [[SWS_CM_10331](#_bookmark111)] applies. [[SWS_CM_10332](#_bookmark112)] applies. [[SWS_CM_10333](#_bookmark113)] applies. [[SWS_CM_10334](#_bookmark114)] applies. [[SWS_CM_10335](#_bookmark115)] applies. [[SWS_CM_10336](#_bookmark116)] applies. [[SWS_CM_10338](#_bookmark117)] applies. [[SWS_CM_10339](#_bookmark118)] applies. [[SWS_CM_10340](#_bookmark119)] applies. [[SWS_CM_10341](#_bookmark120)] applies. [[SWS_CM_10342](#_bookmark121)] applies.

> [[SWS_CM_10327](#_bookmark107)] 适用。[[SWS_CM_10329](#_bookmark108)] 适用。[[SWS_CM_10443](#_bookmark109)] 适用。[[SWS_CM_10330](#_bookmark110)] 适用。[[SWS_CM_10331](#_bookmark111)] 适用。[[SWS_CM_10332](#_bookmark112)] 适用。[[SWS_CM_10333](#_bookmark113)] 适用。[[SWS_CM_10334](#_bookmark114)] 适用。[[SWS_CM_10335](#_bookmark115)] 适用。[[SWS_CM_10336](#_bookmark116)] 适用。[[SWS_CM_10338](#_bookmark117)] 适用。[[SWS_CM_10339](#_bookmark118)] 适用。[[SWS_CM_10340](#_bookmark119)] 适用。[[SWS_CM_10341](#_bookmark120)] 适用。[[SWS_CM_10342](#_bookmark121)] 适用。


[[SWS_CM_10343](#_bookmark122)] applies. [[SWS_CM_10344](#_bookmark123)] applies. [[SWS_CM_10345](#_bookmark124)] applies. [[SWS_CM_10346](#_bookmark125)] applies. [[SWS_CM_10347](#_bookmark126)] applies. [[SWS_CM_10348](#_bookmark127)] applies. [[SWS_CM_10444](#_bookmark128)] applies. [[SWS_CM_10349](#_bookmark129)] applies. [[SWS_CM_10350](#_bookmark130)] applies. [[SWS_CM_10363](#_bookmark131)] applies.

> [[SWS_CM_10343](#_bookmark122)] 适用。[[SWS_CM_10344](#_bookmark123)] 适用。[[SWS_CM_10345](#_bookmark124)] 适用。[[SWS_CM_10346](#_bookmark125)] 适用。[[SWS_CM_10347](#_bookmark126)] 适用。[[SWS_CM_10348](#_bookmark127)] 适用。[[SWS_CM_10444](#_bookmark128)] 适用。[[SWS_CM_10349](#_bookmark129)] 适用。[[SWS_CM_10350](#_bookmark130)] 适用。[[SWS_CM_10363](#_bookmark131)] 适用。

### Serialization of Payload


The serialization technology is defined by the attribute SomeipEventDeployment. serializer. If the attribute is set to signalBased then the signal-servicetranslation is responsible for the handling of the serialization. If the attribute is set to someip then the SOME/IP serializer (see section [7.5.1.9](#serialization-of-payload)) is responsible for the handling of the serialization.

> 技术序列化由SomeipEventDeployment属性定义。 如果该属性设置为signalBased，则信号服务翻译负责序列化处理。 如果该属性设置为someip，则SOME / IP序列化程序（参见[7.5.1.9]（＃序列化有效负载））负责序列化处理。


**[SWS_CM_80100]**{DRAFT} **SOME/IP serialization of signal-based network binding** *[*If the attribute SomeipEventDeployment.serializer is set to someip then the serialization of the payload shall be based on the SOME/IP serialization rules.*♩ (RS_CM_00004)*

> **[SWS_CM_80100]**{草案}**SOME/IP序列化的信号网络绑定** *[*如果SomeipEventDeployment.serializer属性设置为someip，则应根据SOME/IP序列化规则序列化有效负载。*♩ (RS_CM_00004)*


Note: SOME/IP serialization rules are defined in section [7.5.1.9](#serialization-of-payload).

> 注意：SOME/IP 序列化规则定义在[7.5.1.9]（#序列化负载）节中。


**[SWS_CM_80101]**{DRAFT} **Signal-based serialization** *[*If the attribute

> **[SWS_CM_80101]**{草案} **基于信号的序列化** *[*如果属性


SomeipEventDeployment.serializer is set to signalBased then the serialization of the payload shall be based on the definition of the ServiceInstanceToSignalMapping defined for the signal-service-translation in TPS-ManifestSpecification [6].*♩(RS_CM_00004)*

> 如果SomeipEventDeployment.serializer设置为signalBased，则应根据TPS-ManifestSpecification [6]中定义的ServiceInstanceToSignalMapping来序列化有效负载（RS_CM_00004）。


**[SWS_CM_80102]**{DRAFT} **Ignoring not mapped elements** *[*To allow migration the deserialization shall ignore signals which are not subject to ServiceInstanceToSignalMapping.*♩(RS_CM_00004, RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_80102]**{草案} **忽略未映射元素** *[*为了允许迁移，反序列化应该忽略不受ServiceInstanceToSignalMapping控制的信号。*♩(RS_CM_00004, RS_CM_00204, RS_CM_00202)*


**[SWS_CM_80103]**{DRAFT} **Deserializing incomplete data belonging to a field** *[*If less data than expected shall be deserialized and the data to be deserialized belong to a Field, the initValue shall be used if it is defined. Otherwise the data shall be completely discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00004, RS_CM_00204, RS_CM_00202)*

> 如果反序列化的数据少于预期并且数据属于一个字段，则如果定义了initValue，则使用initValue。否则，将完全丢弃数据，并记录事件（如果ara :: com实现已启用日志记录）。

### Signal-Based Static Network binding


The [Signal-Based Static](#_bookmark160) network binding is enabled when a ServiceInstanceToSignalMapping refers to a ProvidedUserDefinedServiceInstance or RequiredUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER or SIGNALBASED_NO_HEADER.

> 当ServiceInstanceToSignalMapping引用类别为SIGNALBASED_WITH_HEADER或SIGNALBASED_NO_HEADER的ProvidedUserDefinedServiceInstance或RequiredUserDefinedServiceInstance时，将启用基于信号的静态网络绑定。


Please note that there is currently no static *ara::com* API optimization defined, thus it is expected that the adaptive application, which interacts with a ServiceInterface, uses the same steps as in any other service oriented interaction (i.e. calling OfferService(), FindService(), Subscribe(), \...).

> 请注意，目前没有定义静态ara::com API优化，因此预期与ServiceInterface交互的自适应应用程序使用与其他服务导向交互相同的步骤（即调用OfferService（），FindService（），Subscribe（），\ ...）。

The general approach is:


For a ProvidedUserDefinedServiceInstance the connection is established in a UDP / TCP Server role.

> 为提供的用户定义服务实例，连接建立在UDP/TCP服务器角色中。

For a RequiredUserDefinedServiceInstance the connection is established in a UDP / TCP Client role.

> 对于需要的用户定义服务实例，连接以UDP/TCP客户端角色建立。

### Service Discovery


**[SWS_CM_80501]**{DRAFT} **Mapping of Offer Service ([Signal-Based Static](#_bookmark160) network binding)** *[*When instructed to *offer* a service instance which is mapped to a ProvidedUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER or SIGNALBASED_NO_HEADER, then the [Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding shall create / use a socket for each entry in the remotePeers list. Each connection is defined by the localUdpPortNumber or localTcpPortNumber and one element out of the remotePeers list. If a connection with identical credentials already exists then this existing connection shall be used.

> **[SWS_CM_80501]**{草案} **服务映射（基于信号的静态网络绑定）** *[*当指示提供映射到类别为SIGNALBASED_WITH_HEADER或SIGNALBASED_NO_HEADER的ProvidedUserDefinedServiceInstance的服务实例时，则基于信号的静态网络绑定将为remotePeers列表中的每个条目创建/使用一个套接字。每个连接由localUdpPortNumber或localTcpPortNumber以及remotePeers列表中的一个元素定义。如果已存在具有相同凭据的连接，则应使用该现有连接。


If a localUdpPortNumber is defined then each connection is created using the UDP protocol and bound to the listed remotePeers.

> 如果定义了本地Udp端口号，那么每个连接都使用UDP协议创建并绑定到列出的远程对等点。


If a localTcpPortNumber is defined then each connection is created using the TCP protocol and is listening for client connections.*♩(RS_CM_00004, RS_CM_00204)*

> 如果定义了本地TCP端口号，则每个连接都使用TCP协议创建，并侦听客户端连接。


**[SWS_CM_80512]**{DRAFT} **Mapping of Stop Offer Service ([Signal-Based](#_bookmark160)** [**Static**](#_bookmark160) **network binding)** *[*When instructed to *stop offering* a service instance which is mapped to a ProvidedUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER or SIGNALBASED_NO_HEADER, then the [Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding shall check:

> **[SWS_CM_80512]**{草案} **停止提供服务的映射（[基于信号](#_bookmark160)** [**静态**](#_bookmark160) **网络绑定）** *[*当指示停止提供映射到SIGNALBASED_WITH_HEADER或SIGNALBASED_NO_HEADER类别的服务实例时，[基于信号](#_bookmark160) [静态](#_bookmark160) 网络绑定将检查：


- If this is the last service instance which uses the respective connection then this connection shall be closed.

> 如果这是最后一个使用相应连接的服务实例，那么这个连接将被关闭。

- If there are still other service instance using this connection then the connection shall be kept open.

> 如果仍有其他服务实例使用此连接，则应保持连接打开。

*♩(RS_CM_00004, RS_CM_00204)*


**[SWS_CM_80502]**{DRAFT} **Mapping of Find Service ([Signal-Based Static](#_bookmark160) network binding)** *[*When instructed to *find* a service instance which is mapped to a RequiredUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER or SIGNALBASED_NO_HEADER, then the [Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding shall immediately return a ara::com::ServiceHandleContainer with information about the static connection:

> **[SWS_CM_80502]**{草案} **查找服务（[基于信号的静态](#_bookmark160)网络绑定）的映射** *[*当指示查找类别为SIGNALBASED_WITH_HEADER或SIGNALBASED_NO_HEADER的RequiredUserDefinedServiceInstance映射的服务实例时，[基于信号的](#_bookmark160) [静态](#_bookmark160)网络绑定应立即返回一个ara::com::ServiceHandleContainer，其中包含有关静态连接的信息：

- localUdpPortNumber or localTcpPortNumber

- information about the EthernetCommunicationConnector (VLAN) where the connection shall be applied to

> 关于以太网通信连接器（VLAN），应将连接应用于其中的信息
- a multicastIpAddress where the events will be consumed in case of multicast reception
- remotePeer information of the remote sender of the data (IP-Address and Port number)

*♩(RS_CM_00004, RS_CM_00204)*


**[SWS_CM_80503]**{DRAFT} **Mapping of Subscribe Service ([Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding)** *[*When instructed to *subscribe* to an event which is part of a RequiredUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER or SIGNALBASED_NO_HEADER, then the [Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding shall:

> **[SWS_CM_80503]**{草稿} **订阅服务（[基于信号](#_bookmark160) [静态](#_bookmark160)网络绑定）的映射** *[*当指示订阅类别为SIGNALBASED_WITH_HEADER或SIGNALBASED_NO_HEADER的RequiredUserDefinedServiceInstance的一部分事件时，[基于信号](#_bookmark160) [静态](#_bookmark160)网络绑定应：

If there is not already a socket connection established:


- TCP: use the information from the ara::com::ServiceHandleContainer create the socket and connect to the server.

> 使用ara::com::ServiceHandleContainer中的信息创建套接字并连接到服务器。
- UDP: use the information from the ara::com::ServiceHandleContainer create the socket.


If there is already a socket connection established: use this socket connection.*♩(RS_CM_00004, RS_CM_00204)*

> 如果已经建立了套接字连接：使用此套接字连接♩（RS_CM_00004，RS_CM_00204）。


**[SWS_CM_80513]**{DRAFT} **Mapping of Unsubscribe Service ([Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding)** *[*When instructed to *un-subscribe* from an event which is part of a RequiredUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER or SIGNALBASED_NO_HEADER, then the [Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding shall check:

> **[SWS_CM_80513]**{草案}**映射取消订阅服务（[信号基](＃_bookmark160)[静态](＃_bookmark160)网络绑定）** *[*当收到指令取消订阅属于RequiredUserDefinedServiceInstance类别中的SIGNALBASED_WITH_HEADER或SIGNALBASED_NO_HEADER事件时，[信号基](＃_bookmark160)[静态](＃_bookmark160)网络绑定应检查：


- If this is the last service instance which uses the respective connection then this connection shall be closed.

> 如果这是最后一个使用相应连接的服务实例，那么这个连接将被关闭。

- If there are still other service instance using this connection then the connection shall be kept open.

> 如果仍有其他服务实例使用此连接，则应保持连接打开。

*♩(RS_CM_00004, RS_CM_00204)*

### Accumulation of messages


**[SWS_CM_80505]**{DRAFT} **Data accumulation for UDP data transmission ( [Signal-Based Static](#_bookmark160) network binding)** *[*To allow for the transmission of multiple messages (signal-based events and signal-based field notifiers) within a single UDP datagram, data accumulation for UDP data transmission shall be supported.*♩ (RS_CM_00004, RS_CM_00204)*

> **[SWS_CM_80505]**{草案} **UDP 数据传输的数据积累（[基于信号的静态](#_bookmark160)网络绑定）** *[*为了允许在单个UDP数据报中传输多个消息（基于信号的事件和基于信号的字段通知），应支持UDP数据传输的数据积累。*♩（RS_CM_00004，RS_CM_00204）*


**[SWS_CM_80504]**{DRAFT} **Configuration of a data accumulation on a RequiredUserDefinedServiceInstance for transmission over UDP ([Signal-Based](#_bookmark160) [Static](#_bookmark160) network binding)** *[*For a ProvidedUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER which has a udpCollectionBufferSizeThreshold \> 0 defined, the events and field notifiers where udpCollectionTrigger is set to never shall be aggregated in a buffer until a trigger arrives that starts the data transmission.

> **[SWS_CM_80504]**{草案} **配置需要的用户定义服务实例的数据积累以通过UDP传输（[基于信号的](#_bookmark160) [静态](#_bookmark160)网络绑定）** *[*对于具有 udpCollectionBufferSizeThreshold \> 0定义的类别为 SIGNALBASED_WITH_HEADER 的ProvidedUserDefinedServiceInstance，其中 udpCollectionTrigger 设置为从不的事件和字段通知程序将被聚合到一个缓冲区中，直到触发器到达开始数据传输。

The following trigger options shall be supported:

- a message needs to be transmitted for which the udpCollectionTrigger is set to always.

- the udpCollectionBufferTimeout is reached for one of the messages already aggregated in the buffer.

> 缓冲区中已聚合的消息之一已达到udpCollectionBufferTimeout。
- the buffer size defined by the attribute udpCollectionBufferSizeThreshold is reached.

- adding the event of field notifier to the buffer would lead to a message larger than the maximum possible size (e.g. MTU size). In this case the actual buffer shall be triggered before handling the new event or field notifier.

> 加入字段通知程序的事件到缓冲区会导致消息大于最大可能大小（例如MTU大小）。在这种情况下，在处理新的事件或字段通知程序之前，应该触发实际的缓冲区。

*♩(RS_CM_00004, RS_CM_00204)*

### Execution context of message reception actions


The section [7.5.1.4](#execution-context-of-message-reception-actions) is fully applicable to the [Signal-Based Static](#_bookmark160) network binding.

> 部分[7.5.1.4](#execution-context-of-message-reception-actions)完全适用于基于信号的静态[信号](#_bookmark160)网络绑定。

### Handling Events


**[SWS_CM_80506]**{DRAFT} **Arbitrary Message Header usage for [Signal-](#_bookmark160) [Based Static](#_bookmark160) network binding messages** *[*If a ProvidedUserDefinedServiceInstance or RequiredUserDefinedServiceInstance of category SIGNALBASED_WITH_HEADER is defined then each message shall have an Arbitrary Message Header (see [TPS_Manifest]) defined. This message header is composed of a 32 bit wide Message ID field and 32 bit wide Message Length field. Both encoded in big endian.

> **[SWS_CM_80506]**{草案} **用于[基于信号](#_bookmark160) [静态](#_bookmark160)网络绑定消息的任意消息头使用** *[*如果定义了类别为SIGNALBASED_WITH_HEADER的ProvidedUserDefinedServiceInstance或RequiredUserDefinedServiceInstance，则每个消息都应具有任意消息头（请参见[TPS_Manifest]）。此消息头由32位宽消息ID字段和32位宽消息长度字段组成。均以大端编码。


The the signal based payload is appended (the Message Length field is used to determine how long the payload is in bytes).*♩(RS_CM_00004, RS_CM_00204)*

> 信号基本负载被附加（消息长度字段用于确定负载的字节数）。*♩(RS_CM_00004，RS_CM_00204)*


**[SWS_CM_80507]**{DRAFT} **No header option for** [**Signal-Based Static**](#_bookmark160) **network binding messages** *[*If a ProvidedUserDefinedServiceInstance or RequiredUserDefinedServiceInstance of category SIGNALBASED_NO_HEADER is defined then there is no header information standardized and thus the signal based payload is the only content of the message.*♩(RS_CM_00004, RS_CM_00204)*

> **[SWS_CM_80507]**{草案} 对[信号基础静态]（＃_bookmark160）网络绑定消息没有头选项*[*如果定义了类别SIGNALBASED_NO_HEADER的ProvidedUserDefinedServiceInstance或RequiredUserDefinedServiceInstance，则没有标准化的头信息，因此信号基础有效负载是消息的唯一内容。*♩（RS_CM_00004，RS_CM_00204）*

### Handling Method Calls


**[SWS_CM_80508]**{DRAFT} **No method support for [Signal-Based Static](#_bookmark160) network binding** *[*The [Signal-Based Static](#_bookmark160) network binding does not support methods.*♩(RS_CM_00004, RS_CM_00204)*

> **[SWS_CM_80508]**{草稿} **[Signal-Based Static](#_bookmark160) 网络绑定不支持方法** *[*[Signal-Based Static](#_bookmark160) 网络绑定不支持方法。*♩(RS_CM_00004, RS_CM_00204)*

### Handling Fields


**[SWS_CM_80509]**{DRAFT} **Only field notifier support for [Signal-Based Static](#_bookmark160) network binding** *[*The [Signal-Based Static](#_bookmark160) network binding only supports the field notifier. Getter or Setter methods are not supported.*♩(RS_CM_00004, RS_CM_00204)*

> **[SWS_CM_80509]**{草稿} **仅支持[基于信号的静态](#_bookmark160)网络绑定的字段通知者** *[*[基于信号的静态](#_bookmark160)网络绑定仅支持字段通知者，不支持Getter或Setter方法。*♩(RS_CM_00004, RS_CM_00204)*

### Serialization of Payload


In case of the static signal-service-translation always the signal-service-translation is responsible for the handling of the serialization.

> 在静态信号服务翻译的情况下，信号服务翻译始终负责序列化的处理。


**[SWS_CM_80510]**{DRAFT} **Ignoring not mapped elements** *[*To allow migration the deserialization shall ignore signals which are not subject to ServiceInstanceToSignalMapping.*♩(RS_CM_00004)*

> **[SWS_CM_80510]**{草案} **忽略未映射元素** *[*为了允许迁移，反序列化应该忽略不受ServiceInstanceToSignalMapping控制的信号。*♩(RS_CM_00004)*


**[SWS_CM_80511]**{DRAFT} **Deserializing incomplete data belonging to a field** *[*If less data than expected shall be deserialized and the data to be deserialized belong to a Field, the initValue shall be used if it is defined. Otherwise the data shall be completely discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00004)*

> **[SWS_CM_80511]**{草案} **反序列化属于字段的不完整数据** *[*如果反序列化的数据比预期的少，并且反序列化的数据属于字段，则如果定义了initValue，则使用initValue。否则，完全丢弃该数据，并记录该事件（如果ara :: com实现启用了日志记录）。*♩(RS_CM_00004)*

### DDS Network binding


**[SWS_CM_11000] DDS Compliance** *[*The DDS network binding shall comply with the DDS Minimum Profile defined in [18], the DDS Wire Interoperability protocol (RTPS) defined in [19], and the DDS-XTYPES Minimal Programming Interface and Network Interoperability Profiles defined in [20].*♩(RS_CM_00204)*

> **[SWS_CM_11000] DDS 合规** *[*DDS 网络绑定必须符合 [18] 中定义的 DDS 最小配置，[19] 中定义的 DDS Wire 互操作协议 (RTPS)，以及 [20] 中定义的 DDS-XTYPES 最小编程接口和网络互操作配置。*♩(RS_CM_00204)*


**[SWS_CM_90500]**{DRAFT} **Choice of Service Instance discovery protocol** *[* DdsProvidedServiceInstances and DdsRequiredServiceInstances provide a discoveryType attribute permitting the choice between two distinct discovery protocols. For a Service Interface Skeleton to be discoverable by a Service Interface Proxy, both shall be configured with the same discoveryType value.*♩(RS_CM_00101, RS_CM_00102)*

> **[SWS_CM_90500]**{草稿} **服务实例发现协议的选择** *[* DdsProvidedServiceInstances 和 DdsRequiredServiceInstances 提供一个 discoveryType 属性，允许在两种不同的发现协议之间进行选择。 为了让服务接口骨架可以被服务接口代理发现，它们必须被配置为相同的 discoveryType 值。*♩(RS_CM_00101, RS_CM_00102)*


The DomainParticipantUserDataQos setting provides a discovery protocol that leverages the USER_DATA QoS policy of DDS Domain Participants, assigning a purpose-specific format string to it as described in [7.5.3.1](#service-discovery-via-domain-participant-user_data-qos-policy) below. This approach is fast and nimble, since no additional DDS Entities beyond Domain Participants need to be created to exercise discovery of Service Instances.

> 此DomainParticipantUserDataQos设置提供一种发现协议，它利用DDS域参与者的USER_DATA QoS策略，为其分配特定格式字符串，如下文[7.5.3.1]（#service-discovery-via-domain-participant-user_data-qos-policy）所述。此方法快速灵活，因为不需要创建除域参与者之外的其他DDS实体来实现服务实例的发现。


The Topic setting provides, as described in section [7.5.3.2](#service-discovery-via-topic) below, a discovery protocol that employs a purpose-specific Topic of a well-defined type to distribute Service Instance announcements in a publish-subscribe, instance-based fashion. This protocol, although more resource-demanding (DDS entities down to a single DataWriter need to be created for Skeletons, same for a DataReader in Proxies), enhances interoperability and enables advanced DDS features such as persistence, routing and durability.

> 话题设置提供了一种发现协议，如下文[7.5.3.2]（＃服务发现通过主题）所述，该协议采用特定目的的特定类型的主题来以发布/订阅，基于实例的方式分发服务实例公告。尽管此协议更资源密集（针对骨架需要创建单个数据写入器的DDS实体，代理的数据读取器也是如此），但它增强了互操作性，并使得高级DDS功能，如持久性，路由和耐久性可用。


**[SWS_CM_90501]**{DRAFT} **Topic naming for Domain Participant USER_DATA QoS based Service Instances** *[*When DomainParticipantUserDataQos is set in the discoveryType attribute for a specific DdsProvidedServiceInstance or DdsRequiredServiceInstance, the de-facto Topic naming scheme for events, triggers, methods and fields is the one described for SERVICE_INSTANCE_RESOURCE_PARTITION.*♩(RS_CM_00201, RS_CM_00211, RS_CM_00216)*

> **[SWS_CM_90501]**{草稿} **基于Domain Participant USER_DATA QoS的服务实例主题命名** *[*当在特定的DdsProvidedServiceInstance或DdsRequiredServiceInstance中设置DomainParticipantUserDataQos的discoveryType属性时，事件、触发器、方法和字段的事实上的主题命名方案是SERVICE_INSTANCE_RESOURCE_PARTITION中描述的。♩(RS_CM_00201，RS_CM_00211，RS_CM_00216)*

### Service Discovery via Domain Participant USER_DATA QoS policy


**[SWS_CM_11001] Mapping of OfferService method** *[*When instructed to offer a Service, the DDS Binding shall perform the following operations:

> **[SWS_CM_11001] 服务提供方法的映射**
*当收到指令提供服务时，DDS 绑定应执行以下操作：*

- [[SWS_CM_11002](#_bookmark198)] It shall assign a DDS DomainParticipant to the Service Instance.
- [[SWS_CM_11003](#_bookmark201)] It shall assign a DDS Topic and a DDS DataWriter to every VariableDataPrototype defined in the ServiceInterface in the role event.
- [[SWS_CM_10550](#_bookmark202)] It shall assign a DDS Topic and a DDS DataWriter to every

Trigger defined in the ServiceInterface in the role trigger.

- [[SWS_CM_11029](#sws_cm_11029-assigning-a-dds-request-and-reply-topic-and-datawriters-and-datareaders-to-the-methods-in-the-serviceinterface-the-dds-binding-shall)] It shall assign a DDS Request Topic and a DDS Reply Topic, and create their corresponding DDS DataWriter and DataReader, to provide access to all ClientServerOperations defined in the ServiceInterface the role method.
- [[SWS_CM_11030](#_bookmark204)] It shall assign a DDS Topic and a DDS DataWriter to every Field defined in the ServiceInterface in the role field with its hasNotifier attribute set to true.
- [[SWS_CM_11031](#sws_cm_11031-assigning-a-dds-request-and-reply-topic-and-datawriters-and-datareaders-to-the-field-getterssetters-in-the-serviceinterface-the-dds)] It shall assign a DDS Request Topic and a DDS Reply Topic, and create their corresponding DDS DataWriter and DDS DataReader, to provide access to all the Fields defined in the ServiceInterface in the role field with hasGetter and/or hasSetter attributes set to true via getter/setter invocation.
- [[SWS_CM_09004](#_bookmark206)] It shall add the Service ID, Service Instance IDs, and ServiceInterface contract version to the DDS DomainParticipant's USER_DATA QoS Policy.

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*


**[SWS_CM_11002] Assigning a DDS DomainParticipant to a Service Instance** *[*The DDS Binding shall assign a DDS DomainParticipant to every Service Instance. The configuration of the DomainParticipant is described in the TPS_ManifestSpecification:

> [SWS_CM_11002] 将DDS域参与者分配给服务实例 *[*DDS绑定应为每个服务实例分配一个DDS域参与者。 DomainParticipant的配置描述在TPS_ManifestSpecification中：


- The Domain ID of the DomainParticipant shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the domainId.

> 域参与者的域ID应该从清单中派生，其中DdsProvidedServiceInstance元素定义了域ID。

- The QoS Profile of the DomainParticipant shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the qosProfile.

> 领域参与者的QoS配置文件应从清单中派生，其中DdsProvidedServiceInstance元素定义了qosProfile。


Before creating a new DomainParticipant, the DDS binding shall first look for existing DomainParticipants in the current process that match the configuration criteria specified above[3](#_bookmark199). If the search is successful, the binding shall assign the DomainParticipant found to the Service[4](#_bookmark200); otherwise, the binding shall create a new DomainParticipant according to the desired configuration and assign it to the Service.

> 在创建新的DomainParticipant之前，DDS绑定应首先查找当前进程中与上述配置条件[3](#_bookmark199)匹配的现有DomainParticipant。 如果搜索成功，则绑定应将找到的DomainParticipant分配给服务[4](#_bookmark200)；否则，绑定应根据所需的配置创建新的DomainParticipant，并将其分配给服务。


Once the DomainParticipant is available to the Service Instance, the binding implementation shall create a DDS Publisher and a DDS Subscriber to enclose all DataWriters and DataReaders associated with the Instance. The Partition QoS of both the DDS Publisher and DDS Subscriber shall contain the following partition name:

> 一旦DomainParticipant可用于服务实例，绑定实现将创建一个DDS发布者和一个DDS订阅者来包含与实例相关联的所有DataWriters和DataReaders。DDS发布者和DDS订阅者的分区QoS都将包含以下分区名称：

\"ara.com://services/\<svcId\>_\<svcInId\>\"

Where:


**\<svcId\>** is the Service Id derived from the Manifest, where the DdsServiceInterfaceDeployment element defines the serviceInterfaceId.

> **\<svcId\>** 是从清单中派生出的服务ID，其中DdsServiceInterfaceDeployment元素定义了服务接口ID。


**\<svcInId\>** is the Instance Id derived from the Manifest, where the DdsProvidedServiceInstance element defines the serviceInstanceId.

> **\<svcInId\>**是从Manifest中派生出来的实例ID，其中DdsProvidedServiceInstance元素定义了服务实例ID。


3The DDS APIs that provide the ability to find existing DomainParticipants search in the scope of the address space of the current process---only local DomainParticipants may be reused.

> DDS 提供的API可以查找现有的DomainParticipants，它们只在当前进程的地址空间范围内搜索，只有本地的DomainParticipants可以重复使用。


4The rules specified in this binding ensure the creation of only one DomainParticipant for a given Domain and set of QoS settings (qosProfile).

> 这个约束中指定的规则确保了对于给定的域和QoS设置（qosProfile）只创建一个DomainParticipant。


Publisher and Subscriber objects may be reused across events and other resources provided by the Service Instance; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.

> 发布者和订阅者对象可以在服务实例提供的事件和其他资源之间重复使用；因此，在封闭的DomainParticipant被销毁之前，它们不应该被移除。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*


**[SWS_CM_11003] Assigning a DDS Topic and a DDS DataWriter to every Event in the ServiceInterface** *[*The DDS binding shall assign a DDS Topic to every event in the ServiceInterface according to the mapping rules specified in [[SWS_CM_11015](#_bookmark232)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create a new DDS Topic to represent the event as defined in [[SWS_CM_11015](#_bookmark232)].

> **[SWS_CM_11003] 将DDS主题和DDS DataWriter分配给服务接口中的每个事件** *[*DDS绑定应根据[[SWS_CM_11015](#_bookmark232)]中指定的映射规则为服务接口中的每个事件分配DDS主题。由于这些DDS主题可能已经存在于分配给服务实例的DomainParticipant中（例如，因为分配给同一DomainParticipant的不同服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中查找与所需标准匹配的现有主题。如果搜索不成功，则DomainParticipant应根据[[SWS_CM_11015](#_bookmark232)]创建新的DDS主题来表示该事件。


Once all DDS Topics representing the events in the ServiceInterface are ready for use, the DomainParticipant assigned to the Service Instance shall create one DDS DataWriter of the equivalent Topic per event using the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)]. The DataWriter shall be configured according to the qosProfile specified in the associated DdsEventQosProps.

> 一旦所有表示服务接口中事件的DDS主题准备就绪，分配给服务实例的DomainParticipant应使用在[[SWS_CM_11002](#_bookmark198)中创建的DDS发布者，为每个事件创建一个相应的DDS数据写入器。数据写入器应根据相关联的DdsEventQosProps中指定的qosProfile进行配置。


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以在服务实例之间重复使用，因此，在DomainParticipant被销毁之前，它们不应被移除。


**[SWS_CM_10550]**{DRAFT} **Assigning a DDS Topic and a DDS DataWriter to every Trigger in the ServiceInterface** *[*The DDS binding shall assign a DDS Topic to every trigger in the ServiceInterface according to the mapping rules specified in [[SWS_CM_10524](#_bookmark244)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create a new DDS Topic to represent the trigger as defined in [[SWS_CM_10524](#_bookmark244)].

> **[SWS_CM_10550]**{草案} **将DDS主题和DDS DataWriter分配给服务接口中的每个触发器** *[*DDS绑定应根据[[SWS_CM_10524](#_bookmark244)]中指定的映射规则为服务接口中的每个触发器分配一个DDS主题。由于这些DDS主题可能已经存在于分配给服务实例的DomainParticipant中（例如，因为分配给同一DomainParticipant的另一个服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中查找与所需条件匹配的现有主题。如果搜索不成功，DomainParticipant将根据[[SWS_CM_10524](#_bookmark244)]创建一个新的DDS主题来表示触发器。


Once all DDS Topics representing the triggers in the ServiceInterface are ready for use, the DomainParticipant assigned to the Service Instance shall create one DDS DataWriter of the equivalent Topic per trigger using the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)]. The DataWriter shall be configured according to the qosProfile specified in the associated DdsEventQosProps that in turn refers via DdsEventDeployment to the triggers.

> 一旦所有代表服务接口中触发器的DDS主题准备就绪，分配给服务实例的DomainParticipant应该使用在[[SWS_CM_11002](#_bookmark198)中创建的DDS Publisher为每个触发器创建一个相应的DDS DataWriter。该DataWriter应该根据相关联的DdsEventQosProps中指定的qosProfile以及DdsEventDeployment中指定的触发器进行配置。


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以跨服务实例重复使用，因此，在销毁封装的DomainParticipant之前不应该移除它们。


[SWS_CM_11029] Assigning a DDS Request and Reply Topic, and DataWriters and DataReaders, to the Methods in the ServiceInterface *[*The DDS binding shall instantiate a DDS Service [21] to handle requests to all the methods in the ServiceInterface.

> [SWS_CM_11029] 将DDS请求和应答主题以及数据写入器和数据读取器分配给ServiceInterface中的方法*[*DDS绑定将实例化一个DDS服务[21]来处理对ServiceInterface中所有方法的请求。


In practice, this implies assigning a DDS Request Topic and a DDS Reply Topic to the DDS Service that handles those method calls according to the mapping rules specified in [[SWS_CM_11100](#_bookmark248)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create new DDS Request and Reply Topics to represent the DDS Service as specified in [[SWS_CM_11100](#_bookmark248)].

> 实际上，这意味着根据[[SWS_CM_11100](#_bookmark248)]中指定的映射规则，将DDS请求主题和DDS回复主题分配给处理这些方法调用的DDS服务。由于这些DDS主题可能已经存在于分配给服务实例的DomainParticipant中（例如，因为分配给相同DomainParticipant的不同服务实例可能已经创建了它们），因此服务首先应查找DomainParticipant中与所需条件匹配的现有主题。如果搜索不成功，DomainParticipant应按照[[SWS_CM_11100](#_bookmark248)]中的说明创建新的DDS请求和回复主题来表示DDS服务。


Once the corresponding DDS Request and Reply Topics are ready for use, the DomainParticipant assigned to the Service Instance shall create:

> 一旦相应的DDS请求和回复主题准备就绪，分配给服务实例的DomainParticipant应该创建：

- [[SWS_CM_11106](#_bookmark254)] A DDS DataReader of the DDS Request Topic to handle requests using the DDS Subscriber created in [[SWS_CM_11002](#_bookmark198)].
- [[SWS_CM_11107](#_bookmark255)] A DDS DataWriter of the DDS Reply Topic to handle replies using the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)].


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)* The handling of method calls with DDS is specified in [7.5.3.5](#handling-method-calls-3).

> 主题对象可以在服务实例之间重复使用；因此，在DomainParticipant被销毁之前，它们不应该被移除。处理使用DDS的方法调用的规定可参考[7.5.3.5]（#handling-method-calls-3）。


**[SWS_CM_11030] Assigning a DDS Topic and a DDS DataWriter to every Field in the ServiceInterface with its hasNotifier attribute equal to true** *[*The DDS binding shall assign a DDS Topic to every field in the ServiceInterface with its hasNotifier attribute set to true according to the mapping rules specified in [[SWS_CM_11130](#_bookmark261)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create a new DDS Topic to represent the field as defined in [[SWS_CM_11130](#_bookmark261)].

> [SWS_CM_11030] 将DDS主题和DDS数据写入程序分配给服务接口中具有hasNotifier属性等于true的每个字段*[*根据[[SWS_CM_11130](#_bookmark261)]中指定的映射规则，DDS绑定应将DDS主题分配给具有hasNotifier属性设置为true的服务接口中的每个字段。由于这些DDS主题可能已经在分配给服务实例的DomainParticipant中可用（例如，因为分配给相同DomainParticipant的不同服务实例可能已经创建了它们），服务首先应在DomainParticipant中查找与所需条件匹配的现有主题。如果搜索不成功，DomainParticipant应根据[[SWS_CM_11130](#_bookmark261)]创建一个新的DDS主题来表示该字段。


Once all DDS Topics representing the fields in the ServiceInterface are ready for use, the DomainParticipant assigned to the Service Instance shall create one DDS DataWriter of the equivalent Topic per field with the hasNotifier attribute set to true using the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)]. The DataWriter shall be configured according to the qosProfile specified in the associated DdsFieldQosProps.

> 一旦所有代表服务接口中字段的DDS主题准备就绪，分配给服务实例的DomainParticipant应使用在[[SWS_CM_11002](#_bookmark198)]中创建的DDS发布者，为每个字段创建一个具有hasNotifier属性设置为true的DDS DataWriter。根据相关的DdsFieldQosProps指定的qosProfile配置DataWriter。


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以跨服务实例重复使用；因此，在DomainParticipant被销毁之前，它们不应被移除。


[SWS_CM_11031] Assigning a DDS Request and Reply Topic, and DataWriters and DataReaders, to the Field Getters/Setters in the ServiceInterface *[*The DDS binding shall instantiate a DDS Service [21] to handle get/set requests to all the fields in the ServiceInterface with hasGetter and/or hasSetter set to true.

> [SWS_CM_11031] 将DDS请求和回复主题以及数据写入器和数据读取器分配给服务接口中的字段获取器/设置器*[*DDS绑定应实例化一个DDS服务[21]来处理对具有hasGetter和/或hasSetter设置为true的所有字段的get/set请求。


In practice, this implies assigning a DDS Request Topic and a DDS Reply Topic to the DDS Service according to the mapping rules specified in [[SWS_CM_11144](#_bookmark265)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create new DDS Request and Reply Topics to represent the DDS Service as specified in [[SWS_CM_11144](#_bookmark265)].

> 在实践中，这意味着根据[[SWS_CM_11144](#_bookmark265)]中指定的映射规则，将DDS请求主题和DDS回复主题分配给DDS服务。由于这些DDS主题可能已经在分配给服务实例的DomainParticipant中可用（例如，因为分配给同一DomainParticipant的不同服务实例可能已经创建了它们），因此服务首先应查找DomainParticipant中与所需条件匹配的现有主题。如果搜索不成功，DomainParticipant应按照[[SWS_CM_11144](#_bookmark265)]中的说明创建新的DDS请求和回复主题以表示DDS服务。


Once the corresponding DDS Request and Reply Topics are ready for use, the DomainParticipant assigned to the Service Instance shall create:

> 一旦相应的DDS请求和回复主题准备就绪，分配给服务实例的DomainParticipant应该创建：

- [[SWS_CM_11149](#_bookmark270)] A DDS DataReader of the DDS Request Topic to handle requests using the DDS Subscriber created in [[SWS_CM_11002](#_bookmark198)].
- [[SWS_CM_11150](#_bookmark271)] A DDS DataWriter of the DDS Reply Topic to handle replies using the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)].


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)* The handling of fields with DDS is specified in section [7.5.3.6](#handling-fields-3).

> 主题对象可以在服务实例之间重复使用；因此，除非所包含的DomainParticipant被销毁，否则不应该移除它们。(RS_CM_00204, RS_CM_00200, RS_CM_00101)处理DDS中的字段的方式在[7.5.3.6](#handling-fields-3)节中规定。


**[SWS_CM_09004] Adding Service IDs, Service Instance IDs, and ServiceInterface Contract Versions to the DDS DomainParticipant's USER_DATA QoS Policy** *[*The binding implementation shall configure the USER_DATA QoS Policy of the DDS DomainParticipant associated with the Service Instance to propagate Service IDs, Instance IDs, and ServiceInterface contract versions, using the native DDS discovery mechanisms defined in [19]. The USER_DATA QoS Policy appends a user-defined value to the DomainParticipant's discovery messages. This information shall be used by ara::com Clients and DDS native applications to identify a DomainParticipant as an "ara::com DomainParticipant" that provides one or more Service Instances.

> **[SWS_CM_09004] 将服务 ID、服务实例 ID 和服务接口合同版本添加到 DDS DomainParticipant 的 USER_DATA QoS 策略** *[*绑定实现应配置与服务实例关联的 DDS DomainParticipant 的 USER_DATA QoS 策略，以使用 [19] 中定义的本机 DDS 发现机制传播服务 ID、实例 ID 和服务接口合同版本。USER_DATA QoS 策略将用户定义的值附加到 DomainParticipant 的发现消息中。此信息将被 ara::com 客户端和 DDS 本机应用程序用于识别 DomainParticipant 为提供一个或多个服务实例的 “ara::com DomainParticipant”。


Service IDs, Service Instance IDs, and ServiceInterface contract versions shall be encoded in the USER_DATA QoS Policy in string format according to the following pattern:

> 服务ID、服务实例ID和服务接口合同版本应按照以下模式以字符串格式编码在USER_DATA QoS策略中：


\"ara.com://services/\<svcId\>_\<svcInId\>-\<svcMajVersion\>.\<svcMinVersion\> [&\<svcId\>_\<svcInId\>-\<svcMajVersion\>.\<svcMinVersion\>]\*\"

> "ara.com://服务/\<svcId\>_\<svcInId\>-\<svcMajVersion\>.\<svcMinVersion\> [&\<svcId\>_\<svcInId\>-\<svcMajVersion\>.\<svcMinVersion\>]\*"

Where:


**\<svcId\>** is the Service ID derived from the Manifest, where the DdsServiceInterfaceDeployment element defines the serviceInterfaceId.

> **\<svcId\>** 是从清单中派生出的服务ID，其中DdsServiceInterfaceDeployment元素定义了服务接口ID。


**\<svcInId\>** is the Instance ID derived from the Manifest, where the DdsProvidedServiceInstance element defines the serviceInstanceId.

> **\<svcInId\>** 是从清单中派生出的实例ID，其中DdsProvidedServiceInstance元素定义了服务实例ID。


**\<svcMajVersion\>** is derived from the Manifest, where the majorVersion element of the ServiceInterface defines the contract's major version.

> **\<svcMajVersion\>** 是从清单中派生出来的，其中ServiceInterface的majorVersion元素定义了合同的主版本号。


**\<svcMinVersion\>** is derived from the Manifest, where the minorVersion element of the ServiceInterface defines the contract's minor version.

> **\<svcMinVersion\>**是从清单中派生出来的，其中ServiceInterface的minorVersion元素定义了合同的次版本。


Because a DomainParticipant may be associated with one or more Service Instances, the syntax specified above allows appending one or more \<svcId\>_\<svcInId\>-

> 因为DomainParticipant可以与一个或多个服务实例相关联，上述指定的语法允许追加一个或多个\<svcId\>_\<svcInId\>-。

\<svcMajVersion\>.\<svcMinVersion\> pairs to the USER_DATA QoS:


- If USER_DATA QoS is empty, the binding implementation shall set it to \"ara.com://services/\<svcId\>_\<svcInId\>-\<svcMajVersion\>.-

> 如果USER_DATA QoS为空，绑定实现应将其设置为“ara.com：//services/\<svcId\>_\<svcInId\>-\<svcMajVersion\>。

\<svcMinVersion\>\".


- Else, if USER_DATA QoS is not empty, the binding implementation shall append the Service ID and Instance to the current value preceded by an ampersand symbol (i.e., \"&\<svcId\>_\<svcInId\>-\<svcMajVersion\>.\<svcMinVersion\>\").

> 如果 USER_DATA QoS 不为空，绑定实现应在当前值之前附加服务 ID 和实例，前面加上一个符号（即“& \<svcId\>_\<svcInId\>-\<svcMajVersion\>.\<svcMinVersion\>”）。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101, RS_CM_00500, RS_CM_00501)*


**[SWS_CM_11005] Mapping of StopOfferService method** *[*When instructed to stop offering a Service, the DDS Binding shall perform the following operations:

> **[SWS_CM_11005] 停止提供服务的映射方法** *[*当指示停止提供服务时，DDS绑定应执行以下操作：


- It shall remove the appropriate Service and Instance IDs from the USER_DATA QoS Policy of the DDS DomainParticipant assigned to the Service Instance.

> 它将从分配给服务实例的DDS域参与者的USER_DATA QoS策略中删除适当的服务和实例ID。

- It shall remove all DDS DataWriters associated with events in the ServiceInterface created in previous calls to the OfferService() method.

> 它将删除与先前调用 OfferService() 方法在 ServiceInterface 中创建的事件相关联的所有 DDS DataWriters。

- It shall remove all DDS DataWriters associated with triggers in the ServiceInterface created in previous calls to the OfferService() method.

> 它将删除与先前调用 OfferService() 方法在 ServiceInterface 中创建的触发器相关联的所有 DDS DataWriters。

- It shall remove all DDS DataWriters and DataReaders associated with the ClientServerOperations defined in the role method created in previous calls to the OfferService() method.

> 它将删除与在先前调用OfferService（）方法中定义的ClientServerOperations关联的所有DDS数据写入器和数据读取器。

- It shall remove all DDS DataWriters associated with fields in the ServiceInterface with their hasNotifier attribute set to true created in previous calls to the OfferService() method.

> 它将删除与ServiceInterface中具有hasNotifier属性设置为true的字段相关联的所有DDS DataWriters，这些字段是在以前调用OfferService()方法时创建的。

- It shall remove all DDS DataWriters and DataReaders associated with the fields in the ServiceInterface with hasGetter and/or hasSetter attributes set to true created in previous calls to the OfferService() method.

> 它将删除先前调用 OfferService() 方法创建的具有 hasGetter 和/或 hasSetter 属性设置为 true 的 ServiceInterface 中的字段相关联的所有 DDS 数据写入器和数据读取器。

*♩(RS_CM_00204, RS_CM_00105)*


**[SWS_CM_11006] Mapping of FindService method** *[*When instructed to find remote Services, the DDS Binding shall perform the following operations:

> **[SWS_CM_11006] 查找服务方法的映射** *[*当指示查找远程服务时，DDS绑定应执行以下操作：

- [[SWS_CM_11007](#_bookmark208)] It shall look for an existing DDS DomainParticipant capable of finding remote Services Instances. If such DomainParticipant does not exist, the DDS binding shall create a new one as specified in [[SWS_CM_11008](#_bookmark209)].
- [[SWS_CM_11009](#_bookmark210)] It shall iterate over the list of discovered remote DomainParticipants and look for those associated with Service Instances that: (1) match the filter criteria specified in the FindService() call, (2) have a compatible ServiceInterface contract version, and (3) have a ServiceInterface contract version that is not part of a DdsRequiredServiceInstance.blocklistedVersion.

- It shall return a HandleType object for every Service Instance that: (1) matches the filter criteria, (2) has a compatible ServiceInterface contract version, and \(3\) has a ServiceInterface contract version that is not part of a DdsRequiredServiceInstance.blocklistedVersion. The Handle object shall contain a reference to both the DomainParticipant that was used in the discovery phase and the DDS Publisher and Subscriber created to match the partition of the remote service instance (see [[SWS_CM_11009](#_bookmark210)]), so that they can be used to create the appropriate DataWriters and DataReaders to handle remote communication.

> 它将为满足以下条件的每个服务实例返回一个HandleType对象：（1）符合过滤条件，（2）具有兼容的ServiceInterface合同版本，以及（3）具有不属于DdsRequiredServiceInstance.blocklistedVersion的ServiceInterface合同版本。该句柄对象将包含用于发现阶段的DomainParticipant以及与远程服务实例的分区匹配的DDS发布者和订阅者的引用（请参见[[SWS_CM_11009](＃_bookmark210)]），以便可以使用它们来创建适当的DataWriters和DataReaders来处理远程通信。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_11007] Finding a DDS DomainParticipant suitable for performing client-side operations** *[*The DDS binding shall provide client-side methods with a DDS DomainParticipant capable of discovering and communicating with remote DDS DomainParticipants assigned to the requested Service Instance(s). The configuration of the DomainParticipant is described in the TPS_ManifestSpecification:

> [SWS_CM_11007] 找到一个适合执行客户端操作的DDS域参与者。DDS绑定应提供客户端方法，其中包含一个DDS域参与者，能够发现并与分配给所请求的服务实例的远程DDS域参与者进行通信。DomainParticipant的配置描述在TPS_ManifestSpecification中：


- The Domain ID of the DomainParticipant shall be derived from the Manifest, where the DdsRequiredServiceInstance element defines the domainId.

> 域参与者的域ID应从清单中派生，其中DdsRequiredServiceInstance元素定义了域ID。

- The QoS Profile of the DomainParticipant shall be derived from the Manifest, where the DdsRequiredServiceInstance element defines the qosProfile.

> 领域参与者的QoS配置文件应该从清单中派生，其中DdsRequiredServiceInstance元素定义了qosProfile。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_11008] Creating a DDS DomainParticipant suitable for performing client-side operations** *[*To create a DomainParticipant capable of discovering and communicating with remote DDS DomainParticipants assigned to Service Instances, the binding implementation shall use the configuration parameters in the TPS_ManifestSpecification described in [[SWS_CM_11007](#_bookmark208)].*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*

> 要创建一个能够发现并与分配给服务实例的远程DDS DomainParticipant通信的DomainParticipant，绑定实现应使用[[SWS_CM_11007](#_bookmark208)]中描述的TPS_ManifestSpecification中的配置参数（RS_CM_00204，RS_CM_00200，RS_CM_00102）。


**[SWS_CM_11009] Discovering remote Service Instances through DDS DomainParticipants** *[*DDS DomainParticipants created or retrieved in the context of Service Discovery are responsible for discovering remote DomainParticipants assigned to ara::com Service Instances.

> [SWS_CM_11009] 通过DDS DomainParticipants 发现远程服务实例。在服务发现的上下文中创建或检索的DDS DomainParticipants负责发现分配给ara :: com服务实例的远程DomainParticipants。


To retrieve the list of discovered Service Instances, the DDS binding shall iterate first the list of remote DomainParticipants the DomainParticipant has discovered so far. This shall be done by calling read() on the DomainParticipant's built-in DataReader for the DCPSParticipant Topic. DCPSParticipant is a standard DDS Topic defined in [19] that DomainParticipants use to inform other DomainParticipants of their

> 要检索发现的服务实例列表，DDS绑定应首先迭代域参与者迄今发现的远程域参与者列表。这应该通过调用域参与者的内置数据读取器的read()来实现，该数据读取器用于DCPSParticipant主题。 DCPSParticipant是[19]中定义的标准DDS主题，域参与者用它来通知其他域参与者。


presence in the network. Among other things, DCPSParticipant Topics propagate the DomainParticipant's USER_DATA QoS Policy; therefore, these messages provide all the necessary information to identify remote DomainParticipants associated with ara::com Service Instances.

> 在网络中存在。除其他外，DCPSParticipant主题传播DomainParticipant的USER_DATA QoS策略；因此，这些消息提供了所有必要的信息来识别与ara :: com服务实例相关联的远程DomainParticipants。


The DDS binding shall analyze the content of the USER_DATA QoS of each remote DomainParticipant and check whether they are associated with Service Instances matching the following criteria:

> DDS 绑定应该分析每个远程DomainParticipant的USER_DATA QoS的内容，并检查它们是否与符合以下标准的服务实例相关联：


If requiredServiceInstanceId is set to "ALL", the binding shall return a new handle for each service instance found in remote DomainParticipants' USER_DATA QoS according to the following pattern:

> 如果requiredServiceInstanceId设置为“ALL”，则根据以下模式，绑定将为远程DomainParticipants的USER_DATA QoS中找到的每个服务实例返回一个新的句柄：

\"ara.com://services/.\*\<svcId\>.\*\"


Else, if requiredServiceInstanceId is set to any value other than "ALL", the binding shall return a new handle for every service instance found in remote DomainParticipants' USER_DATA QoS according to the following pattern:

> 如果requiredServiceInstanceId被设置为除“ALL”以外的任何值，绑定将根据以下模式为远程DomainParticipants的USER_DATA QoS中发现的每个服务实例返回一个新的句柄：

\"ara.com://services/.\*\<svcId\>_\<reqSvcInId\>.\*\"

Where:

**\<svcId\>** is the corresponding serviceInterfaceId.

**\<reqSvcInId\>** is the corresponding requiredServiceInstanceId.


In either case, before returning new handles the binding implementation shall evaluate the ServiceInterface contract version for the corresponding Service Instance in the content of the USER_DATA QoS. The binding shall return a new handle only if:

> 无论哪种情况，在返回新句柄之前，绑定实现应评估相应服务实例在USER_DATA QoS内容中的服务接口协议版本。只有在以下情况下，绑定才会返回新句柄：


1. The ServiceInterface contract version of the discovered service instance is compatible with the serviceInterfaceDeployment version of the DdsRequiredServiceInstance according to [RS_CM_00501].

> 服务接口合约版本发现的服务实例与DdsRequiredServiceInstance的服务接口部署版本根据[RS_CM_00501]兼容。

2. The ServiceInterface contract version is not part of any DdsRequiredServiceInstance.blocklistedVersion, according to [RS_CM_00701].

> 根据[RS_CM_00701]，服务接口合同版本不是任何DdsRequiredServiceInstance.blocklistedVersion的一部分。


Before returning new handles, the binding implementation shall ensure that the DomainParticipant used in the discovery phase has one DDS Publisher and one DDS Subscriber per service instance found matching the filter criteria[5](#_bookmark211). The Partition QoS of both DDS Publisher and DDS Subscriber shall contain the following partition name to match the partition in which the DataReaders and DataWriters associated with the remote service instance are operating (in consonance with [[SWS_CM_11002](#_bookmark198)]):

> 在返回新的句柄之前，绑定实现应确保探索阶段使用的DomainParticipant具有与过滤器条件匹配的每个服务实例找到的一个DDS发布者和一个DDS订阅者。DDS发布者和DDS订阅者的分区QoS应包含以下分区名称，以匹配与远程服务实例相关联的数据读取器和数据写入器正在运行的分区（与[[SWS_CM_11002](#_bookmark198)]一致）：

\"ara.com://services/\<svcId\>_\<reqSvcInId\>\"


If the binding implementation does not find a DDS Publisher with the aforementioned requirements, it shall create a new one and configure the Publisher's Partition QoS with

> 如果绑定实现找不到具有上述要求的DDS发布者，它应该创建一个新的发布者，并配置该发布者的分区QoS.


5These Publishers and Subscribers will be used to enclose all the DDS DataWriters and DataReaders, respectively, that will handle communication with the corresponding remote service instance's DDS DataReaders and DataWriters.

> 这些发布者和订阅者将用于封装所有处理与相应远程服务实例的DDS DataReaders和DataWriters之间通信的DDS DataWriters和DataReaders。


the partition name defined above. Likewise, if it does not find a DDS Subscriber with those requirements, it shall create a new one and configure it accordingly.

> 上面定义的分区名称也是如此。如果找不到具有这些要求的DDS订阅者，它将创建一个新的并相应地配置它。


Publisher and Subscriber objects may be reused across proxies associated with a remote service instance; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.

> 发布者和订阅者对象可以在与远程服务实例相关联的代理之间重复使用；因此，它们不应该在封装的DomainParticipant被销毁之前被移除。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_11010] Mapping of StartFindService method** *[*When instructed to start a continuous service search, the DDS Binding shall perform the following operations:

> **[SWS_CM_11010] 启动FindService方法的映射** *[*当指示启动连续服务搜索时，DDS绑定将执行以下操作：

- [[SWS_CM_11007](#_bookmark208)] It shall look for an existing DDS DomainParticipant capable of finding remote Service Instances. If such DomainParticipant does not exist, the DDS binding shall create it as specified in [[SWS_CM_11008](#_bookmark209)].
- [[SWS_CM_11011](#_bookmark212)] It shall define a DDS BuiltinParticipantListener capable of calling the given FindServiceHandler upon the occurrence of any of the following events:


  1. A remote DomainParticipant assigned to a matching Service is discovered.

> 一个分配给匹配服务的远程域参与者被发现了。

  2. A remote DomainParticipant assigned to a matching Service does not contain the service anymore (i.e., any time a remote DomainParticipant stopped offering a matching Service by removing it from its USER_DATA QoS).

> 远程DomainParticipant分配给匹配的服务后不再包含该服务（即，任何时候，远程DomainParticipant通过从其USER_DATA QoS中删除它而停止提供匹配的服务）。

  3. A remote DomainParticipant assigned to a matching Service ceases to exist (i.e., the instance state is either NOT_ALIVE_DISPOSED or NOT_ALIVE_NO_WRITERS).

> 3. 一个分配到匹配服务的远程DomainParticipant不再存在（即实例状态为NOT_ALIVE_DISPOSED或NOT_ALIVE_NO_WRITERS）。
- [[SWS_CM_11012](#_bookmark213)] It shall bind the defined BuiltinParticipantListener to the DomainParticipant.

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_11011] Defining a DDS BuiltinParticipantListener** *[*The DDS Binding implementation shall define a BuiltinParticipantListener class to handle notifications whenever a remote DomainParticipant is discovered. This class shall derive from the standard DataReaderListener class [18], specifying that the data type of the samples to be handled is ParticipantBuiltinTopicData---the data type associated with the built-in DataReader for samples of DCPSParticipant Topic [19].

> [SWS_CM_11011] 定义DDS的BuiltinParticipantListener：DDS绑定实现应定义一个BuiltinParticipantListener类来处理每当发现远程DomainParticipant时的通知。该类应从标准DataReaderListener类[18]派生，指定要处理的样本的数据类型是ParticipantBuiltinTopicData——与DCPSParticipant主题[19]相关的内置数据读取器的样本数据类型。


BuiltinParticipantListener shall implement the following methods according to the specified instructions:

> BuiltinParticipantListener 应根据指定的说明实现以下方法：


- A Constructor that takes as a parameter references to a FindServiceHandler and a requiredServiceInstanceId. These references shall be stored in member variables so that they can be used by subsequent executions of on_data_available()---which is the method the listener calls every time a new DomainParticipant is discovered.

> 构造函数接受一个FindServiceHandler和一个requiredServiceInstanceId的参数。这些引用将被存储在成员变量中，以便在监听器每次发现一个新的DomainParticipant时，可以被on_data_available()方法使用。

- An on_data_available() method that calls FindServiceHandler using the value of the member variable requiredServiceInstanceId. If the returned [ServiceHandleContainer](#_bookmark474) contains more than one element, on_data_available() shall invoke FindServiceHandler and pass the container as a parameter; otherwise the method shall return and perform no further action.

> 一个on_data_available()方法，它使用成员变量requiredServiceInstanceId的值调用FindServiceHandler。如果返回的[ServiceHandleContainer](#_bookmark474)包含多个元素，on_data_available()应调用FindServiceHandler并将容器作为参数传递；否则，该方法将返回并不再执行任何其他操作。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_11012] Binding a BuiltinParticipantListener to a DDS DomainParticipant** *[*To bind a BuiltinParticipantListener to a DDS DomainParticipant, the DDS binding implementation shall create a new BuiltinParticipantListener object (see [[SWS_CM_11011](#_bookmark212)]) passing FindServiceHandler and requiredServiceInstanceId to the listener's constructor. Then service shall then bind the newly created listener to the DomainParticipant using the set_listener() method with StatusMask = DATA_AVAILABLE_STATUS[^6^](#_bookmark215).

> 要将BuiltinParticipantListener绑定到DDS DomainParticipant，DDS绑定实现应该创建一个新的BuiltinParticipantListener对象（参见[[SWS_CM_11011](#_bookmark212)])，将FindServiceHandler和requiredServiceInstanceId传递给监听器的构造函数。然后服务应使用set_listener()方法将新创建的侦听器绑定到DomainParticipant，其中StatusMask = DATA_AVAILABLE_STATUS[^6^](#_bookmark215)。


The BuiltinParticipantListener shall be removed when the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*

> 当封装的DomainParticipant被销毁时，BuiltinParticipantListener应该被移除。(RS_CM_00204, RS_CM_00200, RS_CM_00102)


**[SWS_CM_11013] Mapping of StopFindService method** *[*When instructed to stop a continuous service search initiated by a previous call to StartFindService(), the DDS Binding shall perform the following operations:

> **[SWS_CM_11013] 停止查找服务方法的映射** *[*当收到指令停止由先前调用StartFindService()发起的连续服务搜索时，DDS 绑定应执行以下操作：

- [[SWS_CM_11007](#_bookmark208)] It shall look for an existing DDS DomainParticipant capable of finding remote Service Instances. If such DomainParticipant does not exist, StopFindService() shall return and perform no further action.
- [[SWS_CM_11014](#_bookmark214)] It shall unbind the BuiltinParticipantListener from the retrieved DDS DomainParticipant[7](#_bookmark216).

*♩(RS_CM_00204, RS_CM_00200)*


**[SWS_CM_11014] Unbinding a BuiltinParticipantListener from a DDS DomainParticipant** *[*When instructed to unbind a BuiltinParticipantListener from a DDS DomainParticipant, the DDS binding implementation service shall invoke the DomainParticipant's set_listener() method to disable the listener. In that case, set_listener() shall be called with StatusMask = STATUS_MASK_NONE.*♩(RS_CM_00204, RS_CM_00200)*

> 当指示从DDS DomainParticipant解除绑定BuiltinParticipantListener时，DDS绑定实现服务应调用DomainParticipant的set_listener()方法来禁用侦听器。在这种情况下，应使用StatusMask = STATUS_MASK_NONE调用set_listener()。


6Note that the syntax of set_listener() and StatusMask is described in terms of the DDS Platform-Independent Model specified in [18]. Different Platform-Specific Mappings, such as the DDSCPP-PSM specified in [22], map these concepts into more language-friendly constructs.

> 注意，set_listener（）和StatusMask的语法是根据[18]中指定的DDS平台独立模型描述的。不同的平台特定映射，如[22]中指定的DDSCPP-PSM，将这些概念映射到更加语言友好的构造中。


7Note that with the behavior specified for FindService() and StartFindService()---the only methods capable of creating DomainParticipants---guarantees that the DomainParticipant used by subsequent calls to StartFindService() and StopFindService() will be the same.

> 注意，由于FindService（）和StartFindService（）指定的行为---唯一能够创建DomainParticipant的方法---可以保证后续调用StartFindService（）和StopFindService（）时使用的DomainParticipant是相同的。

### Service Discovery via Topic


**[SWS_CM_90502]**{DRAFT} **Mapping of OfferService method** *[*When instructed to offer a Service, the DDS Binding shall perform the following operations:

> **[SWS_CM_90502]**{草案} **提供服务方法的映射** *[*当指示提供服务时，DDS 绑定应执行以下操作：

- [[SWS_CM_90503](#_bookmark218)] It shall assign a DDS DomainParticipant to the Service Instance.
- [[SWS_CM_90504](#_bookmark220)] It shall assign a DDS Topic and a DDS DataWriter to every VariableDataPrototype defined in the ServiceInterface in the role event.
- [[SWS_CM_90505](#_bookmark221)] It shall assign a DDS Request Topic and a DDS Reply Topic, and create their corresponding DDS DataWriter and DataReader, to provide access to all ClientServerOperations defined in the ServiceInterface the role method.
- [[SWS_CM_90506](#_bookmark223)] It shall assign a DDS Topic and a DDS DataWriter to every Field defined in the ServiceInterface in the role field with its hasNotifier attribute set to true.
- [[SWS_CM_90507](#_bookmark224)] It shall assign a DDS Request Topic and a DDS Reply Topic, and create their corresponding DDS DataWriter and DDS DataReader, to provide access to all the Fields defined in the ServiceInterface in the role field with hasGetter and/or hasSetter attributes set to true via getter/setter invocation.
- [[SWS_CM_90508](#_bookmark225)] It shall advertise the Service Interface ID, Service Instance ID, and ServiceInterface contract version via the ara.com://services/discovery DDS topic

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*


**[SWS_CM_90503]**{DRAFT} **Assigning a DDS DomainParticipant to a Service Instance** *[*The DDS Binding shall assign a DDS DomainParticipant to every Service Instance. The configuration of the DomainParticipant is described in the TPS_ManifestSpecification:

> **[SWS_CM_90503]**{草案} **将DDS域参与者分配给服务实例** *[*DDS绑定应为每个服务实例分配一个DDS域参与者。 DomainParticipant的配置描述在TPS_ManifestSpecification中：


- The Domain ID of the DomainParticipant shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the domainId.

> 域参与者的域ID应从清单中派生，其中DdsProvidedServiceInstance元素定义了域ID。

- The QoS Profile of the DomainParticipant shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the qosProfile.

> 领域参与者的QoS配置文件应从清单中派生，其中DdsProvidedServiceInstance元素定义了qosProfile。


Before creating a new DomainParticipant, the DDS binding shall first look for existing DomainParticipants in the current process that match the configuration criteria specified above[8](#_bookmark219). If the search is successful, the binding shall assign the DomainParticipant found to the Service[9](#_bookmark222); otherwise, the binding shall create a new DomainParticipant according to the desired configuration and assign it to the Service.

> 在创建新的DomainParticipant之前，DDS绑定应首先查找当前进程中与上述配置条件匹配的现有DomainParticipant[8] (#_bookmark219)。 如果搜索成功，绑定应将找到的DomainParticipant分配给服务[9] (#_bookmark222); 否则，绑定应根据所需的配置创建新的DomainParticipant并将其分配给服务。


8The DDS APIs that provide the ability to find existing DomainParticipants search in the scope of the address space of the current process---only local DomainParticipants may be reused.

> DDS API提供了查找现有DomainParticipants的能力，只在当前进程的地址空间范围内搜索——只有本地DomainParticipants才能被重用。


Once the DomainParticipant is available to the Service Instance, the binding implementation shall create a DDS Publisher and a DDS Subscriber to enclose all DataWriters and DataReaders associated with the Service Instance.

> 一旦DomainParticipant可以被服务实例使用，绑定实现将创建一个DDS发布者和一个DDS订阅者来封装所有与服务实例相关联的数据写入器和数据读取器。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*


**[SWS_CM_90504]**{DRAFT} **Assigning a DDS Topic and a DDS DataWriter to every Event in the ServiceInterface** *[*The DDS binding shall assign a DDS Topic to every event in the ServiceInterface according to the mapping rules specified in [[SWS_CM_11015](#_bookmark232)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create a new DDS Topic to represent the event as defined in [[SWS_CM_11015](#_bookmark232)].

> **[SWS_CM_90504]**{草案} **将DDS主题和DDS数据写入程序分配给服务接口中的每个事件** *[*DDS绑定应根据[[SWS_CM_11015](#_bookmark232)]中指定的映射规则将DDS主题分配给服务接口中的每个事件。由于这些DDS主题可能已经存在于分配给服务实例的DomainParticipant中（例如，因为分配给相同DomainParticipant的另一个服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中搜索匹配所需条件的现有主题。如果搜索不成功，DomainParticipant应根据[[SWS_CM_11015](#_bookmark232)]创建新的DDS主题来表示该事件。


Once all DDS Topics representing the events in the ServiceInterface are ready for use, the DomainParticipant assigned to the Service Instance shall create one DDS DataWriter of the equivalent Topic per event using the DDS Publisher created in [[SWS_CM_90503](#_bookmark218)]. The DataWriter shall be configured according to the qosProfile specified in the associated DdsEventQosProps.

> 一旦所有代表服务接口中事件的DDS主题准备就绪，分配给服务实例的DomainParticipant应使用在[[SWS_CM_90503](#_bookmark218)]中创建的DDS发布者为每个事件创建一个等效主题的DDS数据写入器。 数据写入器应按照相关的DdsEventQosProps中指定的qosProfile进行配置。


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以在服务实例之间重复使用；因此，在DomainParticipant被销毁之前，它们不应该被移除。


**[SWS_CM_90505]**{DRAFT} **Assigning a DDS Request and Reply Topic, and DataWriters and DataReaders, to the Methods in the ServiceInterface** *[*The DDS binding shall instantiate a DDS Service [21] to handle requests to all the methods in the ServiceInterface.

> **[SWS_CM_90505]**{草稿}**将DDS请求和回复主题，以及DataWriters和DataReaders分配给ServiceInterface中的方法** *[*DDS绑定应实例化DDS服务[21]以处理对ServiceInterface中所有方法的请求。


In practice, this implies assigning a DDS Request Topic and a DDS Reply Topic to the DDS Service that handles those method calls according to the mapping rules specified in [[SWS_CM_11100](#_bookmark248)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create new DDS Request and Reply Topics to represent the DDS Service as specified in [[SWS_CM_11100](#_bookmark248)].

> 在实践中，这意味着根据[[SWS_CM_11100](#_bookmark248)]中指定的映射规则，将DDS请求主题和DDS回复主题分配给处理这些方法调用的DDS服务。由于这些DDS主题可能已经在分配给服务实例的DomainParticipant中可用（例如，因为分配给相同DomainParticipant的不同服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中搜索符合所需条件的现有主题。如果搜索不成功，DomainParticipant应按照[[SWS_CM_11100](#_bookmark248)]中的说明创建新的DDS请求和回复主题来表示DDS服务。


Once the corresponding DDS Request and Reply Topics are ready for use, the DomainParticipant assigned to the Service Instance shall create:

> 一旦相应的DDS请求和回复主题准备就绪，分配给服务实例的DomainParticipant应该创建：

- [[SWS_CM_11106](#_bookmark254)] A DDS DataReader of the DDS Request Topic to handle requests using the DDS Subscriber created in [[SWS_CM_90503](#_bookmark218)].


9The rules specified in this binding ensure the creation of only one DomainParticipant for a given Domain and set of QoS settings (qosProfile).

> 规定在此约束中的规则确保只为给定域和QoS设置（qosProfile）创建一个DomainParticipant。

- [[SWS_CM_11107](#_bookmark255)] A DDS DataWriter of the DDS Reply Topic to handle replies using the DDS Publisher created in [[SWS_CM_90503](#_bookmark218)].


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以在服务实例之间重复使用，因此，除非包含的DomainParticipant被销毁，否则不应该删除它们。


The handling of method calls with DDS is specified in [7.5.3.5](#handling-method-calls-3).

> 处理使用DDS的方法调用规定在[7.5.3.5](#handling-method-calls-3)中。


**[SWS_CM_90506]**{DRAFT} **Assigning a DDS Topic and a DDS DataWriter to every Field in the ServiceInterface with its hasNotifier attribute equal to true** *[*The DDS binding shall assign a DDS Topic to every field in the ServiceInterface with its hasNotifier attribute set to true according to the mapping rules specified in [[SWS_CM_11130](#_bookmark261)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create a new DDS Topic to represent the field as defined in [[SWS_CM_11130](#_bookmark261)].

> **[SWS_CM_90506]**{草案}**将有hasNotifier属性等于true的服务接口的每个字段分配一个DDS主题和一个DDS DataWriter** *[*根据[[SWS_CM_11130](#_bookmark261)]中指定的映射规则，DDS绑定应将具有hasNotifier属性设置为true的服务接口中的每个字段分配一个DDS主题。由于这些DDS主题可能已经存在于分配给服务实例的DomainParticipant中（例如，因为分配给相同DomainParticipant的另一个服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中查找与所需条件匹配的现有主题。如果搜索不成功，则DomainParticipant应根据[[SWS_CM_11130](#_bookmark261)]创建一个新的DDS主题来表示该字段。

简体中文：**[SWS_CM_90506]**{草案}**将具有hasNotifier属性等于true的服务接口的每个字段分配一个DDS主题和一个DDS DataWriter** *[*根据[[SWS_CM_11130](#_bookmark261)]中指定的映射规则，DDS绑定应将具有hasNotifier属性设置为true的服务接口中的每个字段分配一个DDS主题。由于这些DDS主题可能已经存在于分配给服务实例的DomainParticipant中（例如，因为分配给相同DomainParticipant的另一个服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中查找与所需条件匹配的现有主题。如果搜索不成功，则DomainParticipant应根据[[SWS_CM_11130](#_bookmark261)]创建一个新的DDS主题来表示该字段。


Once all DDS Topics representing the fields in the ServiceInterface are ready for use, the DomainParticipant assigned to the Service Instance shall create one DDS DataWriter of the equivalent Topic per field with the hasNotifier attribute set to true using the DDS Publisher created in [[SWS_CM_90503](#_bookmark218)]. The DataWriter shall be configured according to the qosProfile specified in the associated DdsFieldQosProps.

> 一旦所有代表服务接口中字段的DDS主题准备就绪，分配给服务实例的DomainParticipant应使用[[SWS_CM_90503](#_bookmark218)]中创建的DDS发布者，为每个字段创建一个具有hasNotifier属性设置为true的DDS DataWriter。根据关联的DdsFieldQosProps中指定的qosProfile配置DataWriter。


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以跨服务实例重复使用；因此，在销毁封装的DomainParticipant之前，它们不应该被移除。


**[SWS_CM_90507]**{DRAFT} **Assigning a DDS Request and Reply Topic, and DataWriters and DataReaders, to the Field Getters/Setters in the ServiceInterface** *[*The DDS binding shall instantiate a DDS Service [21] to handle get/set requests to all the fields in the ServiceInterface with hasGetter and/or hasSetter set to true.

> **[SWS_CM_90507]**{草案}**将DDS请求和回复主题以及DataWriters和DataReaders分配给ServiceInterface中的字段Getters/Setters** *[*DDS绑定将实例化一个DDS服务[21]，以处理对具有hasGetter和/或hasSetter设置为true的ServiceInterface中的所有字段的get/set请求。


In practice, this implies assigning a DDS Request Topic and a DDS Reply Topic to the DDS Service according to the mapping rules specified in [[SWS_CM_11144](#_bookmark265)]. Since these DDS Topics may already be available in the DomainParticipant assigned to the Service Instance (e.g., because a different Service Instance assigned to the same DomainParticipant may have created them), the service shall first look for existing Topics in the DomainParticipant matching the required criteria. If the search is unsuccessful, the DomainParticipant shall create new DDS Request and Reply Topics to represent the DDS Service as specified in [[SWS_CM_11144](#_bookmark265)].

> 在实践中，这意味着根据[[SWS_CM_11144](#_bookmark265)]中指定的映射规则，将DDS请求主题和DDS回复主题分配给DDS服务。由于这些DDS主题可能已经在分配给服务实例的DomainParticipant中可用（例如，因为分配给相同DomainParticipant的不同服务实例可能已经创建了它们），因此服务首先应在DomainParticipant中查找符合所需条件的现有主题。如果搜索不成功，DomainParticipant应按照[[SWS_CM_11144](#_bookmark265)]中的说明创建新的DDS请求和回复主题来表示DDS服务。


Once the corresponding DDS Request and Reply Topics are ready for use, the DomainParticipant assigned to the Service Instance shall create:

> 一旦相应的DDS请求和回复主题准备就绪，分配给服务实例的DomainParticipant应该创建：

- [[SWS_CM_11149](#_bookmark270)] A DDS DataReader of the DDS Request Topic to handle requests using the DDS Subscriber created in [[SWS_CM_90503](#_bookmark218)].
- [[SWS_CM_11150](#_bookmark271)] A DDS DataWriter of the DDS Reply Topic to handle replies using the DDS Publisher created in [[SWS_CM_90503](#_bookmark218)].


Topic objects may be reused across service instances; therefore, they shall not be removed until the enclosing DomainParticipant is destroyed.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101)*

> 主题对象可以跨服务实例重用；因此，在包含的DomainParticipant被销毁之前，它们不应被移除。


The handling of fields with DDS is specified in section [7.5.3.6](#handling-fields-3).

> 处理带有DDS的字段在第7.5.3.6节中有规定。


**[SWS_CM_90508]**{DRAFT} **Advertising Service IDs, Service Instance IDs, and ServiceInterface Contract Versions over the ara.com://services/discovery topic** *[*The binding implementation shall configure DDS Topic, Publisher and DataWriter objects supporting the publication of announcement messages over the ara.com://services/discovery topic, whose type is ServiceAnnouncementMessage and is defined as follows[10](#_bookmark226):

> **[SWS_CM_90508]**{草案} **在ara.com://services/discovery主题上的广告服务ID、服务实例ID和服务接口合同版本** *[*绑定实现应配置DDS主题、发布者和数据写入器对象，支持在ara.com://services/discovery主题上发布公告消息，其类型为ServiceAnnouncementMessage，定义如下[10](#_bookmark226)：

```
1 module dds {

2 module ara {

3 module com {

4

5 enum ServiceInstanceResourceIdentifierType {

6 SERVICE_INSTANCE_RESOURCE_PARTITION,

7 SERVICE_INSTANCE_RESOURCE_TOPIC_PREFIX,

8 SERVICE_INSTANCE_RESOURCE_INSTANCE_ID

9 };

10

11 struct ServiceVersion {

12 uint32 major_version;

13 uint32 minor_version;

14 };

15

16 struct ServiceAnnouncementMessage {

17 \@key string\<256\> interface_id;

18 \@key uint16 instance_id;

19 ServiceVersion version;

20 ServiceInstanceResourceIdentifierType identifier_type;

21 };

22

23 }; // module com

24 }; // module ara

25 }; // module dds
```

Where:


10DDS types are often defined in OMG IDL [23], which provides a standard language-independent format to represent data types and interfaces. Even though we use IDL throughout the specification to define data types, the use of IDL to is not mandated (i.e., a compliant implementation could choose to hand-craft these types, run code generation from an equivalent XML syntax, or run vendor-specific mechanisms to generate the actual data types).

> 10DDS 类型经常在 OMG IDL [23] 中定义，它提供了一种标准的语言无关的格式来表示数据类型和接口。尽管我们在整个规范中使用IDL来定义数据类型，但不强制使用IDL（即，符合要求的实现可以选择手工制作这些类型，从等效的XML语法生成代码，或者运行供应商特定的机制来生成实际的数据类型）。


**interface_id** is the Service Instance ID derived from the Manifest, where the DdsServiceInterfaceDeployment defines the serviceInterfaceId.

> **接口ID**是从Manifest中派生出来的服务实例ID，其中DdsServiceInterfaceDeployment定义了服务接口ID。

The value of this field contributes to the topic instance key


**instance_id** is the Service Instance ID derived from the Manifest, where the DdsProvidedServiceInstance element defines the serviceInterfaceId. The value of this field contributes to the topic instance key

> **实例ID** 来自清单中的Service Instance ID，其中DdsProvidedServiceInstance元素定义了serviceInterfaceId。此字段的值有助于主题实例键。


**version** is derived from the Manifest, where the majorVersion element of the ServiceInterface defines the contract major version, and the minorVersion element of the ServiceInterface defines the contract minor version

> 版本来源于清单，其中ServiceInterface的majorVersion元素定义了合同的主要版本，而ServiceInterface的minorVersion元素定义了合同的次要版本。


**identifier_type** defines the protocol used by consumers of the Service Instance to bind themselves with it. This choice will determine topic naming, usage of partitions and the relevance of in-band instance identifers in the following requirements: [[SWS_CM_11015](#_bookmark232)], [[SWS_CM_11100](#_bookmark248)], [[SWS_CM_11130](#_bookmark261)], [[SWS_CM_11144](#_bookmark265)] and [[SWS_CM_10524](#_bookmark244)].

> **标识符类型**定义服务实例的消费者使用的协议，以绑定它们自己。此选择将确定主题命名，分区使用以及以下要求中的带内实例标识符的相关性：[[SWS_CM_11015](#_bookmark232)], [[SWS_CM_11100](#_bookmark248)], [[SWS_CM_11130](#_bookmark261)], [[SWS_CM_11144](#_bookmark265)] 和 [[SWS_CM_10524](#_bookmark244)]。


In order to guarantee reception of ServiceAnnouncementMessage samples by all Service Interface consumers, including those joining after the Service Instance has been advertised, the following DataWriter QoS policies shall be set for the ara.com:-

> 为了确保所有服务接口消费者（包括在服务实例被广告后加入的消费者）能够接收ServiceAnnouncementMessage样本，以下DataWriter QoS策略必须为ara.com设置：

//services/discovery topic:

- RELIABILITY set to RELIABLE
- HISTORY set to KEEP_LAST with DEPTH set to 1
- DURABILITY set to TRANSIENT_LOCAL


Once the ara.com://services/discovery topic DataWriter is properly set up and ready to use, the offering Service Instance shall:

> 一旦ara.com://services/discovery主题DataWriter设置完毕并准备就绪，提供的服务实例应当：


1. Instantiate a ServiceAnnouncementMessage sample, update it with the proper values uniquely identifying the Service Instance, and use it to register via register_instance() a unique instance (keyed by interface_id and instance_id)

> 1. 实例化一个ServiceAnnouncementMessage示例，使用适当的值更新它，以唯一标识服务实例，并使用它通过register_instance（）注册唯一实例（以interface_id和instance_id键入）。

2. Use the Instance Handle returned by the previous step to publish the sample via write()

> 使用前一步返回的实例句柄通过write（）发布样本。

3. Keep a copy the sample and the Instance Handle for use upon Service Instance tear down (see [[SWS_CM_11005](#_bookmark207)])

> 请在服务实例拆除时保留样本及实例句柄的副本（参见[[SWS_CM_11005](#_bookmark207)])

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101, RS_CM_00500, RS_CM_00501)*


**[SWS_CM_90509]**{DRAFT} **Mapping of StopOfferService method** *[*When instructed to stop offering a Service, the DDS Binding shall perform the following operations:

> **[SWS_CM_90509]**{草案} **停止提供服务方法的映射** *[*当指示停止提供服务时，DDS 绑定应执行以下操作：


- Call dispose() using the sample and the Instance Handle kept during Service Instance announcement (see [[SWS_CM_90508](#_bookmark225)])

> 调用dispose()时，使用服务实例公告期间保留的示例和实例句柄（参见[[SWS_CM_90508](#_bookmark225)])。

- It shall remove all DDS DataWriters associated with events in the ServiceInterface created in previous calls to the OfferService() method.

> 它将删除与先前调用 OfferService() 方法创建的 ServiceInterface 中的事件相关联的所有 DDS DataWriters。

- It shall remove all DDS DataWriters and DataReaders associated with the ClientServerOperations defined in the role method created in previous calls to the OfferService() method.

> 它将删除与以前调用OfferService()方法中定义的ClientServerOperations相关联的所有DDS数据写入器和数据读取器。

- It shall remove all DDS DataWriters associated with fields in the ServiceInterface with their hasNotifier attribute set to true created in previous calls to the OfferService() method.

> 它将删除前面调用OfferService()方法时与具有hasNotifier属性设置为true的ServiceInterface字段相关联的所有DDS数据写入器。

- It shall remove all DDS DataWriters and DataReaders associated with the fields in the ServiceInterface with hasGetter and/or hasSetter attributes set to true created in previous calls to the OfferService() method.

> 它将删除与具有hasGetter和/或hasSetter属性设置为true的在先前调用OfferService()方法中创建的ServiceInterface字段相关联的所有DDS数据写入器和数据读取器。

*♩(RS_CM_00204, RS_CM_00105)*


**[SWS_CM_90510]**{DRAFT} **Mapping of FindService method** *[*When instructed to find remote Services, the DDS Binding shall perform the following operations:

> **[SWS_CM_90510]**{草稿} **查找服务方法的映射** *[*当被指示去查找远程服务时，DDS 绑定应该执行以下操作：

- [[SWS_CM_90511](#_bookmark228)] It shall look for an existing DDS DomainParticipant capable of finding remote Services Instances. If such DomainParticipant does not exist, the DDS binding shall create a new one as specified in [[SWS_CM_90512](#_bookmark229)].
- [[SWS_CM_90513](#_bookmark230)] It shall create a DataReader matching the Topic and QoS policies defined by [[SWS_CM_90508](#_bookmark225)], looking into all samples received for those associated with Service Instances that: (1) match the filter criteria specified in the FindService() call, (2) have a compatible ServiceInterface contract version, and (3) have a ServiceInterface contract version that is not part of a DdsRequiredServiceInstance.blocklistedVersion.

- It shall return a HandleType object for every Service Instance that: (1) matches the filter criteria, (2) has a compatible ServiceInterface contract version, and \(3\) has a ServiceInterface contract version that is not part of a DdsRequiredServiceInstance.blocklistedVersion.

> 它将为满足以下条件的每个服务实例返回一个HandleType对象：(1) 符合过滤条件，(2) 具有兼容的ServiceInterface合同版本，以及(3) 具有不属于DdsRequiredServiceInstance.blocklistedVersion的ServiceInterface合同版本。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_90511]**{DRAFT} **Finding a DDS DomainParticipant suitable for performing client-side operations** *[*The DDS binding shall provide client-side methods with a DDS DomainParticipant capable of discovering and communicating with remote DDS DomainParticipants assigned to the requested Service Instance(s). The configuration of the DomainParticipant is described in the TPS_ManifestSpecification:

> **[SWS_CM_90511]**{草案} **寻找适合执行客户端操作的DDS域参与者** *[*DDS绑定应提供具有能够发现并与请求的服务实例分配的远程DDS域参与者通信的客户端方法。 DomainParticipant的配置描述在TPS_ManifestSpecification中：


- The Domain ID of the DomainParticipant shall be derived from the Manifest, where the DdsRequiredServiceInstance element defines the domainId.

> 域参与者的域ID应从清单中派生，其中DdsRequiredServiceInstance元素定义了域ID。

- The QoS Profile of the DomainParticipant shall be derived from the Manifest, where the DdsRequiredServiceInstance element defines the qosProfile.

> 该域参与者的QoS配置文件应从清单中派生，其中DdsRequiredServiceInstance元素定义了qosProfile。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_90512]**{DRAFT} **Creating a DDS DomainParticipant suitable for performing client-side operations** *[*To create a DomainParticipant capable of discovering and communicating with remote DDS DomainParticipants assigned to Service Instances, the binding implementation shall use the configuration parameters in the TPS_ManifestSpecification described in [[SWS_CM_90511](#_bookmark228)].*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*

> 创建一个能够发现并与分配给服务实例的远程DDS域参与者通信的域参与者，绑定实现应该使用TPS_ManifestSpecification中描述的配置参数（RS_CM_00204，RS_CM_00200，RS_CM_00102）。


**[SWS_CM_90513]**{DRAFT} **Discovering remote Service Instances through the ara.com://services/discovery topic** *[*DDS DomainParticipants created or retrieved in the context of Service Discoverty are responsible for discovering remote DomainParticipants assigned to ara::com Service Instances.

> [SWS_CM_90513]{草案} 通过ara.com://services/discovery主题发现远程服务实例 *[*在服务发现的上下文中创建或检索的DDS域参与者负责发现分配给ara::com服务实例的远程域参与者。


To retrieve a list of discovered Service Instances, the DDS binding shall process inbound ServiceAnnouncementMessage samples from the ara.com://services/discovery topic. This shall be done by calling read() on the DataReader object defined by [[SWS_CM_90510](#_bookmark227)].

> 为了检索已发现的服务实例，DDS 绑定应处理从 ara.com：//services/discovery 主题传入的 ServiceAnnouncementMessage 样本。这应该通过调用 [[SWS_CM_90510](#_bookmark227)] 定义的 DataReader 对象上的 read() 来完成。


If requiredServiceInstanceId is set to ALL, the binding shall return a new handle for each service instance declared by inbound ServiceAnnouncementMessage, as long as its interface_id field matches the corresponding serviceInterfaceId.

> 如果requiredServiceInstanceId被设置为ALL，那么绑定将为来自inbound ServiceAnnouncementMessage声明的每个服务实例返回一个新的句柄，只要其interface_id字段与相应的serviceInterfaceId匹配即可。


Else, if requiredServiceInstanceId is set to any value other than ALL, the binding should return a new handle for each service instance declared by inbound ServiceAnnouncementMessage, as long as its interface_id field matches the serviceInterfaceId and its instance_id field matches requiredServiceInstanceId.

> 如果requiredServiceInstanceId被设置为除ALL以外的任何值，那么绑定应该为由inbound ServiceAnnouncementMessage声明的每个服务实例返回一个新的句柄，只要它的interface_id字段与serviceInterfaceId匹配，并且它的instance_id字段与requiredServiceInstanceId匹配。


In either case, before returning new handles, the binding implementation shall evaluate the ServiceInterface contract version for the corresponding Service Instance in the content of the ServiceAnnouncementMessage samples. The binding shall return a new handle only if:

> 无论哪种情况，在返回新的句柄之前，绑定实现都应评估相应服务实例在ServiceAnnouncementMessage样本中的ServiceInterface合同版本。只有在以下情况下，绑定才会返回新的句柄：


1. The ServiceInterface contract version of the discovered service instance is compatible with the serviceInterfaceDeployment version of the DdsRequiredServiceInstance according to [RS_CM_00501]

> 服务接口合约版本的发现服务实例与DdsRequiredServiceInstance的服务接口部署版本根据[RS_CM_00501]兼容。

2. The ServiceInterface contract version is not part of any DdsRequiredServiceInstance.blocklistedVersion, according to [RS_CM_00701].

> 根据[RS_CM_00701]，服务接口合同版本不是任何DdsRequiredServiceInstance.blocklistedVersion的一部分。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_90514]**{DRAFT} **Mapping of StartFindService method** *[*When instructed to start a continuous service search, the DDS Binding shall perform the following operations:

> **[SWS_CM_90514]**{草案} **StartFindService方法的映射** *[*当指示开始连续服务搜索时，DDS绑定应执行以下操作：

- [[SWS_CM_90511](#_bookmark228)] It shall look for an existing DDS DomainParticipant capable of finding remote Service Instances. If such DomainParticipant does not exist, the DDS binding shall create it as specified in [[SWS_CM_90512](#_bookmark229)].

- It shall continuously monitor arrival of ServiceAnnouncementMessage samples through the ara.com://services/discovery topic, calling FindServiceHandler whenever a matching Service Instance is discovered.

> 它将持续监视通过ara.com://services/discovery主题到达的ServiceAnnouncementMessage样本，每当发现匹配的服务实例时调用FindServiceHandler。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**[SWS_CM_90515]**{DRAFT} **Mapping of StopFindService method** *[*When instructed to stop a continuous service search initiated by a previous call to StartFindService (), the DDS Binding shall perform the following operations:

> **[SWS_CM_90515]**{草案} **停止查找服务方法的映射** *[*当指示通过先前调用StartFindService（）停止连续服务搜索时，DDS绑定应执行以下操作：

- [[SWS_CM_90511](#_bookmark228)] It shall look for an existing DDS DomainParticipant capable of finding remote Service Instances. If such DomainParticipant does not exist, StopFindService() shall return and perform no further action.

- It shall stop monitoring the arrival of ServiceAnnouncementMessage samples through the ara.com://services/discovery topic.

> 它将停止通过ara.com://services/discovery主题监视ServiceAnnouncementMessage样本的到达。

*♩(RS_CM_00204, RS_CM_00200)*

### Handling Events


**[SWS_CM_11015] Mapping Events to DDS Topics** *[*The DDS binding shall map every VariableDataPrototype defined in the ServiceInterface in the role event to a DDS Topic. The equivalent DDS Topic shall be configured as follows:

> **[SWS_CM_11015] 将事件映射到DDS主题** *[*DDS绑定应将服务接口中角色事件中定义的每个VariableDataPrototype映射到一个DDS主题。 相应的DDS主题应按如下配置：

- The Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SER-

> 如果提供的或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION或SER，


VICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>

> VICE_INSTANCE_RESOURCE_INSTANCE_ID，那么主题名称应设置为ara.com：//services/\<InterfaceID\>/\<Major\>.\<Minor\>

/\<TopicName\>


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION进行广告，则此主题的样本应通过其父发布者和订阅者对象（分别包含PARTITION QoS策略中的以下分区：ara.com：//services/ \ <InterfaceID\>/ \ <InstanceId\>）发送和接收DataWriters和DataReaders。

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供或使用的服务实例使用identifier_type属性设置为SERVICE_INSTANCE_TOPIC_PREFIX，那么主题名称应设置为ara.com：//services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>。
- Where:


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>**是DdsServiceInterfaceDeployment服务接口的ID值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **\<InstanceID\>** 是DdsProvidedServiceInstance.serviceInstanceId或DdsRequiredServiceInstance.requiredServiceInstanceId的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。

**\<TopicName\>** is the value of DdsEventDeployment.topicName


- The Topic Data Type shall be defined as specified in [[SWS_CM_11016](#_bookmark233)], and shall be registered under the equivalent data type name.

> 该主题数据类型应按照[[SWS_CM_11016](#_bookmark233)]中的规定进行定义，并应在等效的数据类型名称下进行注册。

*♩(RS_CM_00204, RS_CM_00201)*


**[SWS_CM_11016] DDS Topic data type definition** *[*The data type of a DDS Topic representing an Event shall be constructed according to the following IDL definition:

> **[SWS_CM_11016] DDS 主题数据类型定义** *[*表示事件的DDS主题的数据类型应按照以下IDL定义构造：

```
1 struct \<eventTypeName\>EventType {

2 \@key uint16 instance_id;

3 \<eventTypeName\> data;

4 };
```

Where:

**\<eventTypeName\>** is the Cpp Implementation Data Type symbol


**instance_id** is a \@key member of the type, which identifies all samples with the same instance_id as samples of the same Topic Instance.

> **实例ID**是一个@key成员类型，它可以标识出具有相同实例ID的样本属于同一个主题实例。


**data** is the actual value of the event, which shall be constructed and encoded according to the DDS serialization rules. The \@external annotation is optionally allowed, for cases where references yield implementation benefits over values.

> 数据是事件的实际值，应根据DDS序列化规则构造和编码。可以选择使用\@external注释，以便引用可以比值提供更多的实现好处。

*♩(RS_CM_00204, RS_CM_00201)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 规则DDS序列化定义在第7.5.3.7节（#序列化有效负载3）。


**[SWS_CM_11017] Mapping of Send method** *[*When instructed to send an event message, the DDS Binding shall construct a new sample of the equivalent DDS Topic data type (see [[SWS_CM_11016](#_bookmark233)]) as follows:

> **[SWS_CM_11017] 发送方法的映射** *[*当收到指令发送事件信息时，DDS绑定将构造等效的DDS主题数据类型的新样本（参见[[SWS_CM_11016](#_bookmark233)])，如下所示：


- The Instance Id field (instance_id) shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the serviceInstanceId.

> 字段“实例ID”（instance_id）应从清单中派生，其中DdsProvidedServiceInstance元素定义了serviceInstanceId。
- The Data field (data) shall point to the data input parameter of the Send() method.


That sample shall be then passed as a parameter to the write() method of the DDS DataWriter associated with the event, which shall serialize the sample according to the serialization rules, and publish it over DDS.*♩(RS_CM_00204, RS_CM_00201)*

> 那个样本将被作为参数传递给与事件关联的DDS DataWriter的write()方法，该方法将按照序列化规则序列化该样本，并通过DDS发布它。*♩（RS_CM_00204，RS_CM_00201）*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 载荷序列化规则在第7.5.3.7节中定义。


**[SWS_CM_11018] Mapping of Subscribe method** *[*When instructed to subscribe to an event, the DDS binding shall create a DDS DataReader using the DDS Subscriber created for the proxy in [[SWS_CM_11009](#_bookmark210)]. The rules to create the DataReader are specified in [[SWS_CM_11019](#_bookmark234)].

> **[SWS_CM_11018] 订阅方法的映射** *[*当收到指令订阅事件时，DDS 绑定应使用为代理创建的 DDS 订阅者创建 DDS 数据读取器。创建数据读取器的规则在 [[SWS_CM_11019](#_bookmark234)] 中指定。

*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_11019] Creating a DDS DataReader for event subscription** *[*The DDS binding shall create a DDS DataReader for the Topic associated with the event (see [[SWS_CM_11015](#_bookmark232)]). If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service instance it is bound to, the binding implementation shall use the DDS Subscriber created in [[SWS_CM_11002](#_bookmark198)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataReader.

> [SWS_CM_11019] 为事件订阅创建DDS数据读取器：DDS绑定应为与事件相关的主题创建DDS数据读取器（参见[[SWS_CM_11015](#_bookmark232)]）。如果提供或使用的服务实例使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，以确保代理只与其绑定的服务实例通信，则绑定实现应使用在[[SWS_CM_11002](#_bookmark198)]中创建的DDS订阅者（其分区名称为“ara.com：//services/\<svcId\>_\<reqSvcInId\>\”）来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsEventQosProps element defines the qosProfile that shall be used. To configure the DataReader's cache size according to the maxSampleCount specified in the Subscribe() method call, the value of the DataReader's HISTORY QoS specified in qosProfile shall be overridden as follows:

> DataReaderQos应根据清单中的规定设置，其中DdsEventQosProps元素定义要使用的qosProfile。为了根据Subscribe（）方法调用中指定的maxSampleCount配置DataReader的缓存大小，应该覆盖qosProfile中指定的DataReader的HISTORY QoS的值，如下所示：

  history.kind = KEEP_LAST_HISTORY_QOS
  history.depth = \<maxSampleCount\>

- Listener shall be an instance of the DataReaderListener class specified in [[SWS_CM_11020](#_bookmark235)].

> 侦听器必须是[[SWS_CM_11020](#_bookmark235)]中指定的DataReaderListener类的实例。
- StatusMask shall be set to STATUS_MASK_NONE.

*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_11020] Defining a DDS DataReaderListener** *[*The DDS Binding implementation shall define a DataReaderListener class capable of handling notifications when a new sample is received and/or when the matched status of the subscription changes. This class shall derive from the standard DataReaderListener class [18], specifying that the samples to be handled are of the Topic data type specified in [[SWS_CM_11016](#_bookmark233)].

> **[SWS_CM_11020] 定义DDS DataReaderListener** *[*DDS绑定实现应定义一个DataReaderListener类，能够处理收到新样本时的通知，以及订阅的匹配状态更改时的通知。此类应从标准DataReaderListener类[18]派生，指定要处理的样本是[[SWS_CM_11016](#_bookmark233)]中指定的主题数据类型。


The DataReaderListener shall implement the following methods according to the specified instructions:

> 数据读取器侦听器应根据指定的说明实现以下方法：


- A Constructor that initializes two member variables that hold references to an EventReceiveHandler and a SubscriptionStateChangeHandler.

> 一个构造函数，它初始化两个成员变量，它们分别保存对EventReceiveHandler和SubscriptionStateChangeHandler的引用。

- An on_data_available() method that calls the EventReceiveHandler if it has been set and there are valid samples in the DataReader's cache.

> 一个on_data_available()方法，如果设置了EventReceiveHandler并且DataReader缓存中有有效的样本，就会调用EventReceiveHandler。

- An on_subscription_matched() method that calls GetSubscriptionState() and passes the resulting SubscriptionState to SubscriptionStateChangeHandler if it has been set.

> 一个on_subscription_matched()方法，它调用GetSubscriptionState()并将得到的SubscriptionState传递给SubscriptionStateChangeHandler，如果它已被设置。

- A set_event_receive_handler() method that takes as an input parameter a reference to an EventReceiveHandler and updates the member variable holding a reference to an EventReceiveHandler to point to the input parameter.

> 一个set_event_receive_handler()方法，它接受一个EventReceiveHandler的引用作为输入参数，并将保存对EventReceiveHandler引用的成员变量更新为指向输入参数的引用。

- A set_subscription_state_change_handler() method that takes as an input parameter a reference to a SubscriptionStateChangeHandler and updates the member variable holding a reference to a SubscriptionStateChangeHandler to point to the input parameter.

> 一个set_subscription_state_change_handler（）方法，它将SubscriptionStateChangeHandler的引用作为输入参数，并将保存引用SubscriptionStateChangeHandler的成员变量更新为指向输入参数。

*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_11021] Mapping of Unsubscribe method** *[*When instructed to unsubscribe from a service event, the DDS binding shall delete the DataReader associated with the event.*♩(RS_CM_00204, RS_CM_00104)*

> **[SWS_CM_11021] 未订阅服务事件的映射** *[*当指示取消订阅服务事件时，DDS 绑定应删除与该事件关联的 DataReader。*♩（RS_CM_00204，RS_CM_00104）*


**[SWS_CM_11022] Mapping of GetSubscriptionState method** *[*When instructed to provide the subscription state, the DDS binding shall check if the DataReader associated with the subscription exists:

> **[SWS_CM_11022] 获取订阅状态方法的映射** *[*当被指示提供订阅状态时，DDS 绑定应检查与订阅相关联的数据读取器是否存在：


- If it does exist, the binding shall call the DataReader's get_subscription_matched_status() method next.

> 如果它确实存在，绑定将接下来调用DataReader的get_subscription_matched_status()方法。

- If the total_count attribute of the resulting SubscriptionMatchedStatus is greater than zero, GetSubscriptionState() shall return SubscriptionState = kSubscribed.

> 如果结果SubscriptionMatchedStatus的total_count属性大于零，GetSubscriptionState()应返回SubscriptionState = kSubscribed。
- Otherwise, it shall return SubscriptionState = kSubscriptionPending.

```{=html}
<!--->
```


- Else, if it does not exist---which indicates that either Subscribe() has never invoked or Unsubscribe() has been called before---GetSubscriptionState () shall return SubscriptionState = kNotSubscribed.

> 如果不存在（表明Subscribe（）从未调用过或者Unsubscribe（）已经被调用过），GetSubscriptionState（）应该返回SubscriptionState = kNotSubscribed。

*♩(RS_CM_00204, RS_CM_00106)*


**[SWS_CM_11023] Mapping of GetNewSamples method** *[*When instructed to get new samples, the DDS binding shall perform a take() on the DataReader as follows:

> **[SWS_CM_11023] 對於GetNewSamples方法的映射** *[*當被指示獲取新樣本時，DDS綁定將按以下方式對DataReader執行take()：


- If a maxNumberOfSamples is specified, the binding implementation shall invoke take() with max_samples = maxNumberOfSamples.

> 如果指定了maxNumberOfSamples，绑定实现应该调用take（），max_samples = maxNumberOfSamples。


- Else, if no maxNumberOfSamples is specified (i.e., if maxNumberOfSamples is equal to the default value std::numeric_limits\<std::size_t\>::max()), the binding implementation shall invoke take() without specifying a max_samples limit.

> 如果没有指定maxNumberOfSamples（即maxNumberOfSamples等于默认值std::numeric_limits<std::size_t>::max()），绑定实现应调用take（）而不指定max_samples限制。


After calling take(), the binding implementation shall invoke the Callable f for every valid sample taken from the DataReader's cache (i.e., every sample with SampleInfo.valid_data equal to true), providing f with a reference to the corresponding sample.

> 在调用take()之后，绑定实现应该为从DataReader缓存中获取的每个有效样本（即SampleInfo.valid_data等于true的样本）调用Callable f，并提供对相应样本的引用。

*♩(RS_CM_00204, RS_CM_00202)*


**[SWS_CM_11024] Mapping of GetFreeSampleCount method** *[*When instructed to provide the number of free sample slots, the binding implementation shall return the number free sample slots in the DDS DataReader's cache.*♩(RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_11024] 将GetFreeSampleCount方法映射** *[*当指示提供免费样本槽数时，绑定实现应返回DDS DataReader缓存中的免费样本槽数。*♩(RS_CM_00204, RS_CM_00202)*


**[SWS_CM_11025] Mapping of SetReceiveHandler method** *[*When instructed to register an EventReceiveHandler, the binding implementation shall perform the following operations:

> 当指示注册一个EventReceiveHandler时，绑定实现应执行以下操作：

- It shall get a reference to the DataReader's listener using the get_listener() method.


- It shall use the set_event_receive_handler() method to instruct the listener to invoke the new EventReceiveHandler whenever there is data available.

> 它将使用set_event_receive_handler()方法来指示侦听器在有数据可用时调用新的EventReceiveHandler。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过将listener设置为新的listener对象并将StatusMask设置如下来更新DataReader的侦听器：

  If the original value of StatusMask was STATUS_MASK_NONE or

DATA_AVAILABLE_STATUS, set it to DATA_AVAILABLE_STATUS.


- If the original value of StatusMask was SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为SUBSCRIPTION_MATCHED_STATUS，将其设置为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS。

- If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为DATA_AVAILABLE_STATUS|SUBSCRIPTION_MATCHED_STATUS，请将其设置为DATA_AVAILABLE_STATUS|SUBSCRIPTION_MATCHED_STATUS。

*♩(RS_CM_00204, RS_CM_00203)*


**[SWS_CM_11026] Mapping of UnsetReceiveHandler method** *[*When instructed to unregister an EventReceiveHandler, the binding implementation shall perform the following operations:

> 当指示取消注册EventReceiveHandler时，绑定实现应执行以下操作：SWS_CM_11026] UnsetReceiveHandler 方法的映射

- It shall get a reference to the DataReader's listener using the get_listener() method.
- It shall use the set_event_receive_handler() method to unset the internal

EventReceiveHandler that is called whenever there is data available.


- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过将listener设置为新的listener对象并将StatusMask设置如下来调用set_listener()来更新DataReader的监听器：

  If the original value of StatusMask was STATUS_MASK_NONE or

DATA_AVAILABLE_STATUS, set it to STATUS_MASK_NONE.


- If the original value of StatusMask was SUBSCRIPTION_MATCHED_STATUS, set it to SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为SUBSCRIPTION_MATCHED_STATUS，将其设置为SUBSCRIPTION_MATCHED_STATUS。

- If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS|SUBSCRIPTION_MATCHED_STATUS，将其设置为SUBSCRIPTION_MATCHED_STATUS。

*♩(RS_CM_00204, RS_CM_00203)*


**[SWS_CM_11027] Mapping of SetSubscriptionStateHandler method** *[*When instructed to register a SubscriptionStateChangeHandler, the binding implementation shall perform the following operations:

> 当指示注册SubscriptionStateChangeHandler时，绑定实现应执行以下操作：

- It shall get a reference to the DataReader's listener using the get_listener() method.

- It shall use the set_subscription_state_change_handler() method to instruct the listener to invoke the new SubscriptionStateChangeHandler whenever there is a change in the SubscriptionMatchedStatus.

> 它将使用set_subscription_state_change_handler()方法来指示侦听器，每当SubscriptionMatchedStatus发生变化时，调用新的SubscriptionStateChangeHandler。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过将listener设置为新的listener对象并将StatusMask设置如下来调用set_listener()来更新DataReader的侦听器：


  If the original value of StatusMask was STATUS_MASK_NONE or SUBSCRIPTION_MATCHED_STATUS, set it to SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为STATUS_MASK_NONE或SUBSCRIPTION_MATCHED_STATUS，请将其设置为SUBSCRIPTION_MATCHED_STATUS。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS，将其设置为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS，请将其设置为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS。

*♩(RS_CM_00204, RS_CM_00106)*


**[SWS_CM_11028] Mapping of UnsetSubscriptionStateHandler method** *[*When instructed to unregister a SubscriptionStateChangeHandler, the binding implementation shall perform the following operations:

> 当收到指令取消注册订阅状态变更处理程序时，绑定实现应执行以下操作：[SWS_CM_11028] Mapping of UnsetSubscriptionStateHandler method

- It shall get a reference to the DataReader's listener using the get_listener() method.


- It shall use the set_subscription_state_change_handler() method to instruct the listener to unset the internal SubscriptionStateChangeHandler that is called whenever there is a change in the SubscriptionMatchedStatus.

> 它应该使用set_subscription_state_change_handler()方法来指示侦听器取消设置内部SubscriptionStateChangeHandler，该handler在SubscriptionMatchedStatus发生变化时被调用。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过调用set_listener（）并将listener设置为新的listener对象，以及将StatusMask设置如下来更新DataReader的侦听器：


  If the original value of StatusMask was STATUS_MASK_NONE or SUBSCRIPTION_MATCHED_STATUS, set it to STATUS_MASK_NONE.

> 如果StatusMask的原始值是STATUS_MASK_NONE或SUBSCRIPTION_MATCHED_STATUS，将其设置为STATUS_MASK_NONE。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS, set it to DATA_AVAILABLE_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS，将其设置为DATA_AVAILABLE_STATUS。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS，将其设置为DATA_AVAILABLE_STATUS。

*♩(RS_CM_00204, RS_CM_00106)*

### Handling Triggers


**[SWS_CM_10524]**{DRAFT} **Mapping Triggers to DDS Topics** *[*The DDS binding shall map every Trigger defined in the ServiceInterface in the role trigger to a DDS Topic. The equivalent DDS Topic shall be configured as follows:

> **[SWS_CM_10524]**{草案} **将触发器映射到DDS主题** *[*服务接口中角色触发器中定义的每个触发器都必须映射到DDS主题。 相应的DDS主题应按如下方式配置：

- The Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SER-

> 如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION或SER，


VICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>

> VICE_INSTANCE_RESOURCE_INSTANCE_ID，然后主题名称应设置为ara.com：//services/\<InterfaceID\>/\<Major\>.\<Minor\>

/\<TopicName\>


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION进行广告，则应通过其父发布者和订阅者对象的PARTITION QoS策略中包含以下分区的数据写入器和数据读取器发送和接收此主题的样本：ara.com：//services/\<InterfaceID\>/\<InstanceId\>。

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_TOPIC_PREFIX，则主题名称应设置为ara.com：//services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>
- Where:


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>** 是DdsServiceInterfaceDeployment服务接口的ID值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **<InstanceID>**是DdsProvidedServiceInstance服务实例ID或DdsRequiredServiceInstance所需服务实例ID的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。


**\<TopicName\>** is the value of DdsEventDeployment.topicName associated with the trigger

> **\<TopicName\>**是与触发器关联的DdsEventDeployment.topicName的值


- The Topic Data Type shall be defined as specified in [[SWS_CM_10525](#_bookmark245)], and shall be registered under the equivalent data type name.

> 该主题数据类型将按照[[SWS_CM_10525](#_bookmark245)]中的规定进行定义，并在相应的数据类型名称下进行注册。

*♩(RS_CM_00204, RS_CM_00201)*


**[SWS_CM_10525]**{DRAFT} **DDS Topic data type definition** *[*The data type of a DDS Topic representing a trigger shall be constructed according to the following IDL definition:

> **[SWS_CM_10525]**{草案} **DDS 主题数据类型定义** *[*表示触发器的DDS主题的数据类型应按照以下IDL定义构造：

```
1 struct TriggerType {

2 \@key uint16 instanceIdentifier;

3 };
```

Where:


**instance_id** is a \@key member of the type, which identifies all samples with the same instance_id as samples of the same Topic Instance.

> **instance_id**是一个@key成员类型，它用来标识所有具有相同instance_id的样本都属于同一个主题实例。

*♩(RS_CM_00204, RS_CM_00201)*


**[SWS_CM_10526]**{DRAFT} **Mapping of Send method** *[*When instructed to send a trigger message, the DDS Binding shall construct a new sample of the equivalent DDS Topic data type (see [[SWS_CM_10525](#_bookmark245)]) as follows:

> **[SWS_CM_10526]**{草案} **发送方法的映射** *[*当指示发送触发消息时，DDS 绑定应按照以下方式构造等效的 DDS 主题数据类型的新样本（参见[[SWS_CM_10525](#_bookmark245)])：


- The Instance Id field (instance_id) shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the serviceInstanceId.

> 字段“实例ID”（instance_id）应从清单中派生，其中DdsProvidedServiceInstance元素定义了serviceInstanceId。


That sample shall be then passed as a parameter to the write() method of the DDS DataWriter associated with the trigger, which shall serialize the sample according to the serialization rules, and publish it over DDS.*♩(RS_CM_00204, RS_CM_00201)*

> 那个样本应该作为一个参数传递给与触发器关联的DDS DataWriter的write()方法，这个方法应该根据序列化规则序列化样本，并通过DDS发布它。*♩(RS_CM_00204，RS_CM_00201)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 规则DDS序列化定义在[7.5.3.7](#serialization-of-payload-3)节中。


**[SWS_CM_10527]**{DRAFT} **Mapping of Subscribe method** *[*When instructed to subscribe to a trigger, the DDS binding shall create a DDS DataReader using the DDS Subscriber created for the proxy in [[SWS_CM_11009](#_bookmark210)] or [[SWS_CM_90513](#_bookmark230)]. The rules to create the DataReader are specified in [[SWS_CM_10528](#_bookmark246)].*♩(RS_CM_00204, RS_CM_00103)*

> **[SWS_CM_10527]**{草案} **订阅方法的映射** *[*当指示订阅触发器时，DDS 绑定应使用为代理创建的 DDS 订阅者在[[SWS_CM_11009](#_bookmark210)]或[[SWS_CM_90513](#_bookmark230)]中创建 DDS DataReader。创建 DataReader 的规则在[[SWS_CM_10528](#_bookmark246)]中指定。*♩(RS_CM_00204, RS_CM_00103)*

简体中文：**[SWS_CM_10527]**{草案} **订阅方法的映射** *[*当指示订阅触发器时，DDS 绑定应使用为代理创建的 DDS 订阅者在[[SWS_CM_11009](#_bookmark210)]或[[SWS_CM_90513](#_bookmark230)]中创建 DDS DataReader。创建 DataReader 的规则在[[SWS_CM_10528](#_bookmark246)]中指定。*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_10528]**{DRAFT} **Creating a DDS DataReader for trigger subscription** *[*The DDS binding shall create a DDS DataReader for the Topic associated with the trigger (see [[SWS_CM_10524](#_bookmark244)]). If the provided or consumed Service

> **[SWS_CM_10528]**{草案} **创建一个DDS DataReader以订阅触发器** *[*DDS绑定应该为与触发器相关联的主题创建一个DDS DataReader（参见[[SWS_CM_10524](#_bookmark244)]）。如果提供或消费的服务


Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service instance it is bound to, the binding implementation shall use the DDS Subscriber created in [[SWS_CM_11009](#_bookmark210)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataReader.

> 实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION来进行广告，以确保代理只与其绑定的服务实例通信，绑定实现应使用在[[SWS_CM_11009](#_bookmark210)]中创建的DDS订阅者（其分区名称为“ara.com：// services / \ <svcId \> _ \ <reqSvcInId \>”）来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsEventQosProps element defines the qosProfile that shall be used.

> DataReaderQos应按照清单中的规定进行设置，其中DdsEventQosProps元素定义了应使用的qosProfile。

- Listener shall be an instance of the DataReaderListener class specified in [[SWS_CM_11020](#_bookmark235)].

> 侦听器应该是[[SWS_CM_11020](#_bookmark235)]中指定的DataReaderListener类的一个实例。
- StatusMask shall be set to STATUS_MASK_NONE.

*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_10529]**{DRAFT} **Defining a DDS DataReaderListener** *[*The DDS Binding implementation shall define a DataReaderListener class capable of handling notifications when a new sample is received and/or when the matched status of the subscription changes. This class shall derive from the standard DataReaderListener class [18], specifying that the samples to be handled are of the Topic data type specified in [[SWS_CM_10525](#_bookmark245)].

> **[SWS_CM_10529]**{草案} **定义DDS DataReaderListener** *[*DDS绑定实现应该定义一个DataReaderListener类，能够处理收到新样本时的通知和/或订阅的匹配状态发生变化时的通知。此类应从标准DataReaderListener类[18]派生，指定要处理的样本是[[SWS_CM_10525](#_bookmark245)]中指定的主题数据类型。


The DataReaderListener shall implement the following methods according to the specified instructions:

> 数据读取器侦听器应根据指定的说明实现以下方法：


- A Constructor that initializes two member variables that hold references to an TriggerReceiveHandler and a SubscriptionStateChangeHandler.

> 一个构造函数，用来初始化两个成员变量，它们保存对TriggerReceiveHandler和SubscriptionStateChangeHandler的引用。
- An on_data_available() method that calls the TriggerReceiveHandler

if it has been set and there are valid samples in the DataReader's cache.


- An on_subscription_matched() method that calls GetSubscriptionState() and passes the resulting SubscriptionState to SubscriptionStateChangeHandler if it has been set.

> 一个on_subscription_matched() 方法，调用GetSubscriptionState() 并将结果SubscriptionState传递给SubscriptionStateChangeHandler，如果它已经被设置。

- A set_trigger_receive_handler() method that takes as an input parameter a reference to an TriggerReceiveHandler and updates the member variable holding a reference to an TriggerReceiveHandler to point to the input parameter.

> 一个set_trigger_receive_handler()方法，它接受一个TriggerReceiveHandler的引用作为输入参数，并更新保存TriggerReceiveHandler引用的成员变量，以指向输入参数。

- A set_subscription_state_change_handler() method that takes as an input parameter a reference to a SubscriptionStateChangeHandler and updates the member variable holding a reference to a SubscriptionStateChangeHandler to point to the input parameter.

> 一个set_subscription_state_change_handler()方法，它接受一个SubscriptionStateChangeHandler的引用作为输入参数，并更新保存引用的成员变量，以指向输入参数。

*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_10530]**{DRAFT} **Mapping of Unsubscribe method** *[*When instructed to unsubscribe from a service trigger, the DDS binding shall delete the DataReader associated with the trigger.*♩(RS_CM_00204, RS_CM_00104)*

> **[SWS_CM_10530]**{草案} **取消订阅方法的映射** *[*当指示取消订阅服务触发器时，DDS 绑定应删除与触发器关联的 DataReader。*♩(RS_CM_00204，RS_CM_00104)*


**[SWS_CM_10531]**{DRAFT} **Mapping of GetSubscriptionState method** *[*When instructed to provide the subscription state, the DDS binding shall check if the DataReader associated with the subscription exists:

> **[SWS_CM_10531]**{草案} **GetSubscriptionState方法的映射** *[*当指示提供订阅状态时，DDS绑定应检查与订阅关联的DataReader是否存在：

- If it does exist, the binding shall call the DataReader's

get_subscription_matched_status() method next.


- If the total_count attribute of the resulting SubscriptionMatchedStatus is greater than zero, GetSubscriptionState() shall return SubscriptionState = kSubscribed.

> 如果结果SubscriptionMatchedStatus的total_count属性大于零，GetSubscriptionState()应返回SubscriptionState = kSubscribed。
- Otherwise, it shall return SubscriptionState = kSubscriptionPending.

```{=html}
<!--->
```


- Else, if it does not exist---which indicates that either Subscribe() has never invoked or Unsubscribe() has been called before---GetSubscriptionState () shall return SubscriptionState = kNotSubscribed.

> 如果不存在，即表明Subscribe（）从未调用过或者Unsubscribe（）已经调用过，GetSubscriptionState（）应返回SubscriptionState = kNotSubscribed。

*♩(RS_CM_00204, RS_CM_00106)*


**[SWS_CM_10532]**{DRAFT} **Mapping of GetNewTriggers method** *[*When instructed to get new triggers, the DDS binding shall perform a take() on the DataReader without specifying a max_samples limit.

> 当接收到获取新触发器的指令时，DDS 绑定应该在不指定 max_samples 限制的情况下对 DataReader 执行 take() 操作。


After calling take(), the binding implementation shall increase the internal trigger count proportionally to the number of samples returned by take().*♩(RS_CM_00204, RS_CM_00202)*

> 在调用take()之后，绑定实现应该根据take()返回的样本数量比例增加内部触发计数。


**[SWS_CM_10534]**{DRAFT} **Mapping of SetReceiveHandler method** *[*When instructed to register an TriggerReceiveHandler, the binding implementation shall perform the following operations:

> **[SWS_CM_10534]**{草案} **SetReceiveHandler 方法的映射** *[*当指示注册一个TriggerReceiveHandler时，绑定实现应执行以下操作：

- It shall get a reference to the DataReader's listener using the get_listener() method.

- It shall use the set_trigger_receive_handler() method to instruct the listener to invoke the new TriggerReceiveHandler whenever there is data available.

> 它将使用set_trigger_receive_handler()方法来指示监听器，每当有数据可用时就调用新的TriggerReceiveHandler。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过调用set_listener（），将监听器设置为新的监听器对象，状态掩码设置如下，以更新DataReader的监听器：


- If the original value of StatusMask was STATUS_MASK_NONE or DATA_AVAILABLE_STATUS, set it to DATA_AVAILABLE_STATUS.

> 如果StatusMask的原始值是STATUS_MASK_NONE或DATA_AVAILABLE_STATUS，将其设置为DATA_AVAILABLE_STATUS。

- If the original value of StatusMask was SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为SUBSCRIPTION_MATCHED_STATUS，请将其设置为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS。

- If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS，请将其设置为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS。

*♩(RS_CM_00204, RS_CM_00203)*


**[SWS_CM_10535]**{DRAFT} **Mapping of UnsetReceiveHandler method** *[*When instructed to unregister an TriggerReceiveHandler, the binding implementation shall perform the following operations:

> **[SWS_CM_10535]**{草案} **UnsetReceiveHandler 方法的映射** *[*当指示取消注册 TriggerReceiveHandler 时，绑定实现应执行以下操作：

- It shall get a reference to the DataReader's listener using the get_listener() method.

- It shall use the set_trigger_receive_handler() method to unset the internal TriggerReceiveHandler that is called whenever there is data available.

> 它将使用set_trigger_receive_handler()方法来取消调用内部TriggerReceiveHandler的设置，以便在有数据可用时调用。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过将listener设置为新的listener对象并将StatusMask设置为以下值来调用set_listener()来更新DataReader的监听器：


- If the original value of StatusMask was STATUS_MASK_NONE or DATA_AVAILABLE_STATUS, set it to STATUS_MASK_NONE.

> 如果StatusMask的原始值是STATUS_MASK_NONE或DATA_AVAILABLE_STATUS，将其设置为STATUS_MASK_NONE。

- If the original value of StatusMask was SUBSCRIPTION_MATCHED_STATUS, set it to SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值是SUBSCRIPTION_MATCHED_STATUS，请将其设置为SUBSCRIPTION_MATCHED_STATUS。

- If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为DATA_AVAILABLE_STATUS|SUBSCRIPTION_MATCHED_STATUS，请将其设置为SUBSCRIPTION_MATCHED_STATUS。

*♩(RS_CM_00204, RS_CM_00203)*


**[SWS_CM_10536]**{DRAFT} **Mapping of SetSubscriptionStateHandler method** *[*When instructed to register a SubscriptionStateChangeHandler, the binding implementation shall perform the following operations:

> **[SWS_CM_10536]**{草案} **SetSubscriptionStateHandler 方法的映射** *[*按照指示注册SubscriptionStateChangeHandler时，绑定实现应执行以下操作：

- It shall get a reference to the DataReader's listener using the get_listener() method.


- It shall use the set_subscription_state_change_handler() method to instruct the listener to invoke the new SubscriptionStateChangeHandler whenever there is a change in the SubscriptionMatchedStatus.

> 它应该使用set_subscription_state_change_handler（）方法来指示侦听器在SubscriptionMatchedStatus发生变化时调用新的SubscriptionStateChangeHandler。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过将listener设置为新的listener对象并将StatusMask设置如下来调用set_listener（）来更新DataReader的侦听器：


  If the original value of StatusMask was STATUS_MASK_NONE or SUBSCRIPTION_MATCHED_STATUS, set it to SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值是STATUS_MASK_NONE或SUBSCRIPTION_MATCHED_STATUS，请将其设置为SUBSCRIPTION_MATCHED_STATUS。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS，就将其设置为DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS.

> 如果StatusMask的原始值为DATA_AVAILABLE_STATUS|SUBSCRIPTION_MATCHED_STATUS，请将其设置为DATA_AVAILABLE_STATUS|SUBSCRIPTION_MATCHED_STATUS。

*♩(RS_CM_00204, RS_CM_00106)*


**[SWS_CM_10537]**{DRAFT} **Mapping of UnsetSubscriptionStateHandler method** *[*When instructed to unregister a SubscriptionStateChangeHandler, the binding implementation shall perform the following operations:

> **[SWS_CM_10537]**{草案} **UnsetSubscriptionStateHandler 方法的映射** *[*当指示取消注册SubscriptionStateChangeHandler时，绑定实现应执行以下操作：

- It shall get a reference to the DataReader's listener using the get_listener() method.

- It shall use the set_subscription_state_change_handler() method to instruct the listener to unset the internal SubscriptionStateChangeHandler that is called whenever there is a change in the SubscriptionMatchedStatus.

> 它将使用set_subscription_state_change_handler()方法来指示侦听器取消设置内部SubscriptionStateChangeHandler，该处理程序在SubscriptionMatchedStatus发生变化时被调用。

- It shall update the DataReader's listener by calling set_listener() with listener equal to the new listener object and StatusMask set as follows:

> 它将通过将listener设置为新的listener对象并将StatusMask设置如下来调用set_listener（）来更新DataReader的监听器：


  If the original value of StatusMask was STATUS_MASK_NONE or SUBSCRIPTION_MATCHED_STATUS, set it to STATUS_MASK_NONE.

> 如果StatusMask的原始值为STATUS_MASK_NONE或SUBSCRIPTION_MATCHED_STATUS，将其设置为STATUS_MASK_NONE。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS, set it to DATA_AVAILABLE_STATUS.

> 如果StatusMask的原始值为DATA_AVAILABLE_STATUS，将其设置为DATA_AVAILABLE_STATUS。

  If the original value of StatusMask was DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS, set it to DATA_AVAILABLE_STATUS.

> 如果StatusMask的原始值是DATA_AVAILABLE_STATUS\|SUBSCRIPTION_MATCHED_STATUS，请将其设置为DATA_AVAILABLE_STATUS。

*♩(RS_CM_00204, RS_CM_00106)*

### Handling Method Calls


The RPC over DDS Specification (DDS-RPC) [21] introduces the concept of DDS Services. These Services provide the mechanisms required to define and implement methods that can be invoked remotely by DDS "client" applications using the building blocks of the DDS data-centric publish-subscribe middleware [18]. In this section, we specify how to handle ara::com method calls over DDS by defining the appropriate mapping between ara::com service methods and DDS service methods.

> DDS-RPC规范（DDS-RPC）[21]引入了DDS服务的概念。这些服务提供了使用DDS数据中心发布订阅中间件[18]的基本构建块远程调用DDS“客户端”应用程序所需的定义和实现方法的机制。在本节中，我们通过定义ara :: com服务方法和DDS服务方法之间的适当映射，指定如何通过DDS处理ara :: com方法调用。


**[SWS_CM_11100] Mapping Methods to DDS Service Methods and Topics** *[*Every ServiceInterface containing one or more ClientServerOperations defined in the role method shall have an associated DDS Service to enable ara::com Service Instances to offer those operations, and to enable client applications to invoke them. The equivalent DDS Service shall provide all of the methods of the corresponding ServiceInterface.

> [SWS_CM_11100] 将方法映射到DDS服务方法和主题*[*每个包含角色方法中定义的一个或多个ClientServerOperations的ServiceInterface都应具有相关的DDS服务，以便ara :: com服务实例提供这些操作，并使客户端应用程序调用它们。相应的DDS服务应提供相应ServiceInterface的所有方法。


DDS Services shall be constructed according to the Basic Service Mapping Profile of the RPC over DDS specification [21], which assigns two DDS Topics to every DDS Service: a Request Topic and a Reply Topic. Thus, every ServiceInterface containing one or more ClientServerOperations defined in the role method shall trigger the creation of two equivalent DDS Topics.

> DDS服务将根据RPC over DDS规范[21]的基本服务映射配置构建，其中为每个DDS服务分配两个DDS主题：请求主题和回复主题。因此，包含在角色方法中定义的一个或多个ClientServerOperations的每个ServiceInterface都将触发创建两个等效的DDS主题。

The equivalent DDS Request Topic shall be configured as follows:

- The Request Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SER-

> 如果提供的或使用的服务实例被广告identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION或SER，


VICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>

> VICE_INSTANCE_RESOURCE_INSTANCE_ID，那么主题名称应设置为ara.com：//services/\<InterfaceID\>/\<Major\>.\<Minor\>

/\<TopicName\>


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION进行广告，则此主题的样本应通过其父发布者和订阅者对象中包含以下分区的PARTITION QoS策略发送和接收：ara.com：//services/\<InterfaceID\>/\<InstanceId\>。

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_TOPIC_PREFIX，则主题名称应设置为ara.com：//services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>**是DdsServiceInterfaceDeployment服务接口ID的值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **\<InstanceID\>** 是 DdsProvidedServiceInstance.serviceInstanceId 或 DdsRequiredServiceInstance.requiredServiceInstanceId 的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。


**\<TopicName\>** is the value of DdsServiceInterfaceDeployment. methodRequestTopicName

> **\<TopicName\>** 是DdsServiceInterfaceDeployment的值。methodRequestTopicName


- The Request Topic Data Type shall be defined as specified in [[SWS_CM_11101](#_bookmark249)], and shall be registered under the equivalent data type's name.

> 要求主题数据类型应按照[[SWS_CM_11101](#_bookmark249)]中的规定进行定义，并应在等效数据类型的名称下进行注册。

The equivalent DDS Reply Topic shall be configured as follows:

- The Reply Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SERVICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>

> 如果提供或消费的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION或SERVICE_INSTANCE_RESOURCE_INSTANCE_ID，则主题名称应设置为ara.com：//services/\<InterfaceID\>/\<Major\>.\<Minor\>。

/\<TopicName\>


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供或消费的服务实例使用 identifier_type 属性设置为 SERVICE_INSTANCE_RESOURCE_PARTITION，则此主题的样本应通过其父发布者和订阅者对象的数据写入程序和数据读取程序发送和接收，其中包括 PARTITION QoS 策略中的以下分区：ara.com://services/\<InterfaceID\>/\<InstanceId\>

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供或消费的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_TOPIC_PREFIX，那么主题名称应设置为ara.com：//services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>。
- Where:


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>** 是DdsServiceInterfaceDeployment服务接口的ID值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **\<InstanceID\>**是DdsProvidedServiceInstance服务实例ID或DdsRequiredServiceInstance所需服务实例ID的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。


**\<TopicName\>** is the value of DdsServiceInterfaceDeployment. methodReplyTopicName

> **\<TopicName\>** 是 DdsServiceInterfaceDeployment 的方法回复主题名称的值。


- The Reply Topic Data Type shall be defined as specified in [[SWS_CM_11102](#_bookmark250)], and shall be registered under the equivalent data type's name.

> 回复主题数据类型应按照[[SWS_CM_11102](#_bookmark250)]中的规定进行定义，并按等效数据类型的名称进行注册。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11101] DDS Service Request Topic data type definition** *[*As specified in section 7.5.1.1.6 of [21], the Request Topic data type is a structure composed of a Request Header with meta-data a Call Structure with data. The IDL definition of the Request Topic data type is the following:

> **[SWS_CM_11101] DDS服务请求主题数据类型定义** *[*根据[21]第7.5.1.1.6节的规定，请求主题数据类型是一个由元数据请求头和数据调用结构组成的结构体。请求主题数据类型的IDL定义如下：

1 struct \<svcId\>Method_Request {

2 dds::rpc::RequestHeader header;

3 \<svcId\>Method_Call data;

4 };

Where:

**\<svcId\>** is the corresponding serviceInterfaceId.


**dds::rpc::RequestHeader** is the standard Request Header defined in section 7.5.1.1.1 of [21].

> **dds::rpc::RequestHeader** 是第21节中定义的标准请求头。


**\<svcId\>Method_Call** is the union that holds the value of the input parameters of the corresponding methods, according to the rules specified in section 7.5.1.1.6 of [21].

> **\<svcId\>Method_Call**是根据[21]第7.5.1.1.6节中指定的规则，存储相应方法的输入参数值的联合。


dds::rpc::RequestHeader shall be constructed as specified in section 7.5.1.1.1 of [21]. On top of that, the binding implementation shall set instanceName (a member of the RequestHeader structure that specifies the DDS Service instance name) to a string representation of the serviceInstanceId of the service instance that provides the methods.

> dds::rpc::RequestHeader应按照[21]第7.5.1.1.1节的规定进行构造。此外，绑定实现应将instanceName（RequestHeader结构的成员，用于指定DDS服务实例名称）设置为提供方法的服务实例的serviceInstanceId的字符串表示形式。


\<svcId\>Method_Call shall be constructed as specified in section 7.5.1.1.6 of [21]:

> \<svcId\>方法调用应按照[21]第7.5.1.1.6节的规定进行构造。

- The name of the union shall be \<svcId\>Method_Call.
- The union discriminator shall be a 32-bit signed integer.

- The union shall have a default case of type dds::rpc::UnknownOperation (defined in section 7.5.1.1.1 of [21]) for unsupported and unknown operations.

> 联盟应该拥有一个[21]中第7.5.1.1.1节定义的dds::rpc::UnknownOperation类型的默认情况，用于不支持和未知的操作。

- The union shall have a case label for each ClientServerOperation defined in the ServiceInterface with the role method, where:

> 联盟应为ServiceInterface中定义的每个ClientServerOperation设置一个标签，其中：


  The integer value of the case label shall be a 32-bit hash of the ClientServerOperation's shortName. The binding implementation shall compute the hash as specified in section 7.5.1.1.2 of [21]. Representations of the service interface in OMG IDL [23] shall define 32-bit signed integer constants (i.e., const int32 \<svcId\>Method_\<methodName\>

> 在此情况下的整数值应该是客户/服务操作的简称的32位哈希值。绑定实现应按照[21]第7.5.1.1.2节中的规定计算哈希值。OMG IDL [23]中的服务接口表示应定义32位有符号整数常量（即const int32 \<svcId\>Method_\<methodName\>）。


_Hash; where \<methodName\> is the shortName of the ClientServerOperation) to simplify the representation of the union cases (see below).

> _哈希；其中\<methodName\>是客户端服务器操作的简称）用于简化联合案例的表示（见下文）。

- The member name for the case label shall be the shortName of the ClientServerOperation.

- The type for each case label shall be \<svcId\>Method_\<methodName\> _In, which shall be constructed as specified in section 7.5.1.1.4 of [21] (see below).

> 每个标签的类型应为<svcId>Method_<methodName>_In，其构造方式如[21]第7.5.1.1.4节所述（见下文）。

The IDL definition of the \<svcId\>Method_Call union is the following:

```
1 union \<svcId\>Method_Call switch(int32) {

2 default:

3 dds::rpc::UnknownOperation unknownOp;

4 case \<svcId\>Method_\<method0Name\>_Hash:

5 \<svcId\>Method_\<method0Name\>_In \<method0Name\>;

6 case \<svcId\>Method_\<method1Name\>_Hash:

7 \<svcId\>Method_\<method1Name\>_In \<method1Name\>;

8 // \...

9 case \<svcId\>Method_\<methodNName\>_Hash:

10 \<svcId\>Method_\<methodNName\>_In \<methodNName\>;

11 };
```


As defined in section 7.5.1.1.4 of [21], the \<svcId\>Method_\<methodName\>_In structure shall contain as members all the ArgumentDataPrototypes of the ClientServerOperation with direction set to in or inout. The IDL representation of \<svcId\>Method_\<methodName\>_In is the following:

> 根据[21]第7.5.1.1.4节的定义，\<svcId\>Method_\<methodName\>_In结构中应包含具有方向设置为in或inout的ClientServerOperation的所有ArgumentDataPrototypes。 \<svcId\>Method_\<methodName\>_In的IDL表示形式如下：

```
1 struct \<svcId\>Method_\<methodName\>_In {

2 \<ArgumentDataPrototype[0]\>;

3 \<ArgumentDataPrototype[1]\>;

4 // \...

5 \<ArgumentDataPrototype[n]\>;

6 };
```


In accordance with [21], for methods with no input parameters, the DDS binding shall generate a \<svcId\>Method_\<methodName\>_In structure with a single member named dummy of type dds::rpc::UnusedMember (see section 7.5.1.1.1 of [21]).

> 根据[21]，对于没有输入参数的方法，DDS绑定应该生成一个名为\<svcId\>Method_\<methodName\>_In的结构，该结构有一个名为dummy的成员，类型为dds::rpc::UnusedMember（参见[21]的7.5.1.1.1节）。


The resulting Request Topic data type shall be encoded according to the DDS serialization rules. Unions, such as the \<svcId\>Method_Call union, shall be serialized as specified in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00200)*

> 结果请求主题数据类型应按照DDS序列化规则进行编码。像<svcId>Method_Call联合体这样的联合体应按照[20]第7.4.3.5节中的规定进行序列化。


**[SWS_CM_11102] DDS Service Reply Topic data type definition** *[*As specified in section 7.5.1.1.7 of [21], the Reply Topic data type is a structure composed of a Reply Header with meta-data and a Return Structure with data. The IDL definition of the Reply Topic data type is the following:

> **[SWS_CM_11102] DDS 服务回复主题数据类型定义** *[*根据[21]第7.5.1.1.7节的规定，回复主题数据类型是由元数据的回复头和数据的返回结构组成的结构。回复主题数据类型的IDL定义如下：

```
1 struct \<svcId\>Method_Reply {

2 dds::rpc::ReplyHeader header;

3 \<svcId\>Method_Return data;

4 };
```

Where:

**\<svcId\>** is the corresponding serviceInterfaceId.


**dds::rpc::ReplyHeader** is the standard Reply Header defined in section 7.5.1.1.1 of [21].

> **dds::rpc::ReplyHeader**是[21]第7.5.1.1.1节中定义的标准回复头。


**\<svcId\>Method_Return** is the union that holds the return values (i.e., return values, output parameter values, and/or errors) of the corresponding response, according to the rules specified in section 7.5.1.1.7 of [21].

> **\<svcId\>Method_Return** 是一个联合体，根据[21]第7.5.1.1.7节指定的规则，它持有相应响应的返回值（即返回值、输出参数值和/或错误）。


dds::rpc::ReplyHeader shall be constructed as specified in section 7.5.1.1.1 of [21].

> dds::rpc::ReplyHeader 应按照[21]中第7.5.1.1.1节中的规定进行构造。


\<svcId\>Method_Return shall be constructed as specified in section 7.5.1.1.7 of [21]:

> \<svcId\>方法的返回值应按照[21]第7.5.1.1.7节的规定构建。

- The name of the union shall be \<svcId\>Method_Return.
- The union discriminator shall be a 32-bit signed integer.

- The union shall have a default case of type dds::rpc::UnknownOperation (defined in section 7.5.1.1.1 of [21]) for unsupported and unknown operations.

> 联盟应对不受支持和未知操作有一个类型为dds::rpc::UnknownOperation（在[21]的第7.5.1.1.1节定义）的默认情况。


- The union shall have a case label for each ClientServerOperation defined in the ServiceInterface with the role method, where:

> 联盟应该为ServiceInterface中定义的每个ClientServerOperation角色方法拥有一个案例标签，其中：


  The integer value of the case label shall be a 32-bit hash of the ClientServerOperation's shortName. The binding implementation shall compute the hash as specified in section 7.5.1.1.2 of [21]. Representations of the service interface in OMG IDL [23] shall define 32-bit signed integer constants (i.e., const int32 \<svcId\>Method_\<methodName\> _Hash; where \<methodName\> is the shortName of the ClientServerOperation) to simplify the representation of the union cases (see below).

> 将情况标签的整数值应为ClientServerOperation短名称的32位哈希值。绑定实现应按照[21]第7.5.1.1.2节中的说明计算哈希值。OMG IDL [23]中的服务接口表示应定义32位有符号整数常量（即const int32 \<svcId\>Method_\<methodName\> _Hash;其中\<methodName\>是ClientServerOperation的短名称）以简化联合情况的表示（见下文）。

- The member name for the case label shall be the shortName of the ClientServerOperation.

- The type for each case label shall be \<svcId\>Method_\<methodName\> _Result, which shall be constructed as specified in section 7.5.1.1.4 of [21] (see below).

> 每个情况标签的类型应为<svcId>Method_<methodName>_Result，其构造方式应按照[21]第7.5.1.1.4节中的规定进行。

The IDL definition of \<svcId\>Method_Return is the following:

```
1 union \<svcId\>Method_Return switch(int32) {

2 default:

3 dds::rpc::UnknownOperation unknownOp;

4 case \<svcId\>Method_\<method0Name\>_Hash:

5 \<svcId\>Method_\<method0Name\>_Result \<method0Name\>;

6 case \<svcId\>Method_\<method1Name\>_Hash:

7 \<svcId\>Method_\<method1Name\>_Result \<method1Name\>;

8 // \...

9 case \<svcId\>Method_\<methodNName\>_Hash:

10 \<svcId\>Method_\<methodNName\>_Result \<methodNName\>

11 };
```


As defined in section 7.5.1.1.5 of [21], the \<svcId\>Method_\<methodName\>_Result union shall be constructed as follows:

> 根据[21]第7.5.1.1.5节的定义，\<svcId\>Method_\<methodName\>_Result联合体应构造如下：

- The union discriminator shall be a 32-bit signed integer.
- The union shall have a case with label dds::RETCODE_OK to represent a successful return:


  The value of RETCODE_OK shall be 0x00, as specified in section 2.3.3 of [18].

> 值RETOCDE_OK应为0x00，如[18]第2.3.3节所指定。
  The successful case shall have a single member named result of type

\<svcId\>Method_\<methodName\>_Out (see below).


- The union shall also have a case with label dds::RETCODE_ERROR to represent the ApApplicationError the method may return:

> 联盟还应该有一个标记为dds::RETCODE_ERROR的情况来表示方法可能返回的ApApplicationError。


  The value of RETCODE_ERROR shall be 0x01, as specified in section 2.3.3 of [18].

> RETCODE_ERROR的值应为0x01，如[18]第2.3.3节所指定。

  The error case shall have a single member named error of type ara::core::ErrorCode (see [[SWS_CM_10428](#_bookmark83)]).

> 错误情况应该有一个名为error的单个成员，类型为ara::core::ErrorCode（参见[[SWS_CM_10428](#_bookmark83)）。


The IDL representation of \<svcId\>Method_\<methodName\>_Result is the following:

> \<svcId\>方法_\<methodName\>_结果的IDL表示如下：

```
1 union \<svcId\>Method_\<methodName\>_Result switch(int32) {

2 case dds::RETCODE_OK:

3 \<svcId\>Method_\<methodName\>_Out result;

4 case dds::RETCODE_ERROR:

5 ara::core::ErrorCode error;

6 };
```


Lastly, as defined in section 7.5.1.1.5 of [21], the \<svcId\>Method_\<methodName\> _Out structure be constructed as follows:

> 最后，根据[21]第7.5.1.1.5节的定义，\<svcId\>Method_\<methodName\> _Out结构如下构建：


- The structure shall contain as members all the ArgumentDataPrototypes of the ClientServerOperation with direction set to out or inout.

> 结构应包含所有带有方向设置为out或inout的ClientServerOperation的ArgumentDataPrototype成员。

- The members of the structure representing out and inout arguments shall appear in the structure in the same order as they were declared.

> 成员代表输入和输出参数的结构体应按照它们声明的顺序出现在结构体中。

- If the method has no out, and no inout arguments, the structure shall contain a single member named dummy of type dds::rpc::UnusedMember (in accordance with section 7.5.1.1.1 of [21]).

> 如果方法没有输出，也没有inout参数，结构应该包含一个名为dummy的单个成员，类型为dds::rpc::UnusedMember（符合[21]的第7.5.1.1.1节）。


The IDL representation of \<svcId\>Method_\<methodName\>_Out is the following:

> \<svcId\>Method_\<methodName\>_Out 的 IDL 表示如下：

```
1 struct \<svcId\>Method_\<methodName\>_Out {

2 \<ArgumentDataPrototype[0]\>;

3 \<ArgumentDataPrototype[1]\>;

4 // \...

5 \<ArgumentDataPrototype[n]\>;

6 };
```


The resulting Reply Topic data type shall be encoded according to the DDS serialization rules. Unions, such as the \<svcId\>Method_\<methodName\>_Result union, shall be serialized as specified in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00200)*

> 结果的回复主题数据类型应按照DDS序列化规则进行编码。像\<svcId\>Method_\<methodName\>_Result联合体这样的联合体应按照[20]第7.4.3.5节中的规定进行序列化。（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00200）


**[SWS_CM_10431] Mapping of ara::core::ErrorCode** *[*A ApApplicationError shall be represented according to the following IDL [23]:

> **[SWS_CM_10431] ara::core::ErrorCode 的映射** *[*A ApApplicationError 应该根据以下IDL [23] 表示：

```
1 module dds {

2 module ara {

3 module core {

4

5 struct ErrorCode {

6 uint64 error_domain_value;

7 int32 error_code;

8 };

9

10 }; // module core

11 }; // module ara

12 }; // module dds
```

Where:


**error_domain_value** is a 64-bit unsigned integer representing the ApApplicationErrorDomain. value, to which the raised ApApplicationError belongs.

> **error_domain_value** 是一个64位无符号整数，代表ApApplicationErrorDomain的值，发生的ApApplicationError属于该值。


**error_code** is a 32-bit signed integer representing the ApApplicationError. errorCode, which is represented on binding level as ara::core::ErrorCode::Value().

> **error_code** 是一个32位带符号整数，表示ApApplicationError。errorCode，它在绑定层表示为ara::core::ErrorCode::Value()。


ara::core::ErrorCode shall be serialized according to the DDS serialization rules. Since IDL modules are translated to C++ namespaces during IDL to C++ code generation, the additional top-level module dds prevents clashing of the generated C++ type with ara::com's own ara::core::ErrorCode definition.*♩(RS_CM_00204)*

> ara::core::ErrorCode应根据DDS序列化规则进行序列化。由于IDL模块在IDL到C++代码生成期间被转换为C++命名空间，因此额外的顶级模块dds可以防止生成的C++类型与ara::com自己的ara::core::ErrorCode定义发生冲突。*♩(RS_CM_00204)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 负载序列化规则在第7.5.3.7节中定义。


**[SWS_CM_11103] Creating a DataWriter to handle method requests on the client side** *[*The DDS binding shall create a DDS DataWriter for the Request Topic associated with the methods of the ServiceInterface (see [[SWS_CM_11101](#_bookmark249)]) upon proxy instantiation.

> 在代理实例化时，DDS绑定应创建一个DDS DataWriter用于与服务接口的方法相关联的请求主题。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service instance it is bound to, the binding implementation shall use the DDS Publisher created in [[SWS_CM_11009](#_bookmark210)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataWriter.

> 如果提供或消费的服务实例已经使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION来宣传，为了确保代理只与它绑定的服务实例通信，绑定实现应该使用[[SWS_CM_11009](#_bookmark210)]中创建的DDS发布者（其分区名为“ara.com：//services/ \ <svcId \> _ \ <reqSvcInId \>”）来创建DataWriter。

The DataWriter shall be configured as follows:


- DataWriterQos shall be set as specified in the Manifest, where the DdsRequiredServiceInstance element defines the qosProfile that shall be used.

> 数据写入者Qos应根据清单中的指定设置，其中DdsRequiredServiceInstance元素定义了要使用的qosProfile。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11104] Creating a DataReader to handle method responses on the client side** *[*The DDS binding shall create a DDS DataReader for the Reply Topic associated with the methods of the ServiceInterface (see [[SWS_CM_11102](#_bookmark250)]) upon proxy instantiation.

> 在代理实例化时，DDS绑定应为与服务接口的方法相关联的回复主题创建一个DDS数据读取器（参见[[SWS_CM_11102](#_bookmark250)])。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service instance it is bound to, the binding implementation shall use the DDS Subscriber created in [[SWS_CM_11009](#_bookmark210)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataReader.

> 如果提供或消费的服务实例已经使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION进行广告，为了确保代理只与它绑定的服务实例进行通信，绑定实现应使用[[SWS_CM_11009](#_bookmark210)]中创建的DDS订阅者（其分区名为“ara.com：//services/\<svcId\>_\<reqSvcInId\>”）来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsRequiredServiceInstance element defines the qosProfile that shall be used.

> 数据读取器Qos将按照清单中的指定设置，其中DdsRequiredServiceInstance元素定义将使用的qosProfile。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215)*


**[SWS_CM_11105] Creating a DataReader to handle method requests on the server side** *[*The DDS binding shall create a DDS DataReader for the Request Topic associated with the methods of the ServiceInterface (see [[SWS_CM_11101](#_bookmark249)]) as part of the OfferService() operation (see [[SWS_CM_11001](#_bookmark197)]).

> [SWS_CM_11105] 在服务端处理方法请求时创建一个数据读取器 *[*DDS绑定应在OfferService（参见[[SWS_CM_11001](#_bookmark197)）操作时为与服务接口相关的请求主题创建一个DDS数据读取器（参见[[SWS_CM_11101](#_bookmark249)）。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, the binding shall use the DDS Subscriber created in [[SWS_CM_11002](#_bookmark198)] (whose partition name is \"ara.com://services/\<svcId\>_\<svcInId\>\") to create the DataReader.

> 如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，则绑定应使用在[[SWS_CM_11002](#_bookmark198)]中创建的DDS订阅者（其分区名称为“ara.com：//services/ \ <svcId \> \ <svcInId \>”）来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsProvidedServiceInstance element defines the qosProfile that shall be used.

> DataReaderQos应按照Manifest中的规定进行设置，其中DdsProvidedServiceInstance元素定义了要使用的qosProfile。

- Listener and StatusMask shall be set according to the value of MethodCallProcessingMode that was selected in the constructor of the ServiceSkeleton class:

> 侦听器和状态掩码应根据在ServiceSkeleton类的构造函数中选择的MethodCallProcessingMode的值进行设置。


  For MethodCallProcessingMode = kEvent or kEventSingleThread, Listener shall be set to an instance of the DataReaderListener class specified in [[SWS_CM_11110](#_bookmark257)], and StatusMask shall be set to DATA_AVAILABLE_STATUS.

> 对于MethodCallProcessingMode = kEvent或kEventSingleThread，Listener应设置为[[SWS_CM_11110](#_bookmark257)]中指定的DataReaderListener类的实例，而StatusMask应设置为DATA_AVAILABLE_STATUS。

  For MethodCallProcessingMode = kPoll, Listener shall remain unset, and StatusMask shall be set to STATUS_MASK_NONE.

> 对于MethodCallProcessingMode = kPoll，Listener应保持未设置，而StatusMask应设置为STATUS_MASK_NONE。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11106] Creating a DataWriter to handle method responses on the server side** *[*The DDS binding shall create a DDS DataWriter for the Reply Topic associated with the methods of the ServiceInterface (see [[SWS_CM_11102](#_bookmark250)]) as part of the OfferService() operation (see [[SWS_CM_11101](#_bookmark249)]).

> 该DDS绑定应在OfferService（参见[[SWS_CM_11101](#_bookmark249)）操作期间为与服务接口的方法相关联的回复主题创建一个DDS数据写入器（参见[[SWS_CM_11102](#_bookmark250)]）。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, the binding implementation shall use the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)] (whose partition name is \"ara.com://services/\<svcId\>_\<svcInId\>\") to create the DataWriter.

> 如果提供或消费的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，绑定实现应使用在[[SWS_CM_11002](#_bookmark198)]中创建的DDS发布者（其分区名称为“ara.com：//services/ \ <svcId \>_ \ <svcInId \>”）创建DataWriter。

The DataWriter shall be configured as follows:


- DataWriterQos shall be set as specified in the Manifest, where the DdsProvidedServiceInstance element defines the qosProfile that shall be used.

> 数据写入者的服务质量（DataWriterQos）应按照清单中的规定设置，其中DdsProvidedServiceInstance元素定义了应使用的qosProfile。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11107] Calling a service method from the client side** *[*When instructed to call a method from the client side, the DDS binding shall construct a new sample of the Request Topic---an instance of the Request Topic data type defined in [[SWS_CM_11101](#_bookmark249)])---as follows:

> 当指示从客户端调用方法时，DDS binding 将构造一个新的请求主题样本---[[SWS_CM_11101](#_bookmark249)中定义的请求主题数据类型的实例]---如下所示：


- To initialize the RequestHeader object, requestId shall be set by the underlying DDS implementation according to the rules specified in [21]. instanceName shall be set by the binding implementation to the serviceInstanceId of the remote service instance.

> 要初始化RequestHeader对象，requestId应由根据[21]中指定的规则由底层DDS实现设置。instanceName应由绑定实现设置为远程服务实例的serviceInstanceId。

- To initialize the \<svcId\>Method_Call object, the binding implementation shall first select the appropriate union case (as specified in [[SWS_CM_11101](#_bookmark249)], the hash of the method's name is the union discriminator that selects the union case), and then set accordingly the structure containing all the in and inout arguments.

> 要初始化\<svcId\>Method_Call对象，绑定实现首先应选择适当的联合情况（如[[SWS_CM_11101](#_bookmark249)中所述，方法名的哈希值是选择联合情况的联合鉴别器），然后设置相应的结构，其中包含所有的输入和输入输出参数。


That sample shall then be passed as a parameter to the write() method of the DDS DataWriter created in [[SWS_CM_11103](#_bookmark251)] to handle method requests on the client side, which shall serialize the sample according to the DDS serialization rules, and publish it over DDS.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213)*

> 那个样本然后将作为参数传递给在[[SWS_CM_11103](#_bookmark251)]中创建的DDS DataWriter的write()方法，以处理客户端的方法请求，该方法将根据DDS序列化规则序列化该样本，并通过DDS发布。*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 负载序列化规则在[7.5.3.7](#serialization-of-payload-3)节中定义。


**[SWS_CM_11108] Notifying the client of a response to a method call** *[*To notify the client application of a response as a result of a method call, the DDS binding implementation shall invoke either the set_value() operation or the SetError() operation of the ara::core::Promise corresponding to the ara::core::Future that is returned to the caller.

> 为了通知客户端应用程序关于方法调用的响应，DDS绑定实现应调用ara::core::Promise的set_value()操作或SetError()操作，该ara::core::Future被返回给调用者。


If the discriminator of the \<svcId\>Method_\<methodName\>_Result union holding the response for the specific method call in the received DDS Reply Topic sample is dds::RETCODE_OK (i.e., 0 as defined in [18]), the binding implementation shall call the ara::core::Promise's set_value() operation (see [SWS_CORE_00345] and [SWS_CORE_00346]) using the members representing the out and inout arguments in the corresponding \<svcId\>Method_\<methodName\>_Out result (see [[SWS_CM_11102](#_bookmark250)]).

> 如果接收到的DDS回复主题样本中特定方法调用的\<svcId\>Method_\<methodName\>_Result联合的鉴别器是dds::RETCODE_OK（即，[18]中定义的0），则绑定实现应调用ara :: core :: Promise的set_value（）操作（请参见[SWS_CORE_00345]和[SWS_CORE_00346]），使用相应的\<svcId\>Method_\<methodName\>_Out结果中表示的out和inout参数（请参见[[SWS_CM_11102](#_bookmark250)）。


Else, for any other discriminator value, the binding implementation shall call the ara::core::Promise's SetError() operation (see [SWS_CORE_00353]) with the corresponding ara::core::ErrorCode, which is based on the corresponding ApApplicationError (see [[SWS_CM_11102](#_bookmark250)]).

> 如果是其他调度器值，绑定实现应调用ara :: core :: Promise的SetError（）操作（参见[SWS_CORE_00353]），其中的ara :: core :: ErrorCode基于相应的ApApplicationError（参见[SWS_CM_11102]）。


In either case, the associated set operation shall be performed upon the reception of a new Reply Topic sample by the corresponding DDS DataReader (see [[SWS_CM_11104](#_bookmark252)]). The DDS binding shall use the DataReader's take() to process the sample. Moreover, to correlate a request with a response, the binding shall compare the header.relatedRequestId of the received sample with the original requestId that was set and sent in [[SWS_CM_11107](#_bookmark255)][11](#_bookmark258) [12](#_bookmark259).

> 无论哪种情况，在接收到新的回复主题样本时，都应对相应的DDS DataReader执行相关的集合操作（参见[[SWS_CM_11104](#_bookmark252)]）。DDS绑定应使用DataReader的take（）来处理样本。此外，为了将请求与响应关联起来，绑定应将接收到的样本的header.relatedRequestId与[[SWS_CM_11107](#_bookmark255)][11](#_bookmark258)[12](#_bookmark259)中设置并发送的原始请求ID进行比较。


If a received relatedRequestId does not correspond to a requestId that has been sent by the client, the response shall be discarded.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215)*

> 如果收到的relatedRequestId与客户端发送的requestId不匹配，则应丢弃响应。（RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215）


**[SWS_CM_11109] Processing a method call on the server side (event driven)** *[*In case a MethodCallProcessingMode of either kEvent or kEventSingleThread has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the binding implementation shall create a DataReaderListener to process the requests asynchronously---as described in [[SWS_CM_11110](#_bookmark257)]--and attach an instance of it to the DataReader processing the requests in accordance with [[SWS_CM_11105](#_bookmark253)]. The listener is responsible for identifying the method that shall process the request and dispatch it (see [[SWS_CM_11110](#_bookmark257)]).*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*

> 如果传递给ServiceSkeleton构造函数的MethodCallProcessingMode是kEvent或kEventSingleThread（参见[[SWS_CM_00130](#_bookmark525)），绑定实现应创建一个DataReaderListener以异步处理请求---如[[SWS_CM_11110](#_bookmark257)]中所述---并根据[[SWS_CM_11105](#_bookmark253)]将其实例附加到处理请求的DataReader上。侦听器负责识别将处理请求的方法并分派它（参见[[SWS_CM_11110](#_bookmark257)]）。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11110] Creating a DataReaderListener to process asynchronous requests on the server side** *[*According to [[SWS_CM_11105](#_bookmark253)], a MethodCallProcessingMode of either kEvent or kEventSingleThread requires the instantiation of a DataReaderListener to process asynchronously requests on the server side. The resulting listener shall derive from the standard DataReaderListener class [18], specifying that the data type of the samples to be handled is the Request Topic data type defined in [[SWS_CM_11101](#_bookmark249)].

> 根据[SWS_CM_11105]（＃_bookmark253），kEvent或kEventSingleThread的MethodCallProcessingMode需要实例化一个DataReaderListener来异步处理服务器端的请求。结果侦听器应该从标准DataReaderListener类[18]派生，指定要处理的样本的数据类型是[SWS_CM_11101]（＃_bookmark249）中定义的请求主题数据类型。


The DataReaderListener shall implement the following methods according to the specified instructions:

> 数据读取器侦听器应根据指定的说明实现以下方法：


- An on_data_available() method responsible for reading the received requests from the DataReader's cache---using the take() operation---and dispatching them to the appropriate methods for processing. To identify the method of the ServiceSkeleton class that shall process each request, on_data_available() shall use the union discriminator of the \<svcId\> Method_Call and provide the destination method with the specific ArgumentDataPrototypes in the union case.

> 一个on_data_available()方法负责从DataReader的缓存中读取接收到的请求，使用take()操作，并将其分派到适当的方法进行处理。为了确定ServiceSkeleton类中用于处理每个请求的方法，on_data_available()应使用\<svcId\> Method_Call的联合识别符，并在联合情况下提供特定的ArgumentDataPrototypes给目标方法。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


11The RPC over DDS specification [21] does not mandate a specific mechanism or context to invoke the take() operation on the DataReader that subscribes to method replies.Implementers of this specification may therefore follow different approaches to address this issue.

> RPC 覆盖 DDS 规范[21] 不强制采用特定的机制或上下文来调用订阅方法回复的 DataReader 的 take() 操作。因此，实施此规范的实现者可以采用不同的方法来解决此问题。


12For instance, a proxy could provide a ara::core::Map\<dds::SampleIdentity, ara::core::Promise\<T\> \> to hold the ara::core::Promises assigned to every request (identified by their dds::SampleIdentity requestId), and install a DataReaderListener (on the DataReader created in [[SWS_CM_11104](#_bookmark252)]) with an on_data_available() method that could call the setter of the corresponding ara::core::Promise using the relatedRequestId of the received Reply Topic sample to address it. Alternatively, a compliant solution could also call take() in the context of a std::async using a dds::core::Waitset [18] to block until the reception of the expected sample.

> 举例来说，代理可以提供ara::core::Map\<dds::SampleIdentity，ara::core::Promise\<T\> \>来保存分配给每个请求（由它们的dds :: SampleIdentity requestId标识）的ara :: core :: Promises，并安装DataReaderListener（在[[SWS_CM_11104]（#_bookmark252）中创建的DataReader），其on_data_available（）方法可以使用接收到的Reply Topic样本的relatedRequestId调用相应的ara :: core :: Promise的setter以对其进行地址。另外，一个符合标准的解决方案也可以在std :: async的上下文中调用take（），以使用dds :: core :: Waitset [18]阻塞，直到接收到预期的样本。


**[SWS_CM_11111] Processing a method call on the server side (polling)** *[*In case a MethodCallProcessingMode of kPoll has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the ProcessNextMethodCall method is be responsible for calling take() on the DataReader processing the Request Topic associated with the service (see [[SWS_CM_11105](#_bookmark253)]). ProcessNextMethodCall, shall take only the first sample from the DataReader's cache and dispatch the call the appropriate service method (see [[SWS_CM_00191](#_bookmark537)]) of the ServiceSkeleton class according to the value of the of the discriminator of the \<svcId\>Method_Call union and provide the destination method with the specific ArgumentDataPrototypes in the union case.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*

> **[SWS_CM_11111] 在服务器端处理方法调用（轮询）** *[*如果将kPoll的MethodCallProcessingMode传递给ServiceSkeleton的构造函数（参见[[SWS_CM_00130](#_bookmark525)），则ProcessNextMethodCall方法负责调用与服务关联的请求主题上的DataReader处理（参见[[SWS_CM_11105](#_bookmark253)）。ProcessNextMethodCall只能从DataReader的缓存中取出第一个样本，并根据<svcId>Method_Call联合的鉴别符的值将调用分派到ServiceSkeleton类的适当服务方法（参见[[SWS_CM_00191](#_bookmark537)），并提供特定的联合情况下的ArgumentDataPrototypes给目标方法。*♩（RS_CM_00204，RS_CM_00212，RS_CM_00213）*


**[SWS_CM_11112] Sending a method call response from the server side** *[*The binding implementation shall send a response upon the return (either as a result of a normal return or through one of the possible ApApplicationErrors referenced by the ClientServerOperation in the role possibleApError) of the service method (see [[SWS_CM_10306](#_bookmark77)] and [[SWS_CM_10307](#_bookmark78)]).

> 实现绑定应在服务方法返回（无论是正常返回还是通过客户端服务操作中在可能的ap错误中引用的其中一个）时发送响应（参见[[SWS_CM_10306](#_bookmark77)]和[[SWS_CM_10307](#_bookmark78)）。


To send the response, the DDS binding shall construct a new sample of the Reply Topic ---an instance of the Reply Topic data type defined in [[SWS_CM_11102](#_bookmark250)])---as follows:

> 为了发送响应，DDS 绑定应构造一个新的 Reply Topic 样本（根据 [[SWS_CM_11102](#_bookmark250) 中定义的 Reply Topic 数据类型），如下所示：


- To initialize the ReplyHeader object, relatedRequestId shall be set to the value of the header.requestId attribute of the request that triggered the method call (see [[SWS_CM_11107](#_bookmark255)]).

> 要初始化ReplyHeader对象，相关的RequestId应设置为触发方法调用的请求的header.requestId属性的值（参见[[SWS_CM_11107](#_bookmark255)]）。
- To initialize the \<svcId\>Method_Return object, the binding implementation shall:


  Select the appropriate union case (as specified in [[SWS_CM_11102](#_bookmark250)], the hash of the method's name is the union discriminator that selects the union case).

> 选择适当的联合情况（如[[SWS_CM_11102](#_bookmark250)中所述），方法名称的哈希值是用于选择联合情况的联合判别器。

  Set the \<svcId\>Method_\<methodName\>_Result union selecting its union discriminator based on whether the operation generated the correct result or raised an ApApplicationError:

> 设置\<svcId\>Method_\<methodName\>_Result联合，根据操作是否产生正确结果或引发ApApplicationError来选择其联合鉴别器。


*∗* If operation generated the correct result, the binding shall select the union case for dds::RETCODE_OK and set the \<svcId\>Method_ \<methodName\>_Out structure with all the out and inout arguments.

> 如果操作生成了正确的结果，绑定应该为dds :: RETCODE_OK选择联合情况，并使用所有的输出和inout参数设置\<svcId\>Method_\<methodName\>_Out结构。


*∗* Otherwise, if the operation raised an ApApplicationError, the binding shall select the union case 0x01 and construct the corresponding ara::core::ErrorCode (see [[SWS_CM_11102](#_bookmark250)]).

> 如果操作引发了ApApplicationError，绑定应选择联合情况0x01并构造相应的ara :: core :: ErrorCode（参见[[SWS_CM_11102]（#_bookmark250）]）。


The sample shall then be passed as a parameter to the write() method of the DDS DataWriter created in [[SWS_CM_11105](#_bookmark253)] to handle method responses on the server side, which shall serialize the sample according to the DDS serialization rules, and publish it over DDS.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213)*

> 将样本作为参数传递给在[[SWS_CM_11105](#_bookmark253)]中创建的DDS DataWriter的write()方法，以处理服务器端的方法响应，该方法将根据DDS序列化规则序列化样本，并通过DDS发布。♩（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213）


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 负载序列化规则在第7.5.3.7节定义。

### Handling Fields


**[SWS_CM_11130] Mapping Fields with hasNotifier attribute to DDS Topics** *[*The DDS binding shall assign a DDS Topic to every Field defined in the ServiceInterface in the role field with hasNotifier = true to enable its notification semantics over DDS. The equivalent DDS Topic shall be configured as follows:

> **[SWS_CM_11130] 将具有hasNotifier属性的映射字段到DDS主题** *[*DDS绑定应将DDS主题分配给服务接口中角色字段中定义的每个字段，其中hasNotifier = true，以启用其DDS上的通知语义。相应的DDS主题应按如下配置：

- The Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SERVICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\> .\<Minor\>/\<TopicName\>

> 如果提供或使用的服务实例使用 identifier_type 属性设置为 SERVICE_INSTANCE_RESOURCE_PARTITION 或 SERVICE_INSTANCE_RESOURCE_INSTANCE_ID，那么主题名称应设置为 ara.com://services/\<InterfaceID\>/\<Major\> .\<Minor\>/\<TopicName\>。


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供或使用的服务实例使用 identifier_type 属性设置为 SERVICE_INSTANCE_RESOURCE_PARTITION，则此主题的样本应通过其父发布者和订阅者对象包括以下分区在 PARTITION QoS 策略中的数据写入器和数据读取器发送和接收：ara.com://services/\<InterfaceID\>/\<InstanceId\>。

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供或使用的服务实例使用identifier_type属性设置为SERVICE_INSTANCE_TOPIC_PREFIX，那么主题名称应设置为ara.com：//services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>。
- Where:


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>** 是DdsServiceInterfaceDeployment的服务接口ID的值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **<InstanceID>**是DdsProvidedServiceInstance服务实例的serviceInstanceId或DdsRequiredServiceInstance的requiredServiceInstanceId的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。


**\<TopicName\>** is the value of DdsEventDeployment.topicName defined for DdsFieldDeployment in the notifier role

> **\<TopicName\>**是为Notifier角色定义的DdsFieldDeployment中的DdsEventDeployment.topicName的值。


- The Topic Data Type shall be defined as specified in [[SWS_CM_11131](#_bookmark262)], and shall be registered under the equivalent data type's name.

> 数据类型应按照[[SWS_CM_11131](#_bookmark262)]中的规定来定义，并在等效的数据类型名称下注册。

*♩(RS_CM_00204, RS_CM_00201)*


**[SWS_CM_11131] Field Notifier DDS Topic data type definition** *[*The data type of a DDS Topic representing a Field Notifier shall be constructed according to the following IDL definition:

> **[SWS_CM_11131] 字段通知器 DDS 主题数据类型定义** *[*表示字段通知器的 DDS 主题的数据类型应根据以下 IDL 定义构造：

```
1 struct \<fieldTypeName\>FieldNotifierType {

2 \@key uint16 instance_id;

3 \<fieldTypeName\> data;

4 };
```

Where:

**\<fieldTypeName\>** is the Cpp Implementation Data Type symbol [24].


**instance_id** is a \@key member of the type, which identifies all samples with the same instance_id as samples of the same Topic Instance.

> **instance_id** 是一个@key成员类型，它标识出所有与相同instance_id的样本属于同一个主题实例。


**data** is the actual value of the field, which shall be constructed and encoded according to the DDS serialization rules. The \@external annotation is optionally allowed, for cases where references yield implementation benefits over values.

> **数据**是字段的实际值，应根据DDS序列化规则构造和编码。可以选择性地使用\@external注释，以便引用能够比值提供实现优势。

*♩(RS_CM_00204, RS_CM_00201)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 规则的DDS序列化在[7.5.3.7]（＃序列化有效负载3）部分定义。


**[SWS_CM_11132] Mapping of Update method** *[*When instructed to transmit a field notification message, the DDS binding shall construct a new sample of the equivalent DDS Topic data type (see [[SWS_CM_11131](#_bookmark262)]) as follows:

> **[SWS_CM_11132] 更新方法的映射** *[*按照指示传输字段通知消息时，DDS 绑定应构建相应的 DDS 主题数据类型的新样本（参见[[SWS_CM_11131](#_bookmark262)])，如下所示：


- The Instance Id field (instance_id) shall be derived from the Manifest, where the DdsProvidedServiceInstance element defines the serviceInstanceId.

> 字段“实例ID”（instance_id）应从清单中派生，其中DdsProvidedServiceInstance元素定义服务实例ID。
- The Data field (data) shall point to the data input parameter of the Update() method.


That sample shall be then passed as a parameter to the write() method of the DDS DataWriter associated with the field, which shall serialize the sample according to the DDS serialization rules specified, and publish it over DDS.*♩(RS_CM_00204, RS_CM_00201)*

> 那个样本应该被作为参数传递给与该字段相关联的DDS DataWriter的write（）方法，该方法应根据指定的DDS序列化规则对样本进行序列化，并通过DDS进行发布。*♩（RS_CM_00204，RS_CM_00201）*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 规则DDS序列化在第7.5.3.7节定义（#序列化有效负载3）。


**[SWS_CM_11133] Mapping of Subscribe method** *[*When instructed to subscribe to a field, the DDS binding shall create a DDS DataReader to handle the subscription using the DDS Subscriber created for the proxy in [[SWS_CM_11002](#_bookmark198)]. The rules to create the DataReader are specified in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00103)*

> **[SWS_CM_11133] 订阅方法的映射** *[*当指示订阅某个字段时，DDS 绑定应使用为代理创建的 DDS 订阅者创建 DDS 数据读取器来处理订阅，参见 [[SWS_CM_11002](#_bookmark198)]。创建数据读取器的规则在 [[SWS_CM_11134](#_bookmark263)] 中指定。*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_11134] Creating a DDS DataReader for field subscription** *[*The DDS binding shall create a DDS DataReader for the Topic associated with the field (see [[SWS_CM_11130](#_bookmark261)]). If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service intsance it is bound to, the binding implementation shall use the DDS Subscriber created in [[SWS_CM_11009](#_bookmark210)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataReader.

> 创建DDS数据读取器以订阅字段（参见[[SWS_CM_11130](#_bookmark261)）所关联的主题时，DDS绑定应创建DDS数据读取器。如果提供或消费的服务实例使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，为确保代理只与其绑定的服务实例通信，绑定实现应使用在[[SWS_CM_11009](#_bookmark210)中创建的DDS订阅者（其分区名称为“ara.com：//services/<svcId>_<reqSvcInId>”）来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsFieldQosProps element defines the qosProfile that shall be used. To configure the DataReader's cache size according to the field subscription semantics, the maxSampleCount specified in the Subscribe() method call, the value of the DataReader's HISTORY QoS specified in qosProfile shall be overridden as follows:

> DataReaderQos应按照Manifest中指定的方式设置，其中DdsFieldQosProps元素定义了将要使用的qosProfile。为了根据字段订阅语义配置DataReader的缓存大小，Subscribe（）方法调用中指定的maxSampleCount以及qosProfile中指定的DataReader的HISTORY QoS的值应该被覆盖，如下所示：

  history.kind = KEEP_LAST_HISTORY_QOS
  history.depth = \<maxSampleCount\>


Moreover, to ensure that the proxy received the current value of the field as soon as it creates the subscription, the DataReaders's DURABILITY QoS shall be overridden as follows:

> 此外，为确保代理在创建订阅时立即收到字段的当前值，DataReader的DURABILITY QoS应如下覆盖：

- durability.kind = TRANSIENT_LOCAL_DURABILITY_QOS

Likewise, the RELIABILITY QoS shall be overridden as follows:

- reliability.kind = RELIABLE_RELIABILITY_QOS

```{=html}
<!--->
```


- Listener shall be an instance of the DataReaderListener class specified in [[SWS_CM_11135](#_bookmark264)].

> 侦听器应为[[SWS_CM_11135](#_bookmark264)]中指定的DataReaderListener类的实例。
- StatusMask shall be set to STATUS_MASK_NONE.

*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_11135] Creating a DDS DataReaderListener for field subscription** *[*The DDS implementation shall define a DataReaderListener class to handle field notifications when a new sample is received and/or the matched status of the subscription changes following the instructions specified in [[SWS_CM_11020](#_bookmark235)].

> 在按照[[SWS_CM_11020](#_bookmark235)]中指定的指示下，DDS实现应定义一个DataReaderListener类来处理字段通知，当收到新的样本或订阅的匹配状态发生变化时。


The DataReaderListener class shall specify that the samples to be handled are of the Topic data type specified in [[SWS_CM_11131](#_bookmark262)].*♩(RS_CM_00204, RS_CM_00103)*

> 数据读取器侦听器类应指定要处理的样本是[[SWS_CM_11131](#_bookmark262)]中指定的主题数据类型。*♩(RS_CM_00204, RS_CM_00103)*


**[SWS_CM_11136] Mapping of Unsubscribe method** *[*When instructed to unsubscribe from a field event, the DDS binding shall delete the DataReader associated with the field notifier.*♩(RS_CM_00204, RS_CM_00104)*

> **[SWS_CM_11136] 取消订阅方法的映射** *[*当收到取消订阅字段事件的指示时，DDS 绑定应删除与字段通知者关联的数据读取器。*♩(RS_CM_00204, RS_CM_00104)*


**[SWS_CM_11137] Mapping of GetSubscriptionState method** *[*The GetSubscriptionState method shall be mapped as specified in [[SWS_CM_11022](#_bookmark236)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00106)*

> **[SWS_CM_11137] GetSubscriptionState 方法的映射** *[*GetSubscriptionState 方法应按照[[SWS_CM_11022](#_bookmark236)]中的规定使用[[SWS_CM_11134](#_bookmark263)]中创建的DataReader进行映射。*♩(RS_CM_00204, RS_CM_00106)*


**[SWS_CM_11138] Mapping of GetNewSamples method** *[*The GetNewSamples method shall be mapped as specified in [[SWS_CM_11023](#_bookmark237)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_11138] 将GetNewSamples方法映射如[[SWS_CM_11023](#_bookmark237)]所指定的，使用在[[SWS_CM_11134](#_bookmark263)]中创建的DataReader。♩(RS_CM_00204，RS_CM_00202)**


**[SWS_CM_11139] Mapping of GetFreeSampleCount method** *[*The GetFreeSampleCount method shall be mapped as specified in [[SWS_CM_11024](#_bookmark238)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_11139] 将GetFreeSampleCount方法映射** *[*根据[[SWS_CM_11024](#_bookmark238)]，使用在[[SWS_CM_11134](#_bookmark263)]中创建的DataReader将GetFreeSampleCount方法映射。*♩(RS_CM_00204, RS_CM_00202)*


**[SWS_CM_11140] Mapping of SetReceiveHandler method** *[*The SetReceiveHandler method shall be mapped as specified in [[SWS_CM_11025](#_bookmark239)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00203)*

> **[SWS_CM_11140] 设置接收处理器方法的映射** *[*根据[[SWS_CM_11025](#_bookmark239)]中的规定，使用在[[SWS_CM_11134](#_bookmark263)]中创建的DataReader来映射SetReceiveHandler方法。*♩(RS_CM_00204, RS_CM_00203)*


**[SWS_CM_11141] Mapping of UnsetReceiveHandler method** *[*The UnsetReceiveHandler method shall be mapped as specified in [[SWS_CM_11026](#_bookmark240)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00203)*

> **[SWS_CM_11141] 将UnsetReceiveHandler方法映射** *[*根据[[SWS_CM_11026](#_bookmark240)]中的规定，使用在[[SWS_CM_11134](#_bookmark263)]中创建的DataReader将UnsetReceiveHandler方法映射。*♩(RS_CM_00204, RS_CM_00203)*


**[SWS_CM_11142] Mapping of SetSubscriptionStateHandler method** *[*The SetSubscriptionStateHandler method shall be mapped as specified in [[SWS_CM_11027](#_bookmark241)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00106)*

> **[SWS_CM_11142] 订阅状态处理器方法的映射** *[*根据[[SWS_CM_11027](#_bookmark241)]的规定，使用在[[SWS_CM_11134](#_bookmark263)]中创建的DataReader来映射SetSubscriptionStateHandler方法。*♩(RS_CM_00204, RS_CM_00106)*


**[SWS_CM_11143] Mapping of UnsetSubscriptionStateHandler method** *[*The UnsetSubscriptionStateHandler method shall be mapped as specified in [[SWS_CM_11028](#_bookmark242)] using the DataReader created in [[SWS_CM_11134](#_bookmark263)].*♩(RS_CM_00204, RS_CM_00106)*

> [SWS_CM_11143] 将UnsetSubscriptionStateHandler方法映射如[[SWS_CM_11028](#_bookmark242)]中所述，使用在[[SWS_CM_11134](#_bookmark263)]中创建的DataReader。♩(RS_CM_00204, RS_CM_00106)


**[SWS_CM_11144] Mapping of Field Get/Set methods to DDS Service Methods and Topics** *[*Every ServiceInterface containing one or more Fields defined in the role field with hasGetter or hasSetter attributes set to true shall have an associated DDS Service to enable ara::com Service Instances to offer those operations, and to enable client applications to invoke them. The equivalent DDS Service shall provide the getter and setter methods for all the fields in the corresponding ServiceInterface.

> [SWS_CM_11144] 将字段的Get/Set方法映射到DDS服务方法和主题*[*每个包含一个或多个在角色字段中定义的具有hasGetter或hasSetter属性设置为true的服务接口都应有一个相关的DDS服务，以使ara :: com服务实例提供这些操作，并使客户端应用程序可以调用它们。 相应的DDS服务应为相应服务接口中的所有字段提供getter和setter方法。


In compliance with [[SWS_CM_11100](#_bookmark248)], these DDS Services shall be constructed according to the Basic Service Mapping Profile of the RPC over DDS specification [21]. Thus, every ServiceInterface containing one or more fields with the hasGetter or hasSetter attributes enabled shall trigger the creation of a pair of DDS Topics: a Request Topic and a Reply Topic.

> 符合[[SWS_CM_11100](#_bookmark248)]，这些DDS服务将按照RPC over DDS规范[21]的基本服务映射配置文件进行构建。因此，每个包含一个或多个具有hasGetter或hasSetter属性启用的字段的ServiceInterface将触发创建一对DDS主题：请求主题和回复主题。

The equivalent DDS Request Topic shall be configured as follows:

- The Request Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SERVICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>/\<TopicName\>

> 如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION或SERVICE_INSTANCE_RESOURCE_INSTANCE_ID，那么话题名称应设置为ara.com：//services/ \ <InterfaceID \>/ \ <Major \>/ \ <TopicName \>。


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供的或使用的服务实例已经使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION进行广告，那么这个主题的样本应通过其父发布者和订阅者对象中包含以下分区的PARTITION QoS策略发送和接收：ara.com：//services/\<InterfaceID \>/\<InstanceId \>。

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供的或使用的服务实例已使用 identifier_type 属性设置为 SERVICE_INSTANCE_TOPIC_PREFIX，则主题名称应设置为 ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>。
- Where:


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>**是DdsServiceInterfaceDeployment的服务接口ID的值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **\<InstanceID\>**是DdsProvidedServiceInstance.serviceInstanceId或DdsRequiredServiceInstance.requiredServiceInstanceId的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。


**\<TopicName\>** is the value of DdsServiceInterfaceDeployment. fieldRequestTopicName

> **\<TopicName\>** 是 DdsServiceInterfaceDeployment 的 fieldRequestTopicName 的值。


- The Request Topic Data Type shall be defined as specified in [[SWS_CM_11145](#_bookmark266)]. The equivalent DDS Reply Topic shall be configured as follows:

> 要求主题数据类型应按照[[SWS_CM_11145](#_bookmark266)]中规定的方式定义。相应的DDS回复主题将按以下方式配置：
- The Reply Topic Name shall be derived from the Manifest according to the following rules:


  If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION or SERVICE_INSTANCE_RESOURCE_INSTANCE_ID, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>/\<TopicName\>

> 如果提供或使用的服务实例被广告指定为 identifier_type 属性设置为 SERVICE_INSTANCE_RESOURCE_PARTITION 或 SERVICE_INSTANCE_RESOURCE_INSTANCE_ID，那么话题名称应设置为 ara.com://services/\<InterfaceID\>/\<Major\>.\<Minor\>/\<TopicName\>。


- Additionally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, then samples of this topic shall be sent and received via DataWriters and DataReaders whose respective parent Publisher and Subscriber objects include the following partition in the PARTITION QoS policy: ara.com://services/\<InterfaceID\>/\<InstanceId\>

> 此外，如果提供或使用的服务实例被广告为identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，那么此主题的样本应通过其父发布者和订阅者对象中包含PARTITION QoS策略中的以下分区发送和接收：ara.com：//services/ \ <InterfaceID\>/ \ <InstanceId\>。

- Finally, if the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_TOPIC_PREFIX, then the topic name shall be set to ara.com://services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>

> 最后，如果提供的或使用的服务实例已经使用identifier_type属性设置为SERVICE_INSTANCE_TOPIC_PREFIX，那么主题名称应设置为ara.com：//services/\<InterfaceID\>/\<InstanceID\>/\<TopicName\>。
- Where:


**\<InterfaceID\>** is the value of DdsServiceInterfaceDeployment. serviceInterfaceId

> **\<InterfaceID\>** 是 DdsServiceInterfaceDeployment 的服务接口ID的值。


**\<InstanceID\>** is the value of either DdsProvidedServiceInstance. serviceInstanceId or DdsRequiredServiceInstance.requiredServiceInstanceId

> **<InstanceID>**是DdsProvidedServiceInstance服务实例ID或DdsRequiredServiceInstance所需服务实例ID的值。


**\<Major\> and \<Minor\>** are the values of ServiceInterface.majorVersion and ServiceInterface.minorVersion, respectively

> **\<Major\> 和 \<Minor\>** 分别是 ServiceInterface.majorVersion 和 ServiceInterface.minorVersion 的值。


**\<TopicName\>** is the value of DdsServiceInterfaceDeployment. fieldReplyTopicName

> **\<TopicName\>** 是 DdsServiceInterfaceDeployment 的 fieldReplyTopicName 的值。

- The Reply Topic Data Type shall be defined as specified in [[SWS_CM_11146](#_bookmark267)].

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11145] DDS Service Request Topic data type definition for Field getter and setter operations** *[*As specified in section 7.5.1.1.6 of [21], the Request Topic data type is a structure composed of a Request Header with meta-data and a Call Structure with data. The IDL definition of the Request Topic data type for the DDS Service handling field getters and setters is the following:

> **[SWS_CM_11145] DDS服务请求主题数据类型定义用于字段获取器和设置器操作** *[*根据[21]第7.5.1.1.6节的规定，请求主题数据类型是一个由元数据的请求头和数据的调用结构组成的结构。用于处理字段获取器和设置器的DDS服务的请求主题数据类型的IDL定义如下：

```
1 struct \<svcId\>Field_Request {

2 dds::rpc::RequestHeader header;

3 \<svcId\>Field_Call data;

4 };
```

Where:

**\<svcId\>** is the corresponding serviceInterfaceId.


**dds::rpc::RequestHeader** is the standard Request Header defined in section 1. of [21].

> **dds::rpc::RequestHeader**是在[21]第1节中定义的标准请求头。


**\<svcId\>Field_Call** is the union that holds the value of the input parameters of the corresponding methods, according to the rules specified in section 7.5.1.1.6 of [21].

> **\<svcId\>Field_Call**是根据[21]第7.5.1.1.6节规定的规则，保存相应方法输入参数值的联合。


dds::rpc::RequestHeader shall be constructed as specified in section 7.5.1.1.1 of [21]. On top of that, the binding implementation shall set the instanceName (a member of the RequestHeader structure that specifies the DDS service instance name) to a string representation of the serviceInstanceId of the service instance that provides the fields (which have getters or setters).

> dds::rpc::RequestHeader应按照[21]第7.5.1.1.1节中的规定构造。此外，绑定实现应将instanceName（RequestHeader结构的成员，用于指定DDS服务实例名称）设置为提供字段（具有getter或setter）的服务实例的serviceInstanceId的字符串表示形式。


\<svcId\>Field_Call shall be constructed as specified in section 7.5.1.1.6 of [21].

> 字段调用应按照[21]第7.5.1.1.6节的规定进行构建。

- The name of the union shall be \<svcId\>Field_Call.
- The union discriminator shall be a 32-bit signed integer.

- The union shall have a default case of type dds::rpc::UnknownOperation (defined in section 7.5.1.1.1 of [21]) for unsupported and unknown operations.

> 联盟应对不受支持和未知操作具有dds::rpc::UnknownOperation（在[21]的第7.5.1.1.1节中定义）的默认情况。


- The union shall have a case label for each hasGetter and hasSetter attribute equal to true in the Fields defined in the ServiceInterface with the role field, where:

> 联盟应为ServiceInterface中定义的具有hasGetter和hasSetter属性均为true的字段，具有角色字段，拥有一个案例标签：


  The integer value of the case label shall be a 32-bit hash of the field getter or setter name. That is, \"Get\<fieldName\>\" and \"Set\<fieldName\>\"; where \<fieldName\> is the shortName of the Field. The binding implementation shall compute the hash as specified in section 1. of [21]. Representations of the service interface in OMG IDL [23] shall define 32-bit signed integer constants (i.e., const int32 \<svcId\> Field_Get\<fieldName\>_Hash or const int32 \<svcId\>Field_Set\<fieldName\>_Hash) to simplify the representation of the union cases (see below).

> 整数值的情况标签应该是字段getter或setter名称的32位哈希值。也就是说，"Get\<fieldName\>"和"Set\<fieldName\>"；其中\<fieldName\>是字段的简称。绑定实现应按照[21]第1节中的规定计算哈希值。OMG IDL[23]中的服务接口的表示应定义32位带符号整数常量（即const int32 \<svcId\>Field_Get\<fieldName\>_Hash或const int32 \<svcId\>Field_Set\<fieldName\>_Hash）以简化联合情况的表示（见下文）。


- The member name for the case label shall be get\<FieldName\> for getter methods and set\<FieldName\> for setter methods.

> 会员名称对于标签案例应为get\<FieldName\>，用于获取方法，set\<FieldName\>，用于设置方法。

- The type for each case level shall be \<svcId\>Field_Get\<fieldName\>_In for getter methods, and \<svcId\>Field_Set\<fieldName\>_In for setter methods, which shall be constructed as specified in section 7.5.1.1.4 of [21] (see below).

> 每个案例级别的类型应为\<svcId\>Field_Get\<fieldName\>_In，用于获取方法，以及\<svcId\>Field_Set\<fieldName\>_In，用于设置方法，这些应按照[21]第7.5.1.1.4节中的规定进行构造。

The IDL definition of the \<svcId\>Field_Call union is the following:

```
1 union \<svcId\>Field_Call switch(int32) {

2 default:

3 dds::rpc::UnknownOperation unknownOp;

4 case \<svcId\>Field_Get\<Field0Name\>_Hash:

5 \<svcId\>Field_Get\<Field0Name\>_In get\<Field0Name\>;

6 case \<svcId\>Field_Set\<Field0Name\>_Hash:

7 \<svcId\>Field_Set\<Field0Name\>_In set\<Field0Name\>;

8 case \<svcId\>Field_Get\<Field1Name\>_Hash:

9 \<svcId\>Field_Get\<Field1Name\>_In get\<Field1Name\>;

10 case \<svcId\>Field_Set\<Field1Name\>_Hash:

11 \<svcId\>Field_Set\<Field1Name\>_In set\<Field1Name\>;

12 // \...

13 case \<svcId\>Field_Get\<FieldNName\>_Hash:

14 \<svcId\>Field_Get\<FieldNName\>_In get\<FieldNName\>;

15 case \<svcId\>Field_Set\<FieldNName\>_Hash:

16 \<svcId\>Field_Set\<FieldNName\>_In set\<FieldNName\>;

17 };
```


According to 7.5.1.1.4 of [21], \<svcId\>Field_Set\<FieldName\>_In structures shall contain as member, the corresponding StdCppImplementationDataType representing the value of Field to be set. Conversely, \<svcId\>Field_Get\<FieldName\>_In shall contain a single member named dummy of type dds::rpc::UnusedMember (see section 7.5.1.1.1 of [21]) to indicate that the method has no input parameters.

> 根据[21]的7.5.1.1.4，\<svcId\>Field_Set\<FieldName\>_In结构体应包含一个成员，即相应的StdCppImplementationDataType，表示要设置的字段的值。相反，\<svcId\>Field_Get\<FieldName\>_In应包含一个名为dummy的成员，类型为dds::rpc::UnusedMember（参见[21]的7.5.1.1.1节），以表明该方法没有输入参数。


The resulting Request Topic data type shall be encoded according to the DDS serialization rules. Unions, such as the \<svcId\>Field_Call union, shall be serialized as specified in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*

> 结果请求主题数据类型应按照DDS序列化规则进行编码。像\<svcId\>Field_Call联合体这样的联合体应按照[20]第7.4.3.5节中的规定进行序列化。（RS_CM_00204，RS_CM_00212，RS_CM_00213）


**[SWS_CM_11146] DDS Service Reply Topic data type definition for Field getter and setter operations** *[*As specified in section 7.5.1.1.7 of [21], the Reply Topic data type is a structure composed of a Reply Header with meta-data and a Return Structure with data. The IDL definition of the Reply Topic data type for the DDS Service handling field getters and setters is the following:

> **[SWS_CM_11146] DDS服务回复主题数据类型定义用于字段获取器和设置器操作** *[*根据[21]第7.5.1.1.7节的规定，回复主题数据类型是一个由元数据回复头和数据返回结构组成的结构。处理字段获取器和设置器的DDS服务的回复主题数据类型的IDL定义如下：

```
1 struct \<svcId\>Field_Reply {

2 dds::rpc::ReplyHeader header;

3 \<svcId\>Field_Return data;

4 };
```

Where:

**\<svcId\>** is the corresponding serviceInterfaceId.


**dds::rpc::ReplyHeader** is the standard Reply Header defined in section 7.5.1.1.1 of [21].

> **dds::rpc::ReplyHeader** 是在[21]第7.5.1.1.1节中定义的标准回复头。


**\<svcId\>Field_Return** is the union that holds the return values of the corresponding response, according to the rules specified in section 7.5.1.1.7 of [21].

> **\<svcId\>Field_Return** 是根据[21]第7.5.1.1.7节规定的规则，用于保存相应响应返回值的联合体。


dds::rpc::ReplyHeader shall be constructed as specified in section 7.5.1.1.1 of [21].

> dds::rpc::ReplyHeader 应按照[21]中第7.5.1.1.1节中的规定进行构造。


\<svcId\>Field_Return shall be constructed as specified in section 7.5.1.1.7 of [21]:

> \<svcId\>字段返回应按照[21]第7.5.1.1.7节的规定构建。

- The name of the union shall be \<svcId\>Field_Return.
- The union discriminator shall be a 32-bit signed integer.
- The union shall have a default case of type dds::rpc::UnknownOperation


(defined in section 7.5.1.1.1 of [21]) for unsupported and unknown operations.

> 根据[21]第7.5.1.1.1节定义，用于不支持和未知操作。


- The union shall have a case label for each hasGetter and hasSetter attribute equal to true in the Fields defined in the ServiceInterface with the role field, where:

> 联盟将为ServiceInterface中定义的Fields中每个hasGetter和hasSetter属性均为true的角色字段设置一个标签。


  The integer value of the case label shall be a 32-bit hash of the field getter or setter name. That is, \"Get\<FieldName\>\" and \"Set\<FieldName\>\"; where \<FieldName\> is the shortName of the Field. The binding implementation shall compute the hash as specified in section 7.5.1.1.2 of [21]. Representations of the service interface in OMG IDL [23] shall define 32-bit signed integer constants (i.e., const int32 \<svcId\> Field_Get\<FieldName\>_Hash or const int32 \<svcId\>Field_Set\<FieldName\>_Hash) to simplify the representation of the union cases (see below).

> 整数值的情况标签应该是字段获取器或设置器名称的32位哈希值。也就是，“Get\<FieldName\>”和“Set\<FieldName\>”;其中 \<FieldName\>是字段的短名称。绑定实现应按[21]第7.5.1.1.2节中的规定计算哈希值。OMG IDL [23]中的服务接口的表示应定义32位有符号整数常量（即，const int32 \<svcId\>Field_Get\<FieldName\>_Hash或const int32 \<svcId\>Field_Set\<FieldName\>_Hash），以简化联合情况的表示（见下文）。


- The member name of the case label shall be get\<FieldName\> for getter methods and set\<FieldName\> for setter methods.

> 会员名称的情况标签应为get\<FieldName\>，用于getter方法，以及set\<FieldName\>，用于setter方法。

- The type for each case label shall be \<svcId\>Field_Get\<FieldName\>_Result for getter methods and \<svcId\>Field_Set\<FieldName\>_Result for setter methods, which shall be constructed as specified in section 4. of [21] (see below).

> 每个情况标签的类型应为\<svcId\>Field_Get\<FieldName\>_Result，用于getter方法，以及\<svcId\>Field_Set\<FieldName\>_Result，用于setter方法，这些类型应按照[21]第4节中的规定构造。

The IDL definition of \<svcId\>Field_Return is the following:

```
1 union \<svcId\>Field_Return switch(int32) {

2 default:

3 dds::rpc::UnknownOperation unknownOp;

4 case \<svcId\>Field_Get\<Field0Name\>_Hash:

5 \<svcId\>Field_Get\<Field0Name\>_Result get\<Field0Name\>;

6 case \<svcId\>Field_Set\<Field0Name\>_Hash:

7 \<svcId\>Field_Set\<Field0Name\>_Result set\<Field0Name\>;

8 case \<svcId\>Field_Get\<Field1Name\>_Hash:

9 \<svcId\>Field_Get\<Field1Name\>_Result get\<Field1Name\>;

10 case \<svcId\>Field_Set\<Field1Name\>_Hash:

11 \<svcId\>Field_Set\<Field1Name\>_Result set\<Field1Name\>;

12 // \...

13 case \<svcId\>Field_Get\<FieldNName\>_Hash:

14 \<svcId\>Field_Get\<FieldNName\>_Result get\<FieldNName\>;

15 case \<svcId\>Field_Set\<FieldNName\>_Hash:

16 \<svcId\>Field_Set\<FieldNName\>_Result set\<FieldNName\>;

17 };
```


According with [[SWS_CM_00112](#_bookmark588)] and [[SWS_CM_00113](#_bookmark591)], both getters and setters have the same output parameter. Therefore, in accordance with section 5. of [21], both the \<svcId\>Field_Get\<FieldName\>_Result and \<svcId\> Field_Set\<FieldName\>_Result unions shall be constructed as follows:

> 根据[[SWS_CM_00112](#_bookmark588)]和[[SWS_CM_00113](#_bookmark591)]，getter和setter有相同的输出参数。因此，根据[21]第5节，\<svcId\>Field_Get\<FieldName\>_Result和\<svcId\> Field_Set\<FieldName\>_Result联合应构造如下：

   The union discriminator shall be a 32-bit signed integer.

   The union shall have a case with label dds::RETCODE_OK to represent a successful return:

> 联盟将有一个标签为dds::RETCODE_OK的情况来表示成功的返回。


   The value of RETCODE_OK shall be 0, as specified in section 2.3.3 of [18].

> RETURN_OK的值应该为0，如[18]第2.3.3节所述。
   The successful case shall have a single member named result_ of type


\<svcId\>Field_Get\<FieldName\>_Out to hold the value to be returned to the getter, or type \<svcId\>Field_Set\<FieldName\>_Out to hold the value to be returned to the setter (see below).

> \<svcId\>字段_Get\<FieldName\>_Out用于保存要返回给获取者的值，或者使用\<svcId\>字段_Set\<FieldName\>_Out来保存要返回给设置者的值（见下文）。


The IDL representation of \<svcId\>Field_Get\<FieldName\>_Result is the following:

> IDL 表示 \<svcId\>Field_Get\<FieldName\>_Result 如下：

```
1 union \<svcId\>Field_Get\<FieldName\>_Result switch(int32) {

2 case dds::RETCODE_OK:

3 \<svcId\>Field_Get\<FieldName\>_Out result_;

4 };
```


Likewise, the IDL representation of \<svcId\>Field_Set\<FieldName\>_Result is the following:

> 同样，\<svcId\>Field_Set\<FieldName\>_Result 的IDL表示法如下：

```
1 union \<svcId\>Field_Set\<FieldName\>_Result switch(int32) {

2 case dds::RETCODE_OK:

3 \<svcId\>Field_Set\<FieldName\>_Out result_;

4 };
```


Both types \<svcId\>Field_Get\<FieldName\>_Out and its counterpart \<svcId\> Field_Set\<FieldName\>_Out shall map to a structure with a single member named return_ of the StdCppImplementationDataType representing the value of the corresponding Field.

> 两种类型\<svcId\>Field_Get\<FieldName\>_Out和其对应的\<svcId\> Field_Set\<FieldName\>_Out都应映射到一个名为return_的StdCppImplementationDataType结构，该结构表示相应字段的值。


The resulting Reply Topic data type shall be encoded according to the DDS serialization rules. Unions, such as the \<svcId\>Field_Return union, shall be serialized as specified in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*

> 结果回复主题数据类型应按照DDS序列化规则进行编码。像\<svcId\>Field_Return联合体这样的联合体应按照[20]中7.4.3.5节中的规定进行序列化。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11147] Creating a DataWriter to handle get/set requests on the client side** *[*The DDS binding shall create a DDS DataWriter for the Request Topic associated with the getters and setters of the fields of the ServiceInterface (see [[SWS_CM_11145](#_bookmark266)]) upon proxy instantiation.

> 在代理实例化时，DDS绑定应为与服务接口的字段的获取器和设置器相关联的请求主题创建一个DDS数据写入器（参见[[SWS_CM_11145](#_bookmark266)])。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service instance it is bound to, the binding implementation shall use the DDS Publisher created in [[SWS_CM_11009](#_bookmark210)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataWriter.

> 如果提供或使用的服务实例已经使用标识符类型属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，为了确保代理只与其绑定的服务实例通信，绑定实现应该使用[[SWS_CM_11009](#_bookmark210)]中创建的DDS发布者（其分区名为“ara.com：//services/\<svcId\>_\<reqSvcInId\>\”）来创建DataWriter。

The DataWriter shall be configured as follows:


- DataWriterQos shall be set as specified in the Manifest, where the DdsFieldQosProps element defines the qosProfile that shall be used.

> 数据写入者QoS应按照清单中的指定设置，其中DdsFieldQosProps元素定义了应使用的qosProfile。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11148] Creating a DataReader to handle get/set responses on the client side** *[*The DDS binding shall create a DDS DataReader for the Reply Topic associated with the getters and setters of the fields of the ServiceInterface (see [[SWS_CM_11146](#_bookmark267)]) upon proxy instantiation.

> 在代理实例化时，DDS绑定应为与服务接口的字段的getters和setters相关联的回复主题创建一个DDS数据读取器（参见[[SWS_CM_11146]（#_bookmark267）]）来处理客户端上的get/set响应。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, to ensure the proxy communicates only with the service instance it is bound to, the binding implementation shall use the DDS Subscriber created in [[SWS_CM_11009](#_bookmark210)] (whose partition name is \"ara.com://services/\<svcId\>_\<reqSvcInId\>\") to create the DataReader.

> 如果提供或使用的服务实例已使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，为确保代理只与其绑定的服务实例通信，绑定实现应使用[[SWS_CM_11009](#_bookmark210)]中创建的DDS订阅者(其分区名称为"ara.com://services/<svcId>_<reqSvcInId>")来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsFieldQosProps element defines the qosProfile that shall be used.

> DataReaderQos应根据清单中的规定设置，其中DdsFieldQosProps元素定义了要使用的qosProfile。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215)*


**[SWS_CM_11149] Creating a DataReader to handle get/set requests on the server side** *[*The DDS binding shall create a DDS DataReader for the Request Topic associated with the getters and setters of the fields of the ServiceInterface (see [[SWS_CM_11145](#_bookmark266)]).

> **[SWS_CM_11149] 在服务器端创建一个DataReader处理get / set请求** *[*DDS绑定应为与服务接口字段的getter和setter相关联的请求主题创建一个DDS数据读取器（参见[[SWS_CM_11145]（#_bookmark266））。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, the binding shall use the DDS Subscriber created in [[SWS_CM_11002](#_bookmark198)] (whose partition name is \"ara.com://services/\<svcId\>_\<svcInId\>\") to create the DataReader.

> 如果提供或消费的服务实例已经使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION，则绑定应使用[[SWS_CM_11002](#_bookmark198)]中创建的DDS订阅者（其分区名称为“ara.com：//services/\<svcId\>_\<svcInId\>\”）来创建DataReader。

The DataReader shall be configured as follows:


- DataReaderQos shall be set as specified in the Manifest, where the DdsFieldQosProps element defines the qosProfile that shall be used.

> DataReaderQos应按照清单中的规定进行设置，其中DdsFieldQosProps元素定义了应使用的qosProfile。

- Listener and StatusMask shall be set according to the value of MethodCallProcessingMode that was selected in the constructor of the ServiceSkeleton class:

> 侦听器和状态掩码应根据在ServiceSkeleton类的构造函数中选择的MethodCallProcessingMode的值进行设置。


  For MethodCallProcessingMode = kEvent or kEventSingleThread, Listener shall be set to an instance of the DataReaderListener class specified in [[SWS_CM_11154](#_bookmark274)], and StatusMask shall be set to DATA_AVAILABLE_STATUS.

> 对于MethodCallProcessingMode = kEvent或kEventSingleThread，Listener应设置为[[SWS_CM_11154](#_bookmark274)]中指定的DataReaderListener类的实例，而StatusMask应设置为DATA_AVAILABLE_STATUS。

  For MethodCallProcessingMode = kPoll, Listener shall remain unset, and StatusMask shall be set to STATUS_MASK_NONE.

> 对于MethodCallProcessingMode=kPoll，Listener应保持未设置，而StatusMask应设置为STATUS_MASK_NONE。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11150] Creating a DataWriter to handle get/set responses on the server side** *[*The DDS binding shall create a DDS DataWriter for the Reply Topic associated with the getters and setters of the fields of the ServiceInterface (see [[SWS_CM_11146](#_bookmark267)]).

> 在服务器端处理get/set响应的DDS数据写入器[SWS_CM_11150]：DDS绑定应为与服务接口字段的getters和setters相关联的回复主题创建一个DDS数据写入器（参见[[SWS_CM_11146](#_bookmark267)）。


If the provided or consumed Service Instance has been advertised with the identifier_type attribute set to SERVICE_INSTANCE_RESOURCE_PARTITION, the binding implementation shall use the DDS Publisher created in [[SWS_CM_11002](#_bookmark198)] (whose partition name is \"ara.com://services/\<svcId\>_\<svcInId\>\") to create the DataWriter.

> 如果提供或消费的服务实例已经使用identifier_type属性设置为SERVICE_INSTANCE_RESOURCE_PARTITION进行广告，绑定实现应使用在[[SWS_CM_11002](#_bookmark198)]中创建的DDS发布者（其分区名称为“ara.com：// services / \ <svcId \> _ \ <svcInId \> \”）来创建DataWriter。

The DataWriter shall be configured as follows:


- DataWriterQos shall be set as specified in the Manifest, where the DdsFieldQosProps element defines the qosProfile that shall be used.

> 数据写入者Qos应按照清单中的规定设置，其中DdsFieldQosProps元素定义了应使用的qosProfile。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_11151] Calling get/set method associated with a field from the client side** *[*When instructed to call the Get() or Set() method associated with a Field from the client side, the DDS binding shall construct a new sample of the corresponding Request Topic---an instance of the Request Topic data type defined in [[SWS_CM_11145](#_bookmark266)]---as follows:

> 当指示从客户端调用与字段关联的Get()或Set()方法时，DDS绑定应按照[[SWS_CM_11145](#_bookmark266)]中定义的请求主题数据类型构造一个新的请求主题样本：


- To initialize the RequestHeader object, requestId shall be set by the underlying DDS implementation according to the rules specified in [21]. instanceName shall be set by the binding implementation to the serviceInstanceId of the remote service instance.

> 要初始化RequestHeader对象，根据[21]中指定的规则，应由底层DDS实现设置requestId。instanceName应由绑定实现设置为远程服务实例的serviceInstanceId。

- To initialize the \<svcId\>Field_Call object, the binding implementation shall first select the appropriate union case (as specified in [[SWS_CM_11145](#_bookmark266)], the hash of the field getter/setter's name is the union discriminator that selects the union case). Then,

> 为了初始化\<svcId\>Field_Call对象，绑定实现首先应该选择适当的联合情况（如[[SWS_CM_11145](#_bookmark266)所指定，字段getter/setter的哈希值是用来选择联合情况的辨别器）。


  If the call corresponds to a getter, the binding shall leave the dummy member of the \<svcId\>Field_Get\<FieldName\>_In structure unset.

> 如果调用对应于获取器，则绑定应该不设置\<svcId\>Field_Get\<FieldName\>_In结构体的虚拟成员。

  Else, if the call corresponds to a setter, the binding shall set accordingly the only member of the \<svcId\>Field_Set\<FieldName\>_In structure with the new value for the field.

> 如果调用对应于一个设置器，绑定应该根据\<svcId\>Field_Set\<FieldName\>_In结构体的唯一成员为字段设置新的值。


That sample shall then be passed as a parameter to the write() method of the DDS DataWriter created in [[SWS_CM_11147](#_bookmark268)] to handle get/set requests on the client side, which shall serialize the sample according to the DDS serialization rules, and publish it over DDS.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218)*

> 那个样本然后应作为参数传递给在[[SWS_CM_11147](#_bookmark268)]中创建的DDS DataWriter的write()方法，以处理客户端的get/set请求，它将根据DDS序列化规则序列化该样本，并通过DDS发布它。*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 负载序列化规则在[7.5.3.7]（#serialization-of-payload-3）节中定义。


**[SWS_CM_11152] Notifying the client of the response to the get/set method call** *[*To notify the client application of a response as a result of call to a Get() or Set() method associated with a Field, the DDS binding implementation shall invoke the set_value() operation (see [SWS_CORE_00345] and [SWS_CORE_00346]) with the value of the corresponding result_ member of either the \<svcId\>Field_Get\<FieldName\>_Result structure, for get operations; or \<svcId\> Field_Set\<FieldName\>_Out, for set operations.

> 通知客户端对Get（）或Set（）方法调用的响应，DDS绑定实现应调用set_value（）操作（参见[SWS_CORE_00345]和[SWS_CORE_00346]），其值为相应的result_成员，对于get操作，为\<svcId\>Field_Get\<FieldName\>_Result结构，对于set操作，为\<svcId\>Field_Set\<FieldName\>_Out。


The associated set operation shall be performed upon the reception of a new Reply Topic sample by the corresponding DDS DataReader (see [[SWS_CM_11148](#_bookmark269)]). The DDS binding shall use the DataReader's take() method to process the sample. Moreover, to correlate a request with a response, the binding shall compare the header.relatedRequestsId of the received sample with the original requestId that was sent in [[SWS_CM_11151](#_bookmark272)][13](#_bookmark273). If the relatedRequestId does not correspond to a requestId that has been sent by the client, the response shall be discarded.*♩ (RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218)*

> 当DDS数据读取器收到新的回复主题样本时，应执行相关设置操作（参见[[SWS_CM_11148](#_bookmark269)]）。DDS绑定应使用DataReader的take（）方法来处理样本。此外，为了将请求与响应相关联，绑定应比较收到的样本的header.relatedRequestsId与原始请求Id（在[[SWS_CM_11151](#_bookmark272)][13](#_bookmark273)中发送）。如果relatedRequestId不符合客户端发送的请求ID，则应丢弃响应。*♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00217，RS_CM_00218）*


**[SWS_CM_11153] Processing a get/set method call associated with a field on the server side (event driven)** *[*In case a MethodCallProcessingMode of either kEvent or kEventSingleThread has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the binding implementation shall create a DataReaderListener to process the requests asynchronously---as described in [[SWS_CM_11154](#_bookmark274)]---and attach an instance of it to the DataReader processing the requests for the getters and setters of the ServiceInterface's fields in accordance with [[SWS_CM_11149](#_bookmark270)]. The listener is responsible for identifying the method that shall process the request and dispatch it (see [[SWS_CM_11154](#_bookmark274)]).*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221)*

> 如果将kEvent或kEventSingleThread传递给ServiceSkeleton的构造函数（参见[[SWS_CM_00130](#_bookmark525)），绑定实现将创建一个DataReaderListener来异步处理请求---如[[SWS_CM_11154](#_bookmark274)]中所述---并按照[[SWS_CM_11149](#_bookmark270)]将其实例附加到处理服务接口字段的getter和setter请求的DataReader上。侦听器负责识别要处理请求的方法并将其分派（参见[[SWS_CM_11154](#_bookmark274)]）。*♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00220，RS_CM_00221）*

13See footnotes in [[SWS_CM_11108](#_bookmark256)].



**[SWS_CM_11154] Creating a DataReaderListener to process asynchronous requests for field getters and setters on the server side** *[*According to [[SWS_CM_11149](#_bookmark270)], a MethodCallProcessingMode of either kEvent or kEventSingleThread requires the instantiation of a DataReaderListener to process asynchronously requests on the server side. The resulting listener shall derive from the standard DataReaderListener class [18], specifying that the type of the samples to be handled is the Request Topic data type defined in [[SWS_CM_11145](#_bookmark266)].

> 根据[[SWS_CM_11149](#_bookmark270)]，kEvent或kEventSingleThread的MethodCallProcessingMode需要实例化一个DataReaderListener来异步处理服务器端的字段获取器和设置器的请求。产生的侦听器将从标准DataReaderListener类[18]派生，指定要处理的样本类型是[[SWS_CM_11145](#_bookmark266)]中定义的Request Topic数据类型。


The DataReaderListener shall implement the following method according to the specified instructions:

> 数据读取器侦听器应根据指定的说明实现以下方法：


- An on_data_available() method responsible for reading the received requests from the DataReader's cache---using the take() operation---and dispatching it to the corresponding registered SetHandler or---if it applies--GetHandler (see [[SWS_CM_00114](#_bookmark543)] and [[SWS_CM_00116](#_bookmark546)]). To identify the field of the ServiceSkeleton class, the operation (i.e., Set() or Get()), and therefore the corresponding handler; on_data_available() shall use the union discriminator of the \<svcId\>Field_Call union (see [[SWS_CM_11145](#_bookmark266)]). In the case of a Set() operation, the method shall provide the corresponding SetHandler with the only member of the received \<svcId\>Field_\<FieldName\>_In structure, which contains the new value to be set. In the case of a Get () operation, the binding shall dispatch to the corresponding GetHandler---if it was registered---or to an internal lookup operation for the current value of the field if it was not.

> 一个on_data_available()方法负责从DataReader的缓存中读取接收到的请求（使用take()操作），并将其分派给相应的注册SetHandler或（如果适用）GetHandler（参见[[SWS_CM_00114](#_bookmark543)]和[[SWS_CM_00116](#_bookmark546)]）。为了识别ServiceSkeleton类的字段，操作（即Set()或Get()），因此相应的处理程序；on_data_available()应使用<svcId>Field_Call联合的联合鉴别器（参见[[SWS_CM_11145](#_bookmark266)]）。对于Set()操作，该方法应提供相应的SetHandler，其中包含接收到的<svcId>Field_<FieldName>_In结构的唯一成员，其中包含要设置的新值。对于Get（）操作，绑定应分派给相应的GetHandler（如果已注册）或到字段当前值的内部查找操作，如果未注册。

*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221)*


**[SWS_CM_11155] Processing a get/set method call associated with a field on the server side (polling)** *[*In case a MethodCallProcessingMode of kPoll has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the ProcessNextMethodCall method is responsible for calling take() on the DataReader processing the Request Topic associated with the service (see [[SWS_CM_11145](#_bookmark266)]). ProcessNextMethodCall shall take only the first sample from the DataReader's cache and dispatch it to the corresponding registered SetHandler or---if it applies---GetHandler (see [[SWS_CM_00114](#_bookmark543)] and [[SWS_CM_00116](#_bookmark546)]).

> 如果在ServiceSkeleton的构造函数中传递了kPoll类型的MethodCallProcessingMode（参见[[SWS_CM_00130](#_bookmark525)），那么ProcessNextMethodCall方法负责调用处理请求主题相关服务的DataReader的take()方法（参见[[SWS_CM_11145](#_bookmark266)）。ProcessNextMethodCall应该只从DataReader的缓存中取出第一个样本，并将其分派给相应的已注册的SetHandler或---如果适用---GetHandler（参见[[SWS_CM_00114](#_bookmark543)和[[SWS_CM_00116](#_bookmark546)））。


To identify the field of the ServiceSkeleton class, the operation (i.e., Set() or Get ()), and therefore the corresponding handler, the binding implementation shall use the union discriminator of the \<svcId\>Field_Call union (see [[SWS_CM_11145](#_bookmark266)]). In the case of a Set() operation, the binding shall provide the corresponding SetHandler with the only member of the received \<svcId\>Field_\<FieldName\>

> 为了识别ServiceSkeleton类的字段、操作（即Set()或Get()）以及相应的处理器，绑定实现应使用<svcId>Field_Call联合的联合鉴别符（参见[[SWS_CM_11145](#_bookmark266)]）。如果是Set()操作，绑定应提供相应的SetHandler，其中只包含接收到的<svcId>Field_<FieldName>。


_In structure, which contains the new value to be set. In the case of a Get() operation, the binding shall call the corresponding GetHandler---if it was registered---or dispatch to an internal lookup operation for the current value of the field if it was not.*♩ (RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221)*

> 在结构中，包含要设置的新值。在执行Get（）操作的情况下，绑定应调用相应的GetHandler（如果已注册），或者调度到内部查找操作以获取该字段的当前值（如果未注册）。


**[SWS_CM_11156] Sending a response for a get/set method call associated with a field from the server side** *[*The binding implementation shall send a response upon the return of (1) a SetHandler in the case of a Set() operation; (2) a GetHandler in the case of a Get() operation where a GetHandler has previously been registered; or (3) a lookup operation[14](#_bookmark276) as a result of a Get() operation where no GetHandler was previously registered.

> 实施绑定应在（1）Set（）操作的SetHandler返回时；（2）具有先前注册的GetHandler的Get（）操作时；或（3）由于没有先前注册的GetHandler而导致的查找操作[14]（#_bookmark276）时发送响应。


To send the response, the DDS binding shall construct a new sample of the Reply Topic---an instance of the Reply Topic data type defined in [[SWS_CM_11146](#_bookmark267)]---as follows:

> 为了发送响应，DDS 绑定应该构建一个新的回复主题样本---回复主题数据类型的一个实例，定义在[[SWS_CM_11146](#_bookmark267)]---如下：

- To initialize the ReplyHeader object,


  relatedRequestId shall be set to the value of the header.requestId attribute of the request that triggered the method call (see [[SWS_CM_11151](#_bookmark272)]).

> 相关请求ID应设置为触发方法调用的请求的header.requestId属性的值（参见[[SWS_CM_11151](#_bookmark272)]）。
- To initialize the \<svcId\>Field_Return object, the binding implementation shall:


  Select the appropriate union case (as specified in [[SWS_CM_11146](#_bookmark267)]), the hash of the field's getter/setter method is the union discriminator that selects the union case).

> 选择合适的联合情况（如[[SWS_CM_11146](#_bookmark267)]中所述），字段的getter/setter方法的哈希是选择联合情况的联合鉴别器。

  Set the appropriate \<svcId\>Field_Get\<FieldName\>_Result---for Get () operations---or \<svcId\>Field_Set\<FieldName\>_Result---for Set () operations. In both cases, the binding shall select the union case for dds::RETCODE_OK and set the corresponding structure with the value retrieved upon the return of (1), (2), or (3).

> 设置适当的\<svcId\>Field_Get\<FieldName\>_Result---对于Get（）操作---或\<svcId\>Field_Set\<FieldName\>_Result---对于Set（）操作。在这两种情况下，绑定都应选择dds :: RETCODE_OK的联合情况，并在（1），（2）或（3）返回时设置相应的结构，以获取值。


The sample shall then be passed as a parameter to the write() method of the DDS DataWriter created in [[SWS_CM_11150](#_bookmark271)] to handle method responses on the server side, which shall serialize the sample according to the DDS serialization rules, an publish it over DDS.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221)*

> 将示例然后作为参数传递给在[[SWS_CM_11150](#_bookmark271)]中创建的DDS DataWriter的write()方法，以处理服务器端的方法响应，该方法应根据DDS序列化规则序列化示例，并通过DDS发布它。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221)*


The DDS serialization rules are defined in section [7.5.3.7](#serialization-of-payload-3).

> 负载序列化规则在第7.5.3.7节中定义。

### Serialization of Payload


**[SWS_CM_11040] DDS standard serialization rules** *[*The serialization of the payload shall be done according to the DDS standard serialization rules defined in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00201)*

> [SWS_CM_11040] DDS标准序列化规则*[*负载的序列化应按照 [20] 第7.4.3.5节定义的DDS标准序列化规则进行。*♩(RS_CM_00204，RS_CM_00201)*

14An internal lookup operation to retrieve the current value of a field.

### Basic Data Types


**[SWS_CM_11041] DDS serialization of StdCppImplementationDataType of category VALUE** *[*StdCppImplementationDataType of category VALUE shall be serialized according to the standard serialization rules for the equivalent DDS PRIMITIVE_TYPE defined in section 7.4.3.5 of [20]. Table [7.4](#_bookmark278) provides the equivalent DDS PRIMITIVE_TYPEs for the primitive StdCppImplementationDataTypes with category VALUE defined in [13].*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*

> [SWS_CM_11041] 将类别VALUE的StdCppImplementationDataType序列化为DDS。*[*根据[20]中第7.4.3.5节定义的标准序列化规则，将类别VALUE的StdCppImplementationDataType序列化为相应的DDS PRIMITIVE_TYPE。表[7.4]提供了[13]中定义的原始StdCppImplementationDataTypes的相应DDS PRIMITIVE_TYPE。*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102)*


**Table 7.4: StdCppImplementationDataTypes with category VALUE supported for serialization**

> 表7.4：支持序列化的StdCppImplementationDataTypes的值类别

### Enumeration Data Types


**[SWS_CM_11042] DDS serialization of enumeration data types** *[*Enumeration data types shall be serialized according to the standard serialization rules for DDS ENUM_TYPE defined in section 7.4.3.5 of [20].

> [SWS_CM_11042] 枚举数据类型的DDS序列化：枚举数据类型应按照[20]第7.4.3.5节中定义的DDS ENUM_TYPE标准序列化规则进行序列化。


The bit bound of the ENUM_TYPE shall be set to the size of the enumeration's underlying basic data type (i.e., the Primitive Cpp Implementation Data Type according to [SWS_LBAP_00027]) in bits.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> ENUM_TYPE 的位边界应被设置为枚举的基础数据类型的大小（即根据[SWS_LBAP_00027]的原始Cpp实现数据类型），以位为单位。

### Structured Data Types (structs)


**[SWS_CM_11043] DDS serialization of StdCppImplementationDataType of category STRUCTURE** *[*StdCppImplementationDataType of category STRUCTURE shall be serialized according to the standard serialization rules for DDS STRUCT_TYPE defined in section 7.4.3.5 of [20].

> [SWS_CM_11043] 结构类别的StdCppImplementationDataType应根据[20]第7.4.3.5节中定义的DDS STRUCT_TYPE的标准序列化规则进行序列化。


Optional members of the structure shall be marked as optional as specified in section 7.2.2.4.4.5 of [20].*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 可选结构成员应按[20]第7.2.2.4.4.5节中的规定标记为可选（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）。

### Strings


**[SWS_CM_11044] DDS serialization of StdCppImplementationDataType of category STRING with string shortName** *[*An StdCppImplementationDataType of category STRING shall be serialized according to the standard serialization rules for DDS STRING_TYPE defined in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_11044] 将类别STRING的StdCppImplementationDataType进行DDS序列化，其字符串简称** *[*根据[20]第7.4.3.5节定义的DDS STRING_TYPE标准序列化规则，应对类别STRING的StdCppImplementationDataType进行序列化。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


[SWS_CM_11046] Encoding Format and Endianness of Strings in DDS *[*Section 7.4.1.1.2 of [20] specifies the standard character encoding format for STRING_TYPE: UTF-8. The serialized version shall not include a Byte Order Mark (BOM), as byte order information is already available in the RTPS Encapsulation Identifier and the XCDR serialization format [20].*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*

> [SWS_CM_11046] DDS中字符串的编码格式和字节序*[*[20]的第7.4.1.1.2节指定了STRING_TYPE的标准字符编码格式：UTF-8。序列化版本不应包含字节顺序标记（BOM），因为字节顺序信息已经在RTPS封装标识符和XCDR序列化格式[20]中提供。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*

### Vectors and Arrays


**[SWS_CM_11047] DDS serialization of CppImplementationDataType of category VECTOR** *[*A CppImplementationDataType of category VECTOR shall be serialized according to the standard serialization rules for DDS SEQUENCE_TYPE defined in section 7.4.3.5 of [20].

> [SWS_CM_11047] 将类别VECTOR的CppImplementationDataType序列化为DDS。根据[20]第7.4.3.5节中定义的DDS SEQUENCE_TYPE的标准序列化规则进行序列化。


Binding implementations shall serialize VECTOR CppImplementationDataTypes with more than one dimension, as nested DDS sequences.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 绑定实现应将具有多个维度的VECTOR CppImplementationDataTypes序列化为嵌套的DDS序列。（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）


**[SWS_CM_11048] DDS serialization of CppImplementationDataType of category ARRAY** *[*A CppImplementationDataType of category ARRAY shall be serialized according to the standard serialization rules for DDS ARRAY_TYPE defined in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_11048] 将类别ARRAY的CppImplementationDataType序列化为DDS** *[*类别ARRAY的CppImplementationDataType应按照[20]第7.4.3.5节中定义的标准序列化规则来序列化DDS ARRAY_TYPE。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

### Associative Maps


**[SWS_CM_11049] DDS serialization of CppImplementationDataType of category ASSOCIATIVE_MAP** *[*CppImplementationDataType of category ASSOCIATIVE_MAP shall be serialized according to the standard serialization rules for DDS MAP_TYPE defined in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_11049] CppImplementationDataType 类别 ASSOCIATIVE_MAP 的 DDS 序列化** *[*CppImplementationDataType 类别 ASSOCIATIVE_MAP 应按照 [20] 章节 7.4.3.5 中定义的 DDS MAP_TYPE 标准序列化规则进行序列化。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

### Variant


**[SWS_CM_11050] DDS serialization of CppImplementationDataType of category VARIANT** *[*CppImplementationDataType of category VARIANT shall be serialized according to the standard serialization rules for DDS UNION_TYPE defined in section 7.4.3.5 of [20].*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_11050] VARIANT类别的CppImplementationDataType序列化** *[*根据[20]第7.4.3.5节定义的标准序列化规则，CppImplementationDataType的VARIANT类别应序列化为DDS UNION_TYPE。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

### End-to-end communication protection


The present DDS network binding is defined in terms of interactions between ara::com APIs and standard DDS APIs. Hence, End-to-end communication protection as described in sections [7.7.1](#end-to-end-communication-protection-for-events) and [7.7.2](#end-to-end-communication-protection-for-methods) doesn't apply, because API calls can't be checksummed or payloaded the same way serialized messages are.

> 当前的DDS网络绑定是根据ara :: com API和标准DDS API之间的交互定义的。因此，如[7.7.1]（＃端到端通信保护）和[7.7.2]（＃端到端通信保护）所述的端到端通信保护不适用，因为API调用无法像序列化消息那样进行校验和载荷。


By no means does this imply that DDS is exempt from E2E protection assurances, they are simply provided by the DDS middleware. Please find below the different kinds of faults defined in [4] (derived from ISO-26262-6:2011, annex D.2.4) and their corresponding DDS/RTPS protection mechanism:

> 这并不意味着DDS免于E2E保护保证，它们只是由DDS中间件提供的。以下是[4]中定义的不同类型故障及其相应的DDS/RTPS保护机制：


- Repetition, loss, insertion, incorrect sequence, information from a sender received by only a subset of receivers, and blocking access to a communication channel: submessage 64-bit sequence number, as defined in [19] section 8.3.5.4 \"SequenceNumber\", and additional SequenceNumber-typed fields in section 8.3.7 \"RTPS Submessages\"

> 重复、损失、插入、错误序列、发送者发送的信息只被一部分接收者收到，以及阻止访问通信通道：子消息64位序列号，如[19]第8.3.5.4节“序列号”定义，以及第8.3.7节“RTPS 子消息”中的附加序列号类型字段。


- Delay of information and blocking access to a communication channel: LATENCY_BUDGET Quality of Service policy, as defined in [18] section 2.2.3.8 \"LATENCY_BUDGET\"

> 延迟信息和阻止访问通信通道：LATENCY_BUDGET质量服务政策，如[18]第2.2.3.8节“LATENCY_BUDGET”中定义。

- Masquerade or incorrect addressing of information: DDS Security authentication plugin, as defined in [25] section 8.3 \"Authentication Plugin\"

> 伪装或不正确地地址信息：DDS安全认证插件，如[25]第8.3节“认证插件”中所定义。

- Corruption of information, asymmetric information sent from a sender to multiple receivers: rtpsMessageChecksum under HeaderExtension submessage ([RTPS 2.5 or higher]). In absence of this feature, [25] also provides message integrity verification built into its message authentication protocol

> 数据被篡改、不对称的信息从发送者发送到多个接收者：rtpsMessageChecksum在HeaderExtension子消息（[RTPS 2.5或更高版本]）中。如果没有这个功能，[25]还提供了消息完整性验证，构建到其消息认证协议中。

- Translation of these fault conditions into ara::com::e2e::ProfileCheckStatus values depends on the specific capacities of the DDS implementation to report per-sample the status of the aforementioned protection measures (sequence numbers, latency budget, message authentications, checksums)

> 翻译这些故障条件到ara::com::e2e::ProfileCheckStatus值取决于DDS实现特定能力报告每个样本上述保护措施（序列号、延迟预算、消息身份验证、校验和）的状态。

  1. ## Security


In the following chapter the behavior according to the meta-model of access control and secure communication shall be described.

> 在接下来的章节中，将描述根据访问控制和安全通信的元模型的行为。

### IAM


Access control for Communication Management allows to restrict the instances and elements of services that a local application or a *remote subject* (e.g., a remote ECU) may request to access. Having access control in place reduces the potential damage that a compromised application (in case of local IAM) or a compromised ECU (in case of remote IAM) can cause.

> 访问控制管理允许限制本地应用程序或远程主体（例如远程ECU）可以请求访问的服务的实例和元素。放置访问控制可以减少受损应用程序（如果是本地IAM）或受损ECU（如果是远程IAM）可能造成的潜在损害。


Figure [7.19](#_bookmark288) demonstrates an example scenario where local IAM and remote IAM can take place. Upon a method call from a service, the client's request will be checked by the local IAM to ensure that the application is issuing a legitimate request based on its configured access rights. After successful authorization, the request will be forwarded to the machine where the service is running. When the request arrives at the recipient machine, the remote IAM takes place and a check will be performed to verify if such a request coming from the given sender ECU was envisioned.

> 图7.19演示了一个本地IAM和远程IAM可以发挥作用的示例场景。当服务发出方法调用时，本地IAM将检查客户端的请求，以确保应用程序根据其配置的访问权限发出了合法的请求。在授权成功后，请求将转发到运行服务的机器上。当请求到达接收机时，远程IAM将进行检查，以验证来自给定发送器ECU的此类请求是否被预见。

![](./media/image34.png){width="4.147099737532808in" height="2.1999989063867016in"}

**Figure 7.19:** **Local and Remote Identity and Access Management**

The following assumptions have to be held true to realize access control:


1. Communication between two applications has to be realized by using ara::com interfaces Communication Management to enable access control.

> 两个应用之间的通信必须通过使用ara::com接口通信管理来实现，以启用访问控制。
2. Process separation as defined in SWS IdentityAndAccessManagement [26].


All access permissions for Communication Management are modeled using ComGrant model elements. A ComGrant can be used to model access permissions that either apply to a Machine-local Process or to a remote subject, i.e., either a local Process or a remote entity can be the *subject* of the access control policy: If a ComGrant references an AbstractIamRemoteSubject in the role remoteSubject, then the subjects of the ComGrant are all remote entities that can be identified using the information specified in the referenced AbstractIamRemoteSubject. If a ComGrant does not reference any remoteSubject, then the subjects of the ComGrant are all Processes referenced in the role process by ServiceInstanceToPortPrototypeMappings which reference an AdaptivePlatformServiceInstance in the role serviceInstance that is referenced by the ComGrant in the role serviceInstance.

> 所有通信管理的访问权限都使用ComGrant模型元素进行建模。ComGrant可用于建模适用于机器本地进程或远程主体的访问权限，即，本地进程或远程实体可以是访问控制策略的*主题*：如果ComGrant在角色remoteSubject中引用AbstractIamRemoteSubject，则ComGrant的主题是所有可以使用引用的AbstractIamRemoteSubject中指定的信息进行标识的远程实体。如果ComGrant未引用任何remoteSubject，则ComGrant的主题是通过引用ComGrant中role serviceInstance的AdaptivePlatformServiceInstance中role serviceInstance的ServiceInstanceToPortPrototypeMappings引用的所有进程。


Local access control and remote access control may be enforced independently from each other.

> 本地访问控制和远程访问控制可以独立于彼此实施。

### Configuration of Access Control


While Identity and Access Management (IAM) serves as an umbrella for access control on the Adaptive Platform, the enforcement of access control is implemented in different functional clusters such as CM. If no IAM Functional Cluster is instantiated on a Machine, then no enforcement of access control by CM is expected.

> 当身份和访问管理（IAM）作为自适应平台访问控制的伞，访问控制的执行在不同的功能集群（如CM）中实现。如果没有在机器上实例化IAM功能集群，那么不会预期CM执行访问控制。


**[SWS_CM_10492]**{DRAFT} **IAM Module Instantiation** *[*If no IamModuleInstantiation is defined on the Machine, CM shall perform no access control, i.e., no access to any service shall be restricted because of missing ComGrants.*♩(RS_IAM_00002)*

> **[SWS_CM_10492]**{草案} **IAM 模块实例化** *[*如果机器上没有定义IamModuleInstantiation，CM 不会执行访问控制，即，由于缺少ComGrants而不允许访问任何服务。*♩(RS_IAM_00002)*


Depending on the architecture and the security model, all local Processes might be trusted, thus not requiring local access control. Furthermore, it is possible that all remote ECUs are trusted, e.g., because access control is already performed locally. For these cases, there are two configuration options to enable remote access control and local access control independently.

> 根据架构和安全模型，所有本地进程可能是受信任的，因此不需要本地访问控制。此外，所有远程ECU都可能是受信任的，例如，因为访问控制已经在本地执行。对于这些情况，有两种配置选项可以独立地启用远程访问控制和本地访问控制。


**[SWS_CM_10493]**{DRAFT} **Local Access Control Activation** *[*If IamModuleInstantiation.localComAccessControlEnabled is defined and is set to false, CM shall perform no local access control, i.e., no access to any service from a local Process shall be restricted because of missing ComGrants. If IamModuleInstantiation is defined on the Machine and IamModuleInstantiation.localComAccessControlEnabled is not defined or is set to true, CM shall perform local access control.*♩(RS_IAM_00002)*

> **[SWS_CM_10493]**{草案} **本地访问控制激活** *[*如果IamModuleInstantiation.localComAccessControlEnabled被定义且设置为false，CM将不执行本地访问控制，即，由于缺少ComGrants而不允许从本地进程访问任何服务。如果IamModuleInstantiation在机器上被定义，并且IamModuleInstantiation.localComAccessControlEnabled未被定义或设置为true，CM将执行本地访问控制。*♩(RS_IAM_00002)*


**[SWS_CM_10494]**{DRAFT} **Remote Access Control Activation** *[*If IamModuleInstantiation.remoteAccessControlEnabled is defined and is set to false, CM shall perform no remote access control, i.e., no access to any service from a remote subject shall be restricted because of missing ComGrants. If IamModuleInstantiation is defined on the Machine and IamModuleInstantiation.remoteAccessControlEnabled is not defined or is set to true, CM shall perform remote access control.*♩(RS_IAM_00002)*

> **[SWS_CM_10494]**{草案} **远程访问控制激活** *[*如果IamModuleInstantiation.remoteAccessControlEnabled被定义并且设置为false，CM将不执行任何远程访问控制，即，任何来自远程主体的访问不会因缺少ComGrants而受到限制。如果IamModuleInstantiation被定义在机器上并且IamModuleInstantiation.remoteAccessControlEnabled未定义或者被设置为true，CM将执行远程访问控制。*♩(RS_IAM_00002)*


**[SWS_CM_90001]**{DRAFT} **Restrictions on executing methods** *[*The invocation of a method by an application shall be executed depending on the existence of ComMethodGrant, ComFieldGrant without a reference remoteSubject and with the role attribute of ComFieldGrant set to FieldAccessEnum.getter or FieldAccessEnum.setter. From a temporal perspective the enforcement of intent shall take place between the invocation of one of the following methods and invocation of the continuation registered with then() (see [SWS_CORE_00331]) or the access to result of the Future (via the get() method (see [SWS_CORE_00326])) returned by these methods:

> **[SWS_CM_90001]**{草案} **执行方法的限制** *[*应用程序调用方法的执行取决于ComMethodGrant、ComFieldGrant的存在，而且ComFieldGrant的角色属性被设置为FieldAccessEnum.getter或FieldAccessEnum.setter。从时间角度上看，意图的执行将发生在以下方法的调用之间，以及与then（参见[SWS_CORE_00331]）注册的继续调用之间，或者是通过这些方法返回的Future（通过get（）方法（参见[SWS_CORE_00326]））访问结果：

**[SWS_CM_90001]**{草案} **执行方法的限制** *[*应用程序调用方法的执行取决于ComMethodGrant、ComFieldGrant的存在，而且ComFieldGrant的角色属性被设置为FieldAccessEnum.getter或FieldAccessEnum.setter。从时间角度上看，在以下方法的调用和与then（参见[SWS_CORE_00331]）注册的继续调用，以及通过这些方法返回的Future（通过get（）方法（参见[SWS_CORE_00326]））访问结果之间，应当执行意图：


- the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)])

> 调用相应方法类的函数调用运算符（操作符()）（参见[[SWS_CM_00196](#_bookmark586)])
- the Set() method of the respective Field class (see [[SWS_CM_00113](#_bookmark591)])
- the Get() method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)])


If the software tries to access a field/event/method in the absence of a Grant that controls access to the field/even/method then the error code ComErrc::kGrantEnforcementError shall be returned in the Future of the respective methods (operator(), Set(), Get()). The error shall be logged.*♩(RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果软件试图访问一个控制访问字段/事件/方法的授权不存在的字段/事件/方法，那么将来相应的方法(operator()，Set()，Get())中将返回错误代码ComErrc::kGrantEnforcementError。该错误将被记录，RS_IAM_00006，RS_IAM_00007，RS_IAM_00010。


**[SWS_CM_90002]**{DRAFT} **Restrictions on sending events** *[*Sending an event by an application shall be enabled depending on the existence of ComEventGrant or ComFieldGrant without a reference remoteSubject and with the role attribute set to FieldAccessEnum.setter. From a temporal perspective the enforcement of intent shall take place after the invocation of the following method:

> **[SWS_CM_90002]**{草案} **发送事件的限制** *[*应根据ComEventGrant或ComFieldGrant的存在来启用应用程序发送事件，而且要求role属性设置为FieldAccessEnum.setter。从时间角度来看，在调用以下方法之后才会执行意图：


- the Send() method of the respective Event class (see [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)])

> 该事件类的Send（）方法（见[[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)])
- the Update() method of the respective Field class (see [[SWS_CM_00119](#_bookmark548)])


A failure of the Grant enforcement (i.e., the triggering of an event without appropriate intent modeling) shall cause the event to be dropped silently.*♩(RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果授权执行失败（即，在没有适当意图建模的情况下触发事件），则将静默地丢弃该事件。


**[SWS_CM_90003]**{DRAFT} **Restrictions on receiving events** *[*Subscribing to event notifications shall be enabled depending on the existence of ComEventGrant or ComFieldGrant without a reference remoteSubject and with the role attribute set to FieldAccessEnum.getter. From a temporal perspective the enforcement of the intent shall take place after the invocation of the following method:

> **[SWS_CM_90003]**{草案} **事件接收限制** *[*根据ComEventGrant或ComFieldGrant的存在情况，订阅事件通知应启用，而且角色属性应设置为FieldAccessEnum.getter。从时间角度来看，意图的执行应在调用以下方法之后才进行：

- the Subscribe() method of the respective Event class (see [[SWS_CM_00141](#_bookmark559)])


A failure of the Grant enforcement (i.e., the subscription to an event without appropriate intent modeling) shall cause the subscription to the event to be dropped silently.*♩ (RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果Grant执行失败（即没有适当的意图建模）订阅活动，则该订阅活动将被静默丢弃（RS_IAM_00006，RS_IAM_00007，RS_IAM_00010）。


**[SWS_CM_10538]**{DRAFT} **Restrictions on sending triggers** *[*Sending a trigger by an application shall be enabled depending on the existence of ComEventGrant without a reference remoteSubject. In case of a Trigger the ComEventGrant references the ServiceEventDeployment that in turn references the trigger. From a temporal perspective the enforcement of intent shall take place after the invocation of the following method:

> **[SWS_CM_10538]**{草案} **发送触发器的限制** *[*根据没有参考远程主题的ComEventGrant的存在，应该启用应用程序发送触发器。对于触发器，ComEventGrant引用ServiceEventDeployment，反过来又引用触发器。从时间角度看，意图的执行应该在调用以下方法之后才发生：

- the Send() method of the respective Trigger class (see [[SWS_CM_00721](#_bookmark535)])


A failure of the Grant enforcement (i.e., the triggering of a trigger without appropriate intent modeling) shall cause the trigger to be dropped silently.*♩(RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果授权执行失败（即在没有适当的意图建模的情况下触发触发器），则会导致触发器静悄悄地被丢弃。（RS_IAM_00006，RS_IAM_00007，RS_IAM_00010）


**[SWS_CM_10539]**{DRAFT} **Restrictions on receiving triggers** *[*Receiving a trigger shall be enabled depending on the existence of ComEventGrant without a reference remoteSubject. In case of a Trigger the ComEventGrant references the ServiceEventDeployment that in turn references the trigger. From a temporal perspective the enforcement of the intent shall take place after the invocation of the following method:

> **[SWS_CM_10539]**{草案} **接收触发器的限制** *[*只有在没有参考远程主题的情况下，ComEventGrant的存在才能启用接收触发器。对于触发器，ComEventGrant引用ServiceEventDeployment，而ServiceEventDeployment又引用触发器。从时间角度来看，意图的执行应在调用以下方法之后进行：

- the Subscribe() method of the respective Trigger class (see [[SWS_CM_00723](#_bookmark579)])


A failure of the Grant enforcement (i.e., the subscription to a trigger without appropriate intent modeling) shall cause the subscription to the trigger to be dropped silently.*♩ (RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果Grant执行失败（即在没有适当意图建模的情况下订阅触发器），则会无声地取消该触发器的订阅。（RS_IAM_00006，RS_IAM_00007，RS_IAM_00010）


**[SWS_CM_90005]**{DRAFT} **Restrictions on offering services** *[*Offering a service instance shall be enabled depending on the presence of a ComOfferServiceGrant without a reference remoteSubject. From a temporal perspective the enforcement of the intent shall take place after the invocation of the following method:

> **[SWS_CM_90005]**{草稿} **服务提供的限制** *[*只有在没有参考远程主体的情况下，才能启用服务实例的提供。从时间的角度来看，执行意图的执行将在调用以下方法之后发生：

- the constructor of the respective ServiceSkeleton class (see [[SWS_CM_00130](#_bookmark525)])


If the software tries to access a field/event/method in the absence of a Grant that controls access to the field/even/method then the error code ComErrc::kGrantEnforcementError shall be returned in the Result of the named constructor function Create() for the ServiceSkeleton class. The error shall be logged.*♩(RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果软件试图在没有控制访问该字段/事件/方法的授权的情况下访问该字段/事件/方法，则在ServiceSkeleton类的名称构造函数Create()的结果中应返回错误代码ComErrc::kGrantEnforcementError。此错误应记录在日志中（RS_IAM_00006，RS_IAM_00007，RS_IAM_00010）。


**[SWS_CM_90006]**{DRAFT} **Restrictions on using services** *[*Using a service instance shall be enabled depending on the presence of a ComFindServiceGrant without a reference remoteSubject. From a temporal perspective the enforcement of the intent shall take place after the invocation of the following method:

> **[SWS_CM_90006]**{草案} **服务使用的限制** *[*只有在没有参考远程主题的ComFindServiceGrant存在的情况下，才能启用服务实例。从时间角度来看，执行意图应在调用以下方法之后才生效：

- the constructor of the respective ServiceProxy class (see [[SWS_CM_00131](#_bookmark557)])


If the software tries to access a field/event/method in the absence of a Grant that controls access to the field/even/method then the error code ComErrc::kGrantEnforcementError shall be returned in the Result of the named constructor function Create() for the ServiceProxy class. The error shall be logged.*♩(RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果软件试图在没有控制对字段/事件/方法的访问权限的情况下访问字段/事件/方法，那么在ServiceProxy类的命名构造函数Create()的结果中将返回错误代码ComErrc::kGrantEnforcementError。该错误应被记录（RS_IAM_00006，RS_IAM_00007，RS_IAM_00010）。


**[SWS_CM_90007] Restrictions on using RawDataStreams** *[*Using a RawDataStream instance shall be enabled depending on the presence of a RawDataStreamGrant. From a temporal perspective the enforcement of the intent shall take place after the invocation of the following method:

> **[SWS_CM_90007] 使用RawDataStreams的限制** *[*取决于RawDataStreamGrant的存在，使用RawDataStream实例应该被启用。从时间角度来看，在调用以下方法之后执行意图：

- the Connect() method of the respective RawDataStream class (see [SWS_CM_10484])


If the software tries to access a field/event/method in the absence of a Grant that controls access to the field/even/method then the error code ComErrc::kGrantEnforcementError shall be returned in the Result of the Connect() function. The error shall be logged.*♩(RS_IAM_00006, RS_IAM_00007, RS_IAM_00010)*

> 如果软件试图在没有控制对字段/事件/方法的访问权的情况下访问该字段/事件/方法，则Connect()函数的Result中将返回错误码ComErrc::kGrantEnforcementError。该错误应被记录（RS_IAM_00006，RS_IAM_00007，RS_IAM_00010）。

Note:


In case of [[SWS_CM_90002](#_bookmark291)] and [[SWS_CM_90003](#_bookmark292)] dropping data, the application will not be notified.

> 在[[SWS_CM_90002](#_bookmark291)]和[[SWS_CM_90003](#_bookmark292)]丢失数据的情况下，应用程序不会被通知。


A logging facility for security events is currently not defined in the AUTOSAR Adaptive Platform. Logging violations of access restrictions according to [[SWS_CM_90001](#_bookmark290)], [[SWS_CM_90002](#_bookmark291)], [[SWS_CM_90003](#_bookmark292)], [[SWS_CM_90005](#_bookmark293)] and [[SWS_CM_90006](#_bookmark294)] is up to the implementation or specific ECU projects.

> 汽车自动化可编程应用软件开放系统（AUTOSAR Adaptive Platform）中目前尚未定义安全事件的日志记录设施。根据[[SWS_CM_90001](#_bookmark290)]、[[SWS_CM_90002](#_bookmark291)]、[[SWS_CM_90003](#_bookmark292)]、[[SWS_CM_90005](#_bookmark293)]和[[SWS_CM_90006](#_bookmark294)]记录访问限制违规行为的日志，取决于实现或特定ECU项目。

### Remote Access Control


In order to enforce access control on remote entities, the requesting entity first has to be authenticated, i.e., the identity of the *remote subject* has to be established. Then, it has to be decided whether the access is allowed according to the modeled grants.

> 为了对远程实体实施访问控制，请求实体首先必须要进行身份验证，即必须建立远程主体的身份。然后，根据建模的授权决定是否允许访问。

There are currently three ways to authenticate a remote subject:


- **TLS:** If the remote subject is connected via (D)TLS secure communication, properties of this TLS connection and the used certificates can be used for authenticating the remote subject.

> 如果远程主体通过（D）TLS安全通信连接，则可以使用此TLS连接的属性和所使用的证书来对远程主体进行身份验证。

- **IPsec:** If IPsec is used to establish secure communication, IP related information specified for IPsec configuration can be used for authenticating the remote subject.

> 如果使用IPsec来建立安全通信，用于IPsec配置的IP相关信息可用于认证远程主体。

- **IP:** If IP based communication is used and the authenticity of communication partners can be guaranteed by, e.g., the operational environment, IP related information can be used for authenticating the remote subject.

> 如果使用基于IP的通信，并且可以通过操作环境等保证通信双方的真实性，那么可以使用IP相关信息来进行远程主体认证。


Please note that while SecOC can also provide authenticity of a communication partner, it is not used in this section, because the existing association between SecOC keys and DataIDs already provides a fine grained access control mechanism directly on the level of secure communication and thus additionally applying IAM would not yield any benefit.

> 请注意，尽管SecOC也可以提供通信伙伴的真实性，但在本节中不使用它，因为SecOC密钥和DataIDs之间现有的关联已经直接在安全通信层面上提供了细粒度的访问控制机制，因此额外应用IAM不会带来任何好处。


**[SWS_CM_10495]**{DRAFT} **TLS-based Authentication** *[*Communication Management shall associate remote subjects communicating via an established (D)TLS connection to a TlsIamRemoteSubject according to [TPS_MANI_03240].*♩(RS_CM_00803)*

> **[SWS_CM_10495]**{草案} **基于TLS的认证** *[*根据[TPS_MANI_03240]，通信管理应将通过建立的（D）TLS连接通信的远程主题关联到TlsIamRemoteSubject。*♩(RS_CM_00803)*


**[SWS_CM_10496]**{DRAFT} **IP and IPsec-based Authentication** *[*Communication Management shall associate remote subjects communicating via IP to an IPSecIamRemoteSubject or an IpIamRemoteSubject according to [TPS_MANI_03242] and [TPS_MANI_03244].*♩(RS_CM_00803)*

> **[SWS_CM_10496]**{草案} **基于IP和IPsec的认证** *[*根据[TPS_MANI_03242]和[TPS_MANI_03244]，通信管理应将通过IP通信的远程主体关联到IPSecIamRemoteSubject或IpIamRemoteSubject。*♩(RS_CM_00803)*


Please note that IPsec is usually handled by the OS and may therefore be transparent to Communication Management. Therefore, authentication of IPsec secured connections relies on tuples of IP addresses, protocols, and ports only.

> 请注意，IPsec通常由操作系统处理，因此对通信管理可能是透明的。 因此，IPsec保护连接的身份验证仅依赖于IP地址，协议和端口的元组。


**[SWS_CM_10497]**{DRAFT} **Authentication Failure** *[*If IamModuleInstantiation. remoteAccessControlEnabled is set to true and a remote subject cannot be authenticated, Communication Management shall silently drop all messages from this remote subject.*♩(RS_CM_00803)*

> 如果IamModuleInstantiation中的remoteAccessControlEnabled设置为true，而且无法对远程主体进行身份验证，通信管理将静默丢弃来自这个远程主体的所有消息（RS_CM_00803）。


**[SWS_CM_10498]**{DRAFT} **Remote access control on executing methods** *[*If a remote subject requests the execution of a method of a service interface, but there exists no ComMethodGrant that

> **[SWS_CM_10498]**{草稿} **远程执行方法的访问控制** *[*如果一个远程主体请求执行服务接口的方法，但是不存在ComMethodGrant，

- references the requesting remote subject in the role remoteSubject and
- references a ProvidedApServiceInstance in the role serviceInstance

and


- references the requested method in the role serviceDeployment, then Communication Management shall drop the request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 引用角色服务部署中所请求的方法，通信管理应该放弃请求（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10499]**{DRAFT} **Remote access control on providing methods** *[*If the execution of a method of a service interface provided by a remote subject is requested, but there exists no ComMethodGrant that

> **[SWS_CM_10499]**{草案} **远程访问控制提供方法** *[*如果请求调用远程主体提供的服务接口的方法，但不存在ComMethodGrant

- references the providing remote subject in the role remoteSubject and
- references a RequiredApServiceInstance in the role serviceInstance

and


- references the requested method in the role serviceDeployment, then Communication Management shall drop the request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 引用角色服务部署中所请求的方法，然后通信管理部门应该放弃请求（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10500]**{DRAFT} **Remote access control on providing events** *[*If a remote subject provides an event of a service interface, but there exists no ComEventGrant that

> **[SWS_CM_10500]**{草案} **远程访问控制对提供事件的控制** *[*如果远程主体提供服务接口的事件，但不存在ComEventGrant

- references the providing remote subject in the role remoteSubject and
- references a RequiredApServiceInstance in the role serviceInstance

and


- references the provided event in the role serviceDeployment, then Communication Management shall drop the provided event.*♩(RS_IAM_00001, RS_IAM_00002)*

> 参考角色服务部署中提供的事件，然后通信管理部门应该丢弃提供的事件（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10501]**{DRAFT} **Remote access control on consuming events** *[*If a remote subject subscribes to an event of a service interface, but there exists no ComEventGrant that

> **[SWS_CM_10501]**{草案} **远程访问控制消费事件** *[*如果远程主体订阅服务接口的事件，但不存在ComEventGrant

- references the subscribing remote subject in the role remoteSubject and
- references a ProvidedApServiceInstance in the role serviceInstance

and


- references the subscribed event in the role serviceDeployment, then Communication Management shall drop the subscription request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 引用订阅服务部署中的事件，然后通信管理将取消订阅请求（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10502]**{DRAFT} **Remote access control on providing field notifiers** *[*If a remote subject sends a field notifier, but there exists no ComFieldGrant that

> **[SWS_CM_10502]**{草案} **远程访问控制对提供的字段通知者** *[*如果远程主题发送字段通知者，但是不存在ComFieldGrant

- references the providing remote subject in the role remoteSubject and
- references a RequiredApServiceInstance in the role serviceInstance

and


- references the event in the role serviceDeployment, then Communication Management shall drop the field notifier.*♩(RS_IAM_00001, RS_IAM_00002)*

> 当服务部署参考该事件时，通信管理部门应该删除字段notifier.♩(RS_IAM_00001, RS_IAM_00002)


**[SWS_CM_10503]**{DRAFT} **Remote access control on providing field setters** *[*If the execution of a set method of a field provided by a remote subject is requested, but there exists no ComFieldGrant that

> **[SWS_CM_10503]** {草案} **远程访问控制提供的字段设置器** *[*如果请求执行远程主体提供的字段的设置方法，但不存在ComFieldGrant

- has the parameter ComFieldGrant.role set to setter or getterSetter and
- references the providing remote subject in the role remoteSubject and
- references a RequiredApServiceInstance in the role serviceInstance

and


- references the event in the role serviceDeployment, then Communication Management shall drop the request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 如果参考服务部署事件，通信管理应该放弃请求（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10504]**{DRAFT} **Remote access control on providing field getters** *[*If the execution of a get method of a field provided by a remote subject is requested, but there exists no ComFieldGrant that

> **[SWS_CM_10504]**{草案} **远程控制对提供字段获取者的访问** *[*如果请求执行远程主体提供的字段的get方法，但不存在ComFieldGrant

- has the parameter ComFieldGrant.role set to getter or getterSetter and
- references the providing remote subject in the role remoteSubject and
- references a RequiredApServiceInstance in the role serviceInstance

and


- references the event in the role serviceDeployment, then Communication Management shall drop the request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 提及服務部署中的事件，通信管理將放棄該請求（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10505]**{DRAFT} **Remote access control on consuming field notifiers** *[*If a remote subject subscribes to a field notifier , but there exists no ComFieldGrant that

> **[SWS_CM_10505]**{草案} **遠程訪問控制消費領域的通知者** *[*如果一個遠程主題訂閱了一個領域通知者，但存在沒有ComFieldGrant

- references the subscribing remote subject in the role remoteSubject and
- references a ProvidedApServiceInstance in the role serviceInstance

and


- references the event in the role serviceDeployment, then Communication Management shall drop the the subscription request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 如果参考事件在服务部署中，通信管理应该取消订阅请求(*RS_IAM_00001，RS_IAM_00002*)。


**[SWS_CM_10506]**{DRAFT} **Remote access control on calling field setters** *[*If a remote subject requests the execution of a set method of a field, but there exists no ComFieldGrant that

> **[SWS_CM_10506]**{草案} **远程访问控制对调用字段设置者** *[*如果远程主体请求执行字段的设置方法，但不存在ComFieldGrant

- has the parameter ComFieldGrant.role set to setter or getterSetter and
- references the requesting remote subject in the role remoteSubject and
- references a ProvidedApServiceInstance in the role serviceInstance

and


- references the event in the role serviceDeployment, then Communication Management shall drop the request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 引用服务部署中的事件，通信管理部门应该放弃请求(RS_IAM_00001, RS_IAM_00002)。


**[SWS_CM_10507]**{DRAFT} **Remote access control on calling field getters** *[*If a remote subject requests the execution of a get method of a field, but there exists no ComFieldGrant that

> **[SWS_CM_10507]**{草案} **对远程访问字段获取者进行控制** *[*如果远程主体请求执行字段的获取方法，但不存在ComFieldGrant

- has the parameter ComFieldGrant.role set to getter or getterSetter and
- references the requesting remote subject in the role remoteSubject and
- references a ProvidedApServiceInstance in the role serviceInstance

and


- references the event in the role serviceDeployment, then Communication Management shall drop the request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 如果参考了服务部署中的事件，那么通信管理部门应该放弃请求（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10540]**{DRAFT} **Remote access control on providing triggers** *[*If a remote subject provides a trigger of a service interface, but there exists no ComEventGrant that

> **[SWS_CM_10540]**{草案} **远程访问控制提供触发器** *[*如果远程主体提供服务接口的触发器，但不存在ComEventGrant

- references the providing remote subject in the role remoteSubject and
- references a RequiredApServiceInstance in the role serviceInstance

and


- references the ServiceEventDeployment in the role serviceDeployment that in turn references the provided trigger.

> 引用角色serviceDeployment中的ServiceEventDeployment，它又引用了提供的触发器。


then Communication Management shall drop the provided trigger.*♩(RS_IAM_00001, RS_IAM_00002)*

> 然后，通信管理部门应该取消提供的触发器（RS_IAM_00001，RS_IAM_00002）。


**[SWS_CM_10541]**{DRAFT} **Remote access control on consuming triggers** *[*If a remote subject subscribes to an trigger of a service interface, but there exists no ComEventGrant that

> **[SWS_CM_10541]**{草案} **远程访问控制对消费触发器** *[*如果一个远程主体订阅了服务接口的触发器，但是不存在ComEventGrant

- references the subscribing remote subject in the role remoteSubject and
- references a ProvidedApServiceInstance in the role serviceInstance

and

- references the ServiceEventDeployment in the role serviceDeployment

that in turn references the subscribed trigger.


then Communication Management shall drop the subscription request.*♩(RS_IAM_00001, RS_IAM_00002)*

> 那么，通信管理部门应该取消订阅请求♩（RS_IAM_00001，RS_IAM_00002）*。

### Secure Communication


Communication in Adaptive Platform can be transported via TCP and UDP. Therefore different security mechanisms have to be available to secure the communication. Thefollowing security protocols are currently supported:

> 适应性平台上的通信可以通过TCP和UDP传输。因此，需要提供不同的安全机制来保护通信。目前支持的安全协议有：

- TLS 1.2 (see [RFC5246])
- DTLS 1.2 (see [RFC6347])
- SecOC
- IPSec
- DDS Security
- MACsec


The configuration of SecOc and TLS security protocols has a dependency on the network binding:

> 配置SecOc和TLS安全协议的依赖性取决于网络绑定。


- For SOME/IP network binding AUTOSAR allows the configuration of secure communication for a ServiceInterface by configuring either TlsSecureComProps meta-class or SecOcSecureComProps meta-class . Both are specialization of SecureComProps class that is referenced by ServiceInstanceToMachineMapping. In the case of SecOc additionally ServiceInterfaceElementSecureComConfig needs to be defined and it determines the configuration settings for the individual ServiceInterface elements. When TlsSecureComProps is configured, all the service interface elements are secured and ServiceInterfaceElementSecureComConfig is not used.

> 为了SOME/IP网络绑定，AUTOSAR允许通过配置TlsSecureComProps元类或SecOcSecureComProps元类来为服务接口配置安全通信。这两个都是SecureComProps类的特殊化，该类由ServiceInstanceToMachineMapping引用。在SecOc的情况下，还需要定义ServiceInterfaceElementSecureComConfig，它确定个别服务接口元素的配置设置。当配置TlsSecureComProps时，所有服务接口元素都被保护，不使用ServiceInterfaceElementSecureComConfig。


- For Signal based network binding, only SecOc configuration is possible, and the configuration is determined by SecureCommunicationAuthenticationProps of a SecuredIPdu referenced by the PduTriggering. SecureComProps is not used in the context of signal-based network binding.

> 对于基于信号的网络绑定，只有SecOc配置是可能的，并且该配置由PduTriggering引用的SecuredIPdu的SecureCommunicationAuthenticationProps确定。SecureComProps在信号基础网络绑定的上下文中不使用。

- For DDS Network binding, DDS Transport Security over TCP (TLS), DDS Transport Security over UDP (DTLS) and DDS Security [25] (as transport-independent security) are valid, independent and mutually exclusive choices for securing underlying DDS communications.

> 对于DDS网络绑定，DDS传输安全性通过TCP（TLS）、DDS传输安全性通过UDP（DTLS）和DDS安全性[25]（作为与传输无关的安全性）是有效的、独立的和互斥的选择，用于保护底层DDS通信。


The configuration of Ipsec (IPSecConfig) in aggregated by a NetworkEndpoint therefore it is independent of the network binding.

> IPSecConfig的配置通过网络端点聚合，因此它与网络绑定独立。


SOME/IP supports one-to-many (unicast) and many-to-many (multicast) communication paradigms. These paradigms may switch at runtime for events (see multicastThreshold).

> SOME/IP支持一对多（单播）和多对多（多播）的通信模式。这些模式可以在运行时切换，以处理事件（参见multicastThreshold）。


It is therefore important to be aware of the limitations of the secure channel approach:

> 因此，重要的是要意识到安全通道方法的局限性：

- ### Confidentiality of events


If events are transported using UDP and may be sent using multicast, they cannot be guaranteed confidential due to the fact that only SecOC can be used to secure multicast communication and SecOC does not offer confidentiality. This restriction does not apply to DDS Security.

> 如果使用UDP传输事件，并且可以使用多播发送，由于只能使用SecOC来保护多播通信且SecOC不提供机密性，因此不能保证机密性。这个限制不适用于DDS安全。

1. ### Creation and use of secure channels

   1. **SOME/IP and DDS network binding**


**[SWS_CM_90101]**{DRAFT} **Secure UDP and TCP channel creation for TLS, DTLS and SecOC** *[*The Communication Management software shall create secure UDP channels according to the input for all SecureComProps referenced by ServiceInstanceToMachineMapping in the role secureComPropsForUdp. The Communication Management software shall create secure TCP channels according to the input for all SecureComProps referenced by ServiceInstanceToMachineMapping in the role secureComPropsForTcp. Secure channels may be shared by multiple AdaptivePlatformServiceInstances by multiplexing the communication, i.e. by referencing the same SecureComProps in the same role.*♩(RS_CM_00801)*

> **[SWS_CM_90101]**{草案} **安全UDP和TCP通道的创建以支持TLS、DTLS和SecOC** *[*通信管理软件根据输入创建安全UDP通道，其中由角色secureComPropsForUdp中的ServiceInstanceToMachineMapping引用的所有SecureComProps都将受到影响。 通信管理软件根据输入创建安全TCP通道，其中由角色secureComPropsForTcp中的ServiceInstanceToMachineMapping引用的所有SecureComProps都将受到影响。 多个AdaptivePlatformServiceInstances可以通过复用通信来共享安全通道，即通过在同一角色中引用相同的SecureComProps。*♩(RS_CM_00801)*


**[SWS_CM_90102]**{DRAFT} **Using secure TLS, DTLS and SecOC channels** *[*All communication triggered by a Skeleton or Proxy shall be sent via the respective secure channel according to the configuration input. In the configuration the appropriate secure channel is identified by examining the references to SecureComProps of ServiceInstanceToMachineMapping for the AdaptivePlatformServiceInstance that is mapped to an EthernetCommunicationConnector of a Machine by this ServiceInstanceToMachineMapping.*♩(RS_CM_00801, RS_CM_00803)*

> **[SWS_CM_90102]{草稿}** 使用安全的TLS、DTLS和SecOC通道*[*由Skeleton或Proxy触发的所有通信都应按照配置输入通过相应的安全通道发送。在配置中，通过检查对ServiceInstanceToMachineMapping的SecureComProps的引用来标识适当的安全通道，该ServiceInstanceToMachineMapping将AdaptivePlatformServiceInstance映射到机器的EthernetCommunicationConnector上。*♩(RS_CM_00801, RS_CM_00803)*


The actual secure channel to be created is determined by the concrete sub-class of the SecureComProps base-class.

> 实际要创建的安全通道由SecureComProps基类的具体子类确定。


**[SWS_CM_90201]**{DRAFT} **Secure TLS and DTLS channel creation in the DDS Network Binding** *[*Secure channels shall be created as specified in [[SWS_CM_90101](#_bookmark299)].*♩(RS_CM_00801)*

> **[SWS_CM_90201]**{草案} **在DDS网络绑定中创建安全的TLS和DTLS通道** *[*应按照[[SWS_CM_90101](#_bookmark299)]中的规定创建安全通道。*♩(RS_CM_00801)*

