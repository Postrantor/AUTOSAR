---
tip: translate by openai@2023-06-23 22:20:07
...
# Contents

7. # Functional specification

   1. ## General description


The AUTOSAR Adaptive architecture organizes the software of the AUTOSAR Adaptive foundation as functional clusters. These clusters offer common functionality as services to the applications. The Communication Management (CM) for AUTOSAR Adaptive is such a functional cluster and is part of \"AUTOSAR Runtime for Adaptive Applications\" ARA. It is responsible for the construction and supervision of communication paths between applications, both local and remote.

> AUTOSAR Adaptive架构将AUTOSAR Adaptive基础软件组织为功能集群。这些集群为应用程序提供公共功能服务。AUTOSAR Adaptive的通信管理（CM）是这样一个功能集群，是“AUTOSAR运行时适应性应用程序”ARA的一部分。它负责在应用程序之间建立和监控本地和远程的通信路径。


The CM provides the infrastructure that enables communication between Adaptive AUTOSAR Applications within one machine and with software entities on other machines, e.g. other Adaptive AUTOSAR applications or Classic AUTOSAR SWCs. All communication paths can be established at design, start-upor run-time.

> 系统管理器提供基础设施，可以在一台机器上的自适应AUTOSAR应用之间以及与其他机器上的软件实体之间进行通信，例如其他自适应AUTOSAR应用程序或经典AUTOSAR SWCs。所有通信路径都可以在设计、启动或运行时建立。


This specification includes the syntax of the API, the relationship of API to the model and describes semantics, e.g. through state machines, and assumption of pre-, postconditions and use of APIs. The specification does not provide constraints on the SW architecture of a platform implementation, so there is no definition of basic software modules and no specification of implementation or internal technical architecture of the Communication Management.

> 这个规范包括API的语法，API与模型之间的关系，以及通过状态机等方式描述的语义，以及前提条件、后果条件和使用API的假设。该规范不对平台实现的软件架构提出约束，因此没有基本软件模块的定义，也没有通信管理的实现或内部技术架构的规范。

### Architectural concepts


The Communication management of AUTOSAR Adaptive can be logically divided into the following sub-parts:

> AUTOSAR Adaptive的通信管理可以逻辑上划分为以下几个部分：

- Language binding
- End-to-end communication protection
- Communication / Network binding
- Communication Management software

![](./media/image5.png)**Figure 7.1:** **Technical Architecture of Communication Management**


In the context of Communication Management, the following types of interfaces are defined:

> 在通信管理的背景下，定义了以下类型的接口：


- Public Application Interface: Part of the Adaptive AUTOSAR API and specified in the SWS. This is the standardized ara::com API.

> 公共应用程序接口：Adaptive AUTOSAR API的一部分，并在SWS中指定。这是标准的ara :: com API。

- Functional Cluster Interactions: Interaction between functional clusters. Not normative, intended to make specification more readable and to support integration of SW into demonstrator. (dotted arrow in [7.1](#_bookmark3)) And also interactions between elements within a functional cluster. Not used in specifications, so it is a nonstandardized interface. Used for communication inside Communication Management software (grey arrow in [7.1](#_bookmark3))

> 功能集群交互：功能集群之间的交互。不是规范性的，旨在使规范更易读，并支持软件集成到演示系统中。（[7.1]（＃_bookmark3）中的虚线箭头）还有功能集群内部元素之间的交互。不在规范中使用，因此是非标准化的接口。用于通信管理软件内部的通信（[7.1]（＃_bookmark3）中的灰色箭头）。


Please note, that Language Binding and Communication Binding depend on a specific configuration by the integrator, but they need to be deployed within the application binary. This results in the fact that the serialization of the Communication Binding will run in the execution context of the Adaptive Application.

> 请注意，语言绑定和通信绑定取决于集成器的特定配置，但它们需要部署在应用程序二进制文件中。这导致通信绑定的序列化将在自适应应用程序的执行上下文中运行。

For the design of ARA API the following constraints apply:

- Support the independence of application software components
- Use of Service-oriented communication without dependency on a specific communication protocol

- Make the API as lean as possible, neither supporting very specific use cases which could also be done on top of the API, nor supporting component model or higher level concepts. The API is restricted to support core communication mechanisms.

> 尽可能使API精简，不支持可以在API之上完成的特定用例，也不支持组件模型或更高级概念。该API仅限于支持核心通信机制。
- Support for dynamic communication:


  No discovery by application middleware, the clients know the server but the Server does not know the clients. Event subscription is the only dynamic communication pattern in the application.

> 没有应用中间件的发现，客户端知道服务器，但服务器不知道客户端。事件订阅是应用程序中唯一的动态通信模式。

  Full service discovery in the application. No communication paths are known at configuration time. An API for Service discovery allows the application code to choose the service instance.

> 应用程序中的全面服务发现。在配置时间不知道通信路径。服务发现的API允许应用程序代码选择服务实例。

- Support both Event/Callback and Polling style usage of the API to enable classic RTE style paradigms. To support high determinism demands in case of callbackbased / event-based interaction, there shall be the possibility to avoid uncontrolled context switches.

> 支持API的事件/回调和轮询样式使用，以实现经典的RTE样式范式。为了支持回调/事件基础的交互中的高确定性要求，应该有可能避免不受控制的上下文切换。
- Support both synchronous callback-based communication and asynchronous communication philosophy.
- Support of client/server communication.

- Support of sender/receiver communication with queued semantics where the receiver caches are configurable.

> 支持发送者/接收者使用队列语义进行通信，其中接收者缓存可配置。
- Support of selection of trigger conditions for task activation.
- Extensions for security.
- Extensions for Quality Of Service QoS.
- Scalability for real-time systems.

- Support of built-in end-to-end communication protection, where a use-casespecific behavior can be done on top of ARA API.

> 支持内置的端到端通信保护，可以在ARA API之上实现特定用例的行为。

  1. ### Design decisions

The design of the ARA API covers the following principles:

- It uses the Proxy/Skeleton pattern:


  The (service) proxy is the representative of the possibly remote (i.e. other process, other core, other node) service. It is an instance of a C++ class local to the application/client, which uses the service.

> 代理服务是可能远程（即其他进程、其他核心或其他节点）服务的代表。它是应用程序/客户端本地的C++类的一个实例，它使用该服务。

  The (service) skeleton is the connection of the user provided service implementation to the middleware transport infrastructure. Service implementation class is derived from the (service) skeleton.

> 服务骨架是将用户提供的服务实现连接到中间件传输基础设施的连接。服务实现类是从服务骨架导出的。

  Beside proxies/skeletons, there might exist a so-called \"Runtime\" (singleton) class to provide some essentials to manage proxies and skeletons. But this is communication management software implementation specific and therefore not specified in this document, but may be specified in a future version.

> 除了代理/骨架之外，可能存在所谓的“运行时”(单例)类，以提供一些必要的东西来管理代理和骨架。但这是通信管理软件实现特定的，因此本文档中未指定，但可能在未来的版本中指定。


Regarding proxy/skeleton design pattern in general and its role in middleware implementations, see [9] [10].

> 关于代理/骨架设计模式的概述及其在中间件实现中的作用，请参见[9] [10]。

- It supports callback mechanisms on data reception.

- The API has zero-copy capabilities including the possibility for memory management in the middleware.

> API具有零复制功能，包括中间件中内存管理的可能性。

- It is aligned with the AUTOSAR service model (services, instances, events, methods, \...) to allow the generation of proxies and skeletons out of this model.

> 它与AUTOSAR服务模型（服务、实例、事件、方法等）对齐，可以根据此模型生成代理和骨架。
- Full discovery and service instance selection support on API level.

- Client/Server Communication uses concepts introduced by C++11 language, e.g. std::future, std::promise, to fully support method calls between different contexts.

> 客户端/服务器通信使用C++11语言引入的概念，例如std::future，std::promise，来全面支持不同上下文之间的方法调用。

- Abstract from SOME/IP specific behavior, but support SOME/IP service mechanisms, as methods, events and fields.

> 抽象出SOME/IP特定行为，但支持SOME/IP服务机制，如方法、事件和字段。
- Support/implement the standard end-to-end protection protocols, as specified in

[7] and [4].

- Support of Service contract versioning.
- Support Event and Polling style usage of the API equally to enable classic RT style paradigms.

- Fully exploit C++11/14 features in API design to provide usability and comfort for the application developer.

> 充分利用C++11/14特性设计API，为应用开发者提供便捷和舒适的使用体验。


See ARAComAPI explanatory [1] for more details and explanations on the ARA API design.

> 请参阅ARAComAPI说明[1]，了解更多有关ARA API设计的细节和解释。

### Communication paradigms


Service-Oriented Communication (SoC) as a part of Service-Oriented Architecture (SOA) [11] is the main communication pattern for Adaptive AUTOSAR Applications. It allows establishing communication paths both at run-time, so it can be used to build up dynamic communication with unknown number of participants. Figure [7.2](#_bookmark8) shows the basic operation principle of Service-Oriented Communication.

> 服务导向通信（SoC）作为服务导向架构（SOA）[11]的一部分是自适应AUTOSAR应用程序的主要通信模式。它允许在运行时建立通信路径，因此可用于与未知数量的参与者建立动态通信。图[7.2]（＃_bookmark8）显示了服务导向通信的基本操作原理。

**Figure 7.2:** **Service-Oriented Communication**


Service Discovery decides whether external and internal service-oriented communication is established. The discovery strategy shall allow either returning a specific service instance or all available instances providing the requested service at the time of the request, no matter if they are available locally or remote. The Communication Management software should provide an optimized implementation for both the Service discovery and the communication connection, depending on the location where the service provider resides. More about Service Discovery can be found in *SOME/IP Service Discovery Protocol Specification* [12].

> 服务发现决定是否建立面向服务的外部和内部通信。发现策略应允许返回特定的服务实例或在请求时所有可用的提供所请求服务的实例，无论它们是本地还是远程可用。通信管理软件应根据服务提供者所在的位置提供服务发现和通信连接的优化实现。有关服务发现的更多信息可以在* SOME / IP服务发现协议规范* [12]中找到。


The service class is the central element of the Service-Oriented Communication pattern applied in Adaptive AUTOSAR. It represents the service by collecting the methods and events which are provided or requested by the applications implementing the concrete service functionality.

> 服务类是Adaptive AUTOSAR应用的服务导向通信模式的核心元素。它通过收集实现具体服务功能的应用程序提供或请求的方法和事件来表示服务。

### Service contract versioning


In Service Oriented Architecture (SOA) environments the client and the provider of a service rely on a contract which covers the service interface and behavior. The interface and the behavior of a service may change over time. Therefore, service contract versioning has been introduced to differentiate between the different versions of a service.

> 在面向服务的架构（SOA）环境中，服务提供者和客户端依赖于一个涵盖服务接口和行为的合同。服务的接口和行为可能会随着时间的推移而发生变化。因此，引入了服务合同版本控制来区分不同版本的服务。

![](./media/image6.jpeg){width="5.627187226596676in" height="1.5709372265966755in"}

**Figure 7.3: Service contract versioning over time**


The AUTOSAR Adaptive platform supports service contract versioning. The service contract versioning is separated between the design phase and the deployment phase. This means that any service at design level may have its own version number which is mapped to a version number of the used network binding and vice versa. The mapping process is manually done by the service designer or integrator.

> AUTOSAR自适应平台支持服务合同版本控制。服务合同版本控制在设计和部署阶段分开。这意味着任何在设计级别的服务都可以有自己的版本号，这个版本号映射到所使用的网络绑定的版本号，反之亦然。映射过程由服务设计师或集成器手动完成。

![](./media/image7.jpeg){width="6.290103893263342in" height="4.225in"}

**Figure 7.4: Service contract versioning flow**

Note:


1. The contract version of a ServiceInterface consists of a majorVersion and a minorVersion number. The majorVersion number indicates backwardsincompatible service changes. The minorVersion number indicates backwardscompatible service changes.

> 合同版本的服务接口由主版本号和次版本号组成。主版本号表示向后不兼容的服务变更。次版本号表示向后兼容的服务变更。


   for backwards-incompatible interface or behavior changes the majorVersion

> 对于不兼容的接口或行为更改，主要版本

number is increased and the minorVersion number is set to 0.

- for backwards-compatible interface or behavior changes the majorVersion

number is unchanged and the minorVersion number is increased.


2. The contract version of a ServiceInterface is mapped to a version of the ServiceInterfaceDeployment. This version mapping may be done several times resulting in several ServiceInterfaceDeployments for the same ServiceInterface. Such a mapping will result in unambiguous identification on each VLAN according to the [constr_1723] in [6].

> 同一个ServiceInterface的合同版本可以映射到多个版本的ServiceInterfaceDeployment。这种映射可以多次进行，导致同一个ServiceInterface有多个ServiceInterfaceDeployment。根据[6]中的[constr_1723]，这种映射可以在每个VLAN上确定唯一的标识符。


**[SWS_CM_99003]**{DRAFT} *[*The version of ServiceInterfaceDeployment shall be evaluated by the Service Discovery in terms of backwards-compatibility based on the used network binding for service connection.*♩(RS_CM_00500, RS_CM_00501, RS_CM_00700)*

> **[SWS_CM_99003]**{草稿} *[*服务接口部署的版本应根据用于服务连接的网络绑定，由服务发现来评估其向后兼容性。*♩(RS_CM_00500, RS_CM_00501, RS_CM_00700)*

1. ## Raw Data Streaming

   1. ### Raw Data Streaming Interface


In some cases it is necessary for the application software to be able to process raw binary data streams sent over a communication channel. In a raw binary data stream the data is not typed, and is handled as a continuing sequence of bytes. So serialization of the data is not necessary. This section specifies an interface as part of ara::com to support processing of raw binary data streams, as an alternative to SOME/IP.

> 在某些情况下，应用软件需要能够处理通过通信通道发送的原始二进制数据流。在原始二进制数据流中，数据没有类型，并且被处理为一个连续的字节序列。因此，不需要对数据进行序列化。本节指定了ara :: com的一部分接口，以支持处理原始二进制数据流，作为SOME / IP的替代方案。


The interface is statically defined and independent of the underlying network protocol. However, currently the modeling for the Raw Data Streaming Interface only supports TCP/IP sockets as transport layer. Both unicast and multicast socket connections shall be supported. The sockets can use both TCP or UDP as transport protocol. TCP is the natural choice for RawDataStreams since it is a reliable stream oriented protocol. However, UDP shall also be supported when an unreliable connection is acceptable for the application.

> 界面是静态定义的，独立于底层网络协议。但是，目前，原始数据流接口的建模仅支持TCP/IP套接字作为传输层。应支持单播和多播套接字连接。套接字可以使用TCP或UDP作为传输协议。对于原始数据流，TCP是可靠的流导向协议的自然选择。但是，当应用程序可以接受不可靠的连接时，也应支持UDP。


The operations of the interface are synchronous. The default behavior is blocking, but a timeout handling shall be implemented to return the call with an error if the operation takes too long. The timeout values are applied as parameters to each operation. See the description for each operation below on how the timeout handling is applied.

> 界面的操作是同步的。默认行为是阻塞的，但应实现超时处理以在操作时间过长时返回调用并返回错误。超时值作为参数应用于每个操作。请参见下面每个操作的描述，了解如何应用超时处理。


The integration of the Raw Data Streaming Interface and Adaptive Applications is done in the deployment phase, by specifying various attributes and parameters for the socket connections that shall be used for the Raw Data Stream, using RawDataStreamMapping and EthernetRawDataStreamMapping. The model and the parameters are described in *TPS_ManifestSpecification* [6].

> 在部署阶段，通过使用RawDataStreamMapping和EthernetRawDataStreamMapping指定用于原始数据流的各种属性和参数，实现原始数据流界面和自适应应用程序的集成。模型和参数描述在*TPS_ManifestSpecification*[6]中。


Secure communication can be achieved by applying TLS or IPSec protocols in the middleware. Also access control imposed by the IAM can be applied for Raw Data

> 安全通信可以通过在中间件中应用TLS或IPSec协议来实现。此外，可以通过IAM施加的访问控制来应用原始数据。


Streams. All security functions are configurable in the deployment and mapping model of Raw Data Streaming Interface, see *TPS_ManifestSpecification* [6].

> 流。所有安全功能都可以在原始数据流接口的部署和映射模型中进行配置，请参见*TPS_ManifestSpecification*[6]。


For safety critical applications wanting to use RawDataStreaming, a safety analysis needs to be done by the application developer, to find relevant communication faults for the stream data. If a protection of data exchange algorithm is needed, such as E2E protection, this will not be provided in the RawDataStream interface, but is to be implemented in the application layer that is using the RawDataStream interface. This is because only raw data with no data type information is transferred over the RawDataStream.

> 用于安全关键应用的RawDataStreaming需要应用开发人员进行安全分析以找出流数据的相关通信故障。如果需要数据交换算法的保护，例如端到端保护，则不会在RawDataStream接口中提供，而是需要在使用RawDataStream接口的应用层中实现。这是因为只有没有数据类型信息的原始数据才能通过RawDataStream传输。


An application can use the Raw Data Streaming API both as a client (connecting to a listening Raw Data Streaming service) or server (waiting for incoming connections from clients).

> 一个应用程序可以使用原始数据流API既作为客户端（连接到侦听原始数据流服务），也可以作为服务器（等待来自客户端的连接）。


Figure [7.5](#_bookmark12) shows the logical view of the usage of RawDataStream instances.

> 图7.5显示了RawDataStream实例的逻辑视图。

![](./media/image8.jpeg){width="6.046874453193351in" height="3.276561679790026in"}

**Figure 7.5:** **Raw Data Stream Logical View.**

### Limitations


The current solution does not support any runtime variance in terms of network topology, such as service discovery functionality, which means that the RawDataStreams has to be configured statically on the same ECU as the application. Dynamic configuration and runtime functionality will be added in future releases if needed.

> 目前的解决方案不支持网络拓扑结构上的任何运行时变化，例如服务发现功能，这意味着RawDataStreams必须在与应用程序相同的ECU上进行静态配置。如果需要，将在未来发行版中添加动态配置和运行时功能。


The multicast support is limited to one-to-many, i.e. a server can send data to multiple clients using multicast, but only receive data from one client, using the unicast

> 多播支持仅限一对多，即服务器可以使用多播向多个客户端发送数据，但只能使用单播接收来自一个客户端的数据。


address. Also multicast shall only be used with UDP. For TCP connections, only 1-to-1 connections are supported, i.e. multiple clients to one server is not supported.

> 地址。只能使用UDP来使用多播。仅支持1对1的TCP连接，即不支持多个客户端连接到一个服务器。

### Use cases

The RawDataStream interface can be used in the following set-ups:

- Client (connect to) to an external non-AUTOSAR sensor providing raw data on a socket connection.

- Server (wait for a connection from) for an external non-AUTOSAR sensor providing raw data on a socket connection.

> 服务器（等待来自）外部非AUTOSAR传感器的连接，该传感器通过套接字连接提供原始数据。
- Client or Server for another AUTOSAR external RawDataStream instance.


RawDataStream socket connections can be setup for UDP or TCP, Unicast or Multicast. Currently the use cases in fig [7.6](#_bookmark15) are supported.

> 可以为UDP或TCP、单播或多播设置原始数据流套接字连接。目前支持图7.6中的用例。

![](./media/image9.png){width="1.8246576990376202in" height="0.14583333333333334in"}![](./media/image10.png){width="0.5989577865266842in" height="0.3645833333333333in"} ![](./media/image11.png){width="0.6273129921259842in" height="6.635389326334208e-2in"}

![](./media/image12.png){width="0.5989577865266842in" height="0.3645833333333333in"}![](./media/image13.png){width="0.6323228346456693in" height="6.499890638670167e-2in"}![](./media/image14.png){width="4.205056867891513in" height="1.0208333333333333in"}![](./media/image15.png){width="0.5989577865266842in" height="0.3645833333333333in"}![](./media/image16.png){width="1.8231200787401576in" height="8.333333333333333e-2in"}![](./media/image17.png)![](./media/image18.png){width="0.6075142169728784in" height="0.3697911198600175in"}![](./media/image19.png){width="3.961777121609799in" height="8.333333333333333e-2in"}

![](./media/image20.png)

![](./media/image22.png){width="2.451048775153106in" height="0.14583333333333334in"}

**Figure 7.6:** **The currently supported use cases for Raw Data Streams, and which artifacts in the Deployment model that shall be used to configure the different use cases**

### Raw Data Streaming

For the Raw Data Stream C++ API reference, see chapter 8.1.3.21.


**[SWS_CM_10476] Defining a RawDataStream** *[*To open a RawDataStream connection a RawDataStream instance is created. The constructor creates the necessary socket data structures for RawDataStream Communication, using the artifacts specified in the mapped EthernetRawDataStreamClientMapping and EthernetRawDataStreamServerMapping.*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

> **[SWS_CM_10476] 定义 RawDataStream** *[*要打开一个 RawDataStream 连接，必须创建一个 RawDataStream 实例。构造函数使用映射的 EthernetRawDataStreamClientMapping 和 EthernetRawDataStreamServerMapping 中指定的工件创建必要的套接字数据结构，用于 RawDataStream 通信。*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

### [SWS_CM_99004] {DRAFT} Ethernet endpoint configuration *[*


Ethernet socket connections are statically configured in the Deployment model as part of the Service Instance Manifest, and used throughout the connected session for the RawDataStreams communication. The following configuration elements can be specified on the Deployment model of each RawDataStreamClient or RawDataStreamServer instance, identified through the InstanceSpecifier provided to the constructor.

> 以太网插座连接在部署模型中是作为服务实例清单的一部分静态配置的，并在整个连接会话中用于RawDataStreams通信。以下配置元素可以在每个RawDataStreamClient或RawDataStreamServer实例的部署模型中指定，通过提供给构造函数的InstanceSpecifier进行标识。

RawDataStreamClient endpoint and credentials configuration elements:

- Local Network Endpoint: EthernetRawDataStreamClientMapping.localCommConnector
- Local UdpPort: EthernetRawDataStreamClientMapping.localUdpPort
- Local TcpPort: EthernetRawDataStreamClientMapping.localTcpPort
- Socket Options: EthernetRawDataStreamClientMapping.socketOption
- (D)TLS properties: EthernetRawDataStreamClientMapping.tlsSecureComProps
- Remote Unicast Credentials: EthernetRawDataStreamClientMapping. unicastCredentials (UDP/TCP)
- Multicast Credentials: EthernetRawDataStreamClientMapping.multicastCredentials (UDP only)

RawDataStreamServer endpoint and credentials configuration elements:

- Local Network Endpoint: EthernetRawDataStreamServerMapping.localCommConnector
- Local UdpPort: EthernetRawDataStreamServerMapping.localUdpPort
- Local TcpPort: EthernetRawDataStreamServerMapping.localTcpPort
- Socket Options: EthernetRawDataStreamServerMapping.socketOption
- (D)TLS properties: EthernetRawDataStreamServerMapping.tlsSecureComProps
- Remote Unicast Credentials: EthernetRawDataStreamServerMapping. unicastUdpCredentials (UDP only)
- Multicast Credentials: EthernetRawDataStreamServerMapping.multicastCredentials (UDP only)

For the RawDataStreamClients the following shall apply:


- Remote server credentials for unicast communication must always be defined for the client. The Unicast remote server credentials are configured in RawDataStreamEthernetTcpUdpCredentials aggregated by the EthernetRawDataStreamClientMapping in the role unicastCredentials.

> 远程服务器凭据必须为客户端定义单播通信。单播远程服务器凭据由EthernetRawDataStreamClientMapping中的RawDataStreamEthernetTcpUdpCredentials聚合配置在角色unicastCredentials中。

- A tcpPort and udpPort shall not be defined in the same RawDataStreamEthernetTcpUdpCredentials element.

> 一个RawDataStreamEthernetTcpUdpCredentials元素中不应该定义tcpPort和udpPort。

- If a TcpPort is defined in the EthernetRawDataStreamClientMapping.unicastCredentials, these credentials are used for Connect() calls to establish the connection to the server.

> 如果在EthernetRawDataStreamClientMapping.unicastCredentials中定义了TcpPort，则这些凭据将用于Connect（）调用以建立与服务器的连接。

- This unicast connection shall always be used for WriteData() calls to send data to the server (for both UDP and TCP).

> 这个单播连接应该总是用于调用WriteData()向服务器发送数据（无论是UDP还是TCP）。

- If Multicast Credentials are defined for the client, the RawDataStream shall bind and join the multicast address and udpPort given in the MulticastCredentials. The MulticastCredentials is configured in RawDataStreamEthernetUdpCredentials aggregated by the EthernetRawDataStreamClientMapping. This multicast socket connection shall be read from when ReadData() is called.

> 如果为客户端定义了多播凭据，RawDataStream应绑定并加入在多播凭据中给出的多播地址和udp端口。多播凭据由EthernetRawDataStreamClientMapping聚合配置。当调用ReadData()时，应该从此多播套接字连接中读取数据。

- If no MulticastCredentials are defined for the client, the Unicast Remote Credentials shall also be used for ReadData() calls.

> 如果客户端没有定义多播凭据，则应将单播远程凭据也用于ReadData（）调用。

For the RawDataStreamServers the following shall apply:


- If Multicast Credentials is defined for the server, a multicast connection shall be created using the Multicast Credentials which are configured in RawDataStreamEthernetUdpCredentials aggregated by the EthernetRawDataStreamServerMapping in the role multicastCredentials. Then the data is sent on this multicast socket when WriteData() is called.

> 如果为服务器定义了多播凭据，则应使用在EthernetRawDataStreamServerMapping角色的multicastCredentials中配置的多播凭据创建多播连接。然后，在调用WriteData()时，将数据发送到此多播套接字。

- If Remote Unicast Credentials are defined for the server, a unicast socket shall be created using the Unicast Credentials which are configured in RawDataStreamEthernetUdpCredentials aggregated by the EthernetRawDataStreamServerMapping in the role unicastUdpCredentials. Then the data is sent on this unicast socket when WriteData() is called.

> 如果服务器定义了远程单播凭据，则应使用EthernetRawDataStreamServerMapping中以unicastUdpCredentials聚合的RawDataStreamEthernetUdpCredentials中配置的单播凭据创建单播套接字。然后，调用WriteData()时会在此单播套接字上发送数据。

- The local credentials defined in EthernetCommunicationConnector shall always be used to create a unicast socket and read data from a client when ReadData() is called on the server side. If no local credentials are defined, reading of data from the server cannot be performed, and an error kStreamNotConnected will be returned.

> 本地凭据定义在EthernetCommunicationConnector中，当在服务器端调用ReadData()时，总是使用该本地凭据来创建单播套接字并从客户端读取数据。如果没有定义本地凭据，则无法从服务器读取数据，并返回错误kStreamNotConnected。

- If a localTcpPort is defined in EthernetRawDataStreamServerMapping, the credentials defined in EthernetCommunicationConnector are used to create, bind, and listen to the socket used for TCP communication when the constructor of RawDataStream is called. Then the server accepts incoming connection requests when WaitForConnection() is called.

> 如果在EthernetRawDataStreamServerMapping中定义了localTcpPort，那么在构造RawDataStream时，就会使用EthernetCommunicationConnector中定义的凭据来创建、绑定和侦听用于TCP通信的套接字。然后，当调用WaitForConnection()时，服务器就会接受传入的连接请求。

*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*


**[SWS_CM_90216]**{DRAFT} **Socket Options configuration** *[*For both RawDataStreamClients and RawDataStreamServers a list of socket options can be defined in the attribute socketOption to be applied to the sockets created for unicast or multicast communication. The options shall be specified as a list of strings. The accepted values are platform specific and shall be documented by the vendor.*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

> **[SWS_CM_90216]**{草案} **套接字选项配置** *[*对于RawDataStreamClients和RawDataStreamServers，可以在属性socketOption中定义一系列套接字选项，用于单播或多播通信所创建的套接字。该选项应指定为字符串列表。接受的值是特定于平台的，并由供应商进行文档化。*♩（RS_CM_00410，RS_CM_00411，RS_CM_00412）*


An example of socketOption definition is to provide a series of \"option\", \"value\" pairs for POSIX socket level options, e.g.: [\"SO_KEEPALIVE\", \"1\", SO_RCVBUF\",\"1024\"]

> 一个socketOption定义的示例是为POSIX socket级别选项提供一系列的“选项”，“值”对，例如：[“SO_KEEPALIVE”，“1”，SO_RCVBUF”，“1024”]。


**[SWS_CM_90217]**{DRAFT} **TLS properties configuration** *[*For both RawDataStreamClients and RawDataStreamServers (D)TLS properties can be defined in the attributes tlsSecureComProps to configure usage of TLS to create secure UDP and TCP channels for the RawDataStreams according to the Transport Layer Security protocol. See [[SWS_CM_90211](#_bookmark302)]*♩(RS_CM_00410, RS_CM_00411)*

> **[SWS_CM_90217]**（草案）**TLS 属性配置** *[*对于RawDataStreamClients和RawDataStreamServers，可以在属性tlsSecureComProps中定义（D）TLS属性，以便按照传输层安全协议为RawDataStreams创建安全的UDP和TCP通道。参见[[SWS_CM_90211](#_bookmark302)]*♩（RS_CM_00410，RS_CM_00411）*

简体中文：**[SWS_CM_90217]**（草案）**TLS 属性配置** *[*对于RawDataStreamClients和RawDataStreamServers，可以在属性tlsSecureComProps中定义（D）TLS属性，以便按照传输层安全协议为RawDataStreams创建安全的UDP和TCP通道。参见[[SWS_CM_90211](#_bookmark302)]*♩（RS_CM_00410，RS_CM_00411）*


Note: Usage of (D)TLS is restricted to 1:1 socket connections (use case 1 and 2 of figure [Figure](#_bookmark15) [7.6](#_bookmark15)).

> 注意：（D）TLS 的使用仅限于 1:1 套接字连接（参见图 7.6 中的使用情况 1 和 2）。


The functionality of a RawDataStream for Client communication is realized in these four operations: Connect, Shutdown, ReadData and WriteData. A RawDataStream for Server Communication is realized in these four operations: WaitForConnection, Shutdown, ReadData and WriteData.

> 功能实现客户端通信的RawDataStream有四个操作：连接、关闭、读取数据和写入数据。实现服务器通信的RawDataStream有四个操作：等待连接、关闭、读取数据和写入数据。


**[SWS_CM_10477] Connect stream link** *[*Each invocation of the Connect operation for a TCP socket connection shall establish a communication link with a remote server that is listening for socket connections, The socket created in the RawDataStream instance shall be used for the connection. For UDP socket connections Connect shall do nothing.*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

> **[SWS_CM_10477] 连接流链接** *[*每次调用TCP套接字连接的连接操作都将与侦听套接字连接的远程服务器建立通信链路，RawDataStream实例中创建的套接字将用于连接。对于UDP套接字连接，Connect不执行任何操作。*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*


**[SWS_CM_99005]**{DRAFT} **Wait for incoming connections** *[*Each invocation of the WaitForConnection operation shall wait for and accept incoming requests for establishment of a TCP communication link with a connecting remote client. The socket created and prepared in the RawDataStream instance shall be used for the connection. For UDP socket connections WaitForConnection shall do nothing.*♩(RS_CM_00411, RS_CM_00412)*

> **[SWS_CM_99005]**{草案} **等待传入的连接** *[*每次调用WaitForConnection操作都会等待并接受远程客户端发起的建立TCP通信链接的传入请求。在RawDataStream实例中创建和准备的套接字将用于连接。对于UDP套接字连接，WaitForConnection无需做任何操作。*♩(RS_CM_00411, RS_CM_00412)*


**[SWS_CM_10478] Shutdown stream link** *[*Each invocation of the Shutdown operation shall destroy the communication link for the stream.*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

> **[SWS_CM_10478] 关闭流链接** *[*每次调用关闭操作都将销毁流的通信链接。*♩（RS_CM_00410，RS_CM_00411，RS_CM_00412）*


**[SWS_CM_10479] Read data from stream** *[*Each invocation of the ReadData operation shall request to read a number of bytes from the stream. The read data shall be

> **[SWS_CM_10479] 从流中读取数据** *[*每次调用ReadData操作都应请求从流中读取一定数量的字节。读取的数据应该


moved to a buffer returned as result from the function, together with the actual number of bytes transferred.*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

> 将结果从函数返回的缓冲区中移动，同时传输实际的字节数。


**[SWS_CM_10480] Write data to stream** *[*Each invocation of the WriteData operation shall request to write a number of bytes to the stream and send it out on the socket connection. The actual number of bytes transferred shall be returned. It shall be possible to apply a timeout value for the operation. The operation shall write the data to the socket or internal buffer, and then return with the number of bytes written. For efficiency, the Write operation does not wait until data is actually sent on the bus, but the TCP data flow handling shall make sure that data is transmitted and received in the correct order. For UDP connections the order cannot be guaranteed.*♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)*

> [SWS_CM_10480] 向流写入数据*[*每次调用WriteData操作都将请求将一定数量的字节写入流并通过套接字连接发出。实际传输的字节数将被返回。可以为该操作应用超时值。该操作将将数据写入套接字或内部缓冲区，然后返回已写入的字节数。为了提高效率，Write操作不会等待数据实际发送到总线上，但TCP数据流处理应确保数据以正确的顺序发送和接收。对于UDP连接，无法保证顺序。*♩（RS_CM_00410，RS_CM_00411，RS_CM_00412）*


**[SWS_CM_99006]**{DRAFT} **Timeout handling** *[*For all Connect, WaitForConnection, Read and Write RawDataStream operations a timeout value can be specified via a parameter in runtime. If no timeout parameter is given the operation shall block. If a timeout value is specified, and the operation does not finish within the specified time, an error code RawErrc::kCommunicationTimeout shall be returned and the technical state of the RawDataStream connection shall be restored to the same as before the call was made.*♩(RS_CM_00410, RS_CM_00411)*

> **[SWS_CM_99006]**{草案} **超时处理** *[*对于所有的Connect、WaitForConnection、Read和Write RawDataStream操作，可以通过运行时参数指定超时值。如果没有指定超时参数，操作将会阻塞。如果指定了超时值，但操作未在指定时间内完成，将返回错误码RawErrc::kCommunicationTimeout，并将RawDataStream连接的技术状态恢复为调用之前的状态。*♩(RS_CM_00410, RS_CM_00411)*

## Communication Group


The Communication Group is a communication concept based on ara::com which is designed for Adaptive State Management applications. It can be seen as a composite Service which manages information routing in a defined manner. A Communication Group has one server and multiple clients. The server is able to send broadcast and peer to peer messages to the clients of a Communication Group. The clients can acknowledge these messages. The server of a Communication Group can further verify how many clients are connected to the Communication Group at every time. Applications can connect/disconnect to a Communication Group instance using one of the two Communication Group Service Interfaces, CommunicationGroupServer or CommunicationGroupClient.

> 通信组是一种基于ara::com的通信概念，专为自适应状态管理应用而设计。它可以被看作是一种复合服务，能够以定义的方式管理信息路由。通信组由一个服务器和多个客户端组成。服务器能够向通信组的客户端发送广播和点对点消息，客户端可以确认这些消息。通信组的服务器还可以验证每次有多少客户端连接到通信组。应用程序可以使用两个通信组服务接口之一，即CommunicationGroupServer或CommunicationGroupClient，连接/断开通信组实例。

![](./media/image23.png)

**Figure 7.7: Communication Group**

### Interfaces


The Communication Group uses two Service interfaces, one for a Communication Group Server and one for Communication Group clients.

> 通信组使用两个服务接口，一个用于通信组服务器，另一个用于通信组客户端。

### Communication Group Server


**[SWS_CM_99000]**{DRAFT} **CommunicationGroupServer Service** *[*A Communication Group shall provide a CommunicationGroupServer Service to be used by the Server of a Communication Group.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99000]**{草案} **通信组服务器服务** *[*一个通信组应提供一个通信组服务器服务，供通信组的服务器使用。*♩(RS_CM_00600, RS_CM_00601)*


**[SWS_CM_99001]**{DRAFT} **Broadcast method of CommunicationGroupServer Service** *[*The CommunicationGroupServer Service shall provide the method broadcast to broadcast messages to the clients of the Communication Group. This method shall take as input parameter the message to be broadcasted. In case the boardcast method fails the method return shall provide an error code as specified in [[SWS_CM_99024](#_bookmark506)].*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99001]**{草稿} **通信组服务的广播方法** *[*通信组服务应提供广播方法，以将消息广播到通信组的客户端。该方法的输入参数为要广播的消息。如果广播方法失败，方法返回值应提供[[SWS_CM_99024](#_bookmark506)]中指定的错误代码。*♩(RS_CM_00600, RS_CM_00601)*


The C++ signature below presents the resulting boardcast method of a generated Service Proxy/Skeleton interface.

> 下面的C++签名展示了生成的服务代理/骨架接口的结果广播方法。

template \<typename T\>

ara::core::Future\<void\> broadcast (const T& msg);


**[SWS_CM_99002]**{DRAFT} **Peer To Peer Message method of CommunicationGroupServer Service** *[*The CommunicationGroupServer Service shall provide a method message to send a message to a dedicated client of the Communication Group. This method shall take as input parameters the message to be sent, and the clientID of the client which shall be addressed. In case the message method fails the method return shall provide an error code as specified in [[SWS_CM_99024](#_bookmark506)].*♩ (RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99002]**{草案} **通信组服务的点对点消息方法** *[*通信组服务应提供一种向指定通信组客户端发送消息的方法。该方法应以要发送的消息和要接收该消息的客户端ID作为输入参数。如果消息方法失败，则该方法的返回应按照[[SWS_CM_99024](#_bookmark506)]中的指定提供错误代码。*♩ (RS_CM_00600, RS_CM_00601)*


The C++ signature below presents the resulting message method of a generated Service Proxy/Skeleton interface.

> 以下C++签名展示了生成的服务代理/骨架接口的结果消息方法。

template \<typename T\>

ara::core::Future\<void\> message (std::uint32_t clientID, const T& msg);


**[SWS_CM_99014]**{DRAFT} **Message Response event of CommunicationGroupServer Service** *[*The CommunicationGroupServer Service shall provide an event response that contains the respond of a dedicated client to a broadcast or a peer to peer message of the Communication Group. The event shall provide the response message and the clientID of this response.*♩(RS_CM_00600, RS_CM_00601)*

> [SWS_CM_99014]{草稿} 通信组服务的消息响应事件  通信组服务应提供一个事件响应，其中包含专用客户端对通信组的广播或点对点消息的响应。该事件应提供响应消息和此响应的客户端ID。(RS_CM_00600, RS_CM_00601)


The C++ signature below presents the resulting event response message of a generated Service Proxy/Skeleton interface.

> 以下C++签名展示了生成的服务代理/骨架接口的结果事件响应消息。

template \<typename R\> struct Response {

std::uint32_t clientID; const R& responseMsg

}


**[SWS_CM_99015]**{DRAFT} **List Clients method of CommunicationGroupServer Service** *[*The CommunicationGroupServer Service shall provide a method listClients to report about the connected clients of the Communication Group. This method shall have no input parameters and shall return the list of clients. In case the listClients method fails the method return shall provide an error code as specified in [[SWS_CM_99024](#_bookmark506)].*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99015]**{草案} **CommunicationGroupServer 服务的客户端列表方法** *[*CommunicationGroupServer 服务应提供一个listClients 方法来报告通信组的连接客户端。此方法不应有输入参数，并应返回客户端列表。如果listClients 方法失败，则返回值应按[[SWS_CM_99024](#_bookmark506)]中指定的错误代码。*♩(RS_CM_00600, RS_CM_00601)*


The C++ signature below presents the resulting listClients method of a generated Service Proxy/Skeleton interface.

> 以下C++签名展示了生成的服务代理/骨架接口的结果listClients方法。

ara::core::Future\<ara::core::Vector\<std::uint32_t\>\> listClients();

### Communication Group Client


**[SWS_CM_99007]**{DRAFT} **CommunicationGroupClient Service** *[*The clients of a Communication Group shall provide a CommunicationGroupClient Service to be used by a Communication Group.

> **[SWS_CM_99007]**{草案} **通信组客户服务** *[*一个通信组的客户应提供一个通信组客户服务供通信组使用。

*♩(RS_CM_00600, RS_CM_00601)*


**[SWS_CM_99008]**{DRAFT} **Message method of CommunicationGroupClient Service** *[*The CommunicationGroupClient Service shall provide a method message for the client to receive a message from the Communication Group. This method shall take as input parameter the message. In case the message method fails the method return shall provide an error code as specified in [[SWS_CM_99024](#_bookmark506)].*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99008]**{草案} **CommunicationGroupClient服务的消息方法** *[*CommunicationGroupClient服务应提供一种消息方法，以便客户端从通信组接收消息。此方法应以消息为输入参数。如果消息方法失败，方法返回应提供在[[SWS_CM_99024](#_bookmark506)]中指定的错误代码。*♩(RS_CM_00600, RS_CM_00601)*


The C++ signature below presents the resulting message method of a generated Service Proxy/Skeleton interface.

> 以下C++签名展示了生成的服务代理/骨架接口的结果消息方法。

template \<typename T\>

ara::core::Future\<void\> message (const T& msg);


**[SWS_CM_99009]**{DRAFT} **Message Response event of CommunicationGroupClient Service** *[*The CommunicationGroupClient Service shall provide an event response for the client to send a response message to the Communication Group. The event shall provide the response message.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99009]**{草稿} **CommunicationGroupClient 服务的消息响应事件** *[*CommunicationGroupClient 服务应为客户端提供一个事件响应，以便客户端可以向通信组发送响应消息。该事件应提供响应消息。*♩(RS_CM_00600, RS_CM_00601)*


The C++ signature below presents the resulting event response message of a generated Service Proxy/Skeleton interface.

> 以下C++签名展示了生成的服务代理/骨架接口的结果事件响应消息。

template \<typename R\> const R& responseMsg;

### Behavior


The Communication Group performs the following tasks to enable a Communication Group.

> 通信小组执行以下任务以启用通信小组。


**[SWS_CM_99010]**{DRAFT} **Broadcast task** *[*A Broadcast task shall be triggered by the broadcast method of the CommunicationGroupServer Service. The CommunicationGroup shall forward this broadcast message to all connected clients by calling the message method of the CommunicationGroupClient Service from each connected client.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99010]**{草稿} **广播任务** *[*CommunicationGroupServer服务的广播方法将触发一个广播任务。CommunicationGroup将通过从每个连接的客户端调用CommunicationGroupClient服务的message方法，将此广播消息转发给所有连接的客户端。*♩(RS_CM_00600, RS_CM_00601)*


**[SWS_CM_99011]**{DRAFT} **Peer To Peer message task** *[*A Peer to Peer message task shall be triggered by the message method (which includes the client address) of the CommunicationGroupServer Service. The CommunicationGroup shall forward

> **[SWS_CM_99011]**{草案} **点对点消息任务** *[*点对点消息任务应由CommunicationGroupServer服务的消息方法（包括客户端地址）触发。CommunicationGroup应转发


this message to the addressed client by calling the message method of the CommunicationGroupClient Service of this client.*♩(RS_CM_00600, RS_CM_00601)*

> 请调用此客户端的CommunicationGroupClient服务的message方法，将此消息发送给收件人客户♩（RS_CM_00600，RS_CM_00601）。


**[SWS_CM_99012]**{DRAFT} **Message Response task** *[*The Message Response task shall be triggered by the message response event of the CommunicationGroupClient Service from a client . The CommunicationGroup shall forward this response message with the client source address to the message response event of the CommunicationGroupServer Service.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99012]**{草案}**消息响应任务** *[*消息响应任务应由客户端的CommunicationGroupClient服务的消息响应事件触发。CommunicationGroup应将此响应消息与客户端源地址转发到CommunicationGroupServer服务的消息响应事件♩(RS_CM_00600, RS_CM_00601)*


**[SWS_CM_99013]**{DRAFT} **List Clients task** *[*The List Clients task shall be triggered by the list clients method of the CommunicationGroupServer Service. The CommunicationGroup shall provide the list of all connected client addresses with the return of the list clients method of the CommunicationGroupServer Service.*♩ (RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99013]**{草案} **客户端列表任务** *[*客户端列表任务应该由通信组服务的客户端列表方法触发。通信组应该在通信组服务的客户端列表方法的返回中提供所有连接的客户端地址。*♩（RS_CM_00600，RS_CM_00601）*

### Connection


The connection and disconnection to Communication Group is performed by standard

> 通讯组的连接和断开连接是通过标准执行的

ara::com functions.

### Communication Group Server


The Server of a Communication Group connects to a Communication Group by connecting to the CommunicationGroupServer Service of this Communication group (using FindService or StartFindService).

> 服务器组织通过连接到此通信组织的CommunicationGroupServer服务（使用FindService或StartFindService）来连接到通信组织。


**[SWS_CM_99016]**{DRAFT} **Connection Status of a Communication Group Server** *[*The Server of the Communication Group shall be considered to be connected if the server has successfully subscribed to the response message response event of the CommunicationGroupServer Service, else the Server shall be considered not connected.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99016]**{草案} **通信组服务器的连接状态** *[*如果服务器已成功订阅通信组服务器服务的响应消息响应事件，则认为服务器已连接，否则认为服务器未连接。*♩(RS_CM_00600, RS_CM_00601)*

### Communication Group Client


A Communication Group client connects to a Communication Group by offering the CommunicationGroupClient Service. A Communication Group client disconnects to a Communication Group by stop offering the CommunicationGroupClient Service.

> 一个通信组客户端通过提供通信组客户端服务连接到通信组。一个通信组客户端断开与通信组的连接是通过停止提供通信组客户端服务。

### Limitations

The Communication Group concept has the following limitations:

- There is only one Server for an instance of a Communication Group at a given time.

- A Client provides the CommunicationGroupClient Service to only one instance of a Communication Group at a given time.

> 客户只能同时向一个通信组提供CommunicationGroupClient服务。

The figure below outlines a connection example for a Communication Group.

![](./media/image26.png){width="5.278894356955381in" height="2.4870833333333335in"}

**Figure 7.8: Communication Group connection example**

### Communication Group Model


The model of Communication Group is labeled by one of three standard ServiceInterface.category values. See also the *TPS_ManifestSpecification* [6].

> 模型通信组由三个标准ServiceInterface.category值之一标记。另请参阅*TPS_ManifestSpecification* [6]。


**[SWS_CM_99017]**{DRAFT} **category value COMMUNICATION_GROUP** *[*The ServiceInterface.category value COMMUNICATION_GROUP shall be used to define a Communication Group template.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99017]**{草案} **类别值 COMMUNICATION_GROUP** *[*ServiceInterface.category值 COMMUNICATION_GROUP 应用于定义通信组模板。*♩(RS_CM_00600, RS_CM_00601)*

### [SWS_CM_99018] {DRAFT} category value COMMUNICATION_GROUP_SERVER


*[*The ServiceInterface.category value COMMUNICATION_GROUP_SERVER shall be used to define CommunicationGroupServer service.*♩(RS_CM_00600, RS_CM_00601)*

> *服务接口的category值COMMUNICATION_GROUP_SERVER应该用来定义CommunicationGroupServer服务（RS_CM_00600，RS_CM_00601）。*

### [SWS_CM_99019] {DRAFT} category value COMMUNICATION_GROUP_CLIENT


*[*The ServiceInterface.category value COMMUNICATION_GROUP_CLIENT shall be used to define CommunicationGroupClient service.*♩(RS_CM_00600, RS_CM_00601)*

> *服务接口的category值COMMUNICATION_GROUP_CLIENT应该用于定义CommunicationGroupClient服务（RS_CM_00600，RS_CM_00601）。*

The figure below presents the relations between these category values.

\<\<derive\>\>

**Figure 7.9: Communication Group service interface categories**

### Communication Group Creation


A Communication Group is created by defining a Communication Group template

> 一个通信组通过定义通信组模板而创建

only.


**[SWS_CM_99020]**{DRAFT} **Communcation Group template** *[*The Communication Group template is a ServiceInterface of type CommunicationGroupClient with the category value COMMUNICATION_GROUP. It shall be used to define a Communication Group, where:

> **[SWS_CM_99020]**{草案} **通信组模板** *[*通信组模板是一种类型为CommunicationGroupClient的ServiceInterface，其分类值为COMMUNICATION_GROUP。它应用于定义通信组，其中：

- The SHORT-NAME of this template shall define of the name of the Communication Group.

- The event definition according to [[SWS_CM_99009](#_bookmark24)] shall define the data type of the message responses of the Communication Group.

> 根据[[SWS_CM_99009](#_bookmark24)]的事件定义，应定义通信组消息响应的数据类型。

- The method definition according to [[SWS_CM_99008](#_bookmark23)] shall define the data type of the messages of the Communication Group.

> 根据[[SWS_CM_99008](#_bookmark23)]的方法定义应定义通信组的消息的数据类型。

*♩(RS_CM_00600, RS_CM_00601)*


Based on the Communication Group template [[SWS_CM_99020](#_bookmark32)] the ServiceInterfaces for the CommunicationGroupServer [[SWS_CM_99000](#_bookmark20)] and the CommunicationGroupClient [[SWS_CM_99007](#_bookmark22)] can be generated/derived.

> 基于通信组模板[[SWS_CM_99020](#_bookmark32)]，可以生成/派生出通信组服务器[[SWS_CM_99000](#_bookmark20)]和通信组客户端[[SWS_CM_99007](#_bookmark22)]的服务接口。


**[SWS_CM_99021]**{DRAFT} **SHORT-NAME value of generated CommunicationGroupServer service** *[*The SHORT-NAME value of generated Communication-

> **[SWS_CM_99021]**{草案} **生成的CommunicationGroupServer服务的SHORT-NAME值** *[*生成的CommunicationGroupServer服务的SHORT-NAME值


GroupServer service shall be the SHORT-NAME of the according Communication Group template concatenated by the name Server.*♩(RS_CM_00600, RS_CM_00601)*

> 群服务器服务将是相应通信组模板的简称，由服务器名称连接而成（RS_CM_00600、RS_CM_00601）。


**[SWS_CM_99022]**{DRAFT} **SHORT-NAME value of generated CommunicationGroupClient service** *[*The SHORT-NAME value of generated CommunicationGroupClient service shall be the SHORT-NAME of the according Communication Group template concatenated by the name Client.*♩(RS_CM_00600, RS_CM_00601)*

> **[SWS_CM_99022]**{草稿} **生成的CommunicationGroupClient服务的SHORT-NAME值** *[*生成的CommunicationGroupClient服务的SHORT-NAME值应为相应的Communication Group模板的SHORT-NAME，加上“Client”的名称。*♩(RS_CM_00600, RS_CM_00601)*

The figures below outline the Communication Group creation flow.


The Communication Group Template defines the name of the Communication Group and defines the message and message response datatypes.

> 模板通信组定义了通信组的名称，并定义了消息和消息响应的数据类型。

![](./media/image27.jpeg)

response message definition

**Figure 7.10: Communication Group Template**


The CommunicationGroupServer and the CommunicationGroupClient Service descriptions are derived from the Communication Group Template.

> 通信组服务器和通信组客户端服务描述源自通信组模板。

![](./media/image29.png){width="6.2456933508311465in" height="2.410311679790026in"}

**Figure 7.11: Communication Group Flow**

![](./media/image30.jpeg)

**Figure 7.12: Communication Group Server Service Description**

Note:

- The PowerModeResponse datatype is a structure of clientID and PowerModeRespMsg datatype.
- The Clients datatype is a vector of uint32 datatype.

![](./media/image31.jpeg)

**Figure 7.13: Communication Group Client Service Description**

## Optional Execution Context


Some ara::com API's with an asynchronous callback allow the use of an optional execution context parameter (see [[SWS_CM_11352](#_bookmark553)], [[SWS_CM_11352](#_bookmark553)], [[SWS_CM_11354](#_bookmark564)], [[SWS_CM_11356](#_bookmark574)], [[SWS_CM_11358](#_bookmark571)], [[SWS_CM_11360](#_bookmark544)],

> 一些ara::com API可以使用异步回调，允许使用可选的执行上下文参数（参见[[SWS_CM_11352](#_bookmark553)], [[SWS_CM_11354](#_bookmark564)], [[SWS_CM_11356](#_bookmark574)], [[SWS_CM_11358](#_bookmark571)], [[SWS_CM_11360](#_bookmark544)]）。


[[SWS_CM_11362](#_bookmark547)]). The execution context parameter gives the user more control over the execution environment of a method call.

> 参数执行上下文可以让用户更好地控制方法调用的执行环境。


**[SWS_CM_11364]**{DRAFT} **Minimal behaviour of provided Execution Context** *[*An optionally provided execution context executor shall:

> **[SWS_CM_11364]**{草案} **提供的执行上下文的最低行为** *[*可选提供的执行上下文执行程序应：

- execute every function that it was passed to.
- execute each function it was passed to only once.

*♩(RS_CM_00204)*

## Network binding


The following chapters describe the requirements according to specific network protocol bindings.

> 以下章节描述了根据特定网络协议绑定的要求。


Since the selection of a particular network protocol binding is an integrator driven deployment decision, any change in the selection of a particular network protocol binding or changes in the various attributes and parameters of a particular network protocol

> 由于选择特定网络协议绑定是集成器驱动的部署决定，因此在选择特定网络协议绑定或改变特定网络协议的各种属性和参数时，都会发生变化。


binding shall be possible without requiring a re-compilation of the involved adaptive applications. The required changes to the involved adaptive application shall be limited to a re-linking (either static or dynamic) of the involved adaptive application.

> 绑定不需要重新编译涉及的自适应应用程序即可实现。对涉及的自适应应用程序所需的更改仅限于对涉及的自适应应用程序的静态或动态重新链接。


**[SWS_CM_10384]**{DRAFT} **Change of Service Interface Deployment** *[*A change of the service interface deployment shall be possible without re-compiling the involved adaptive applications. -This means that the following changes in the service interface deployment shall be possible without the need for a re-compilation of the adaptive applications:

> **[SWS_CM_10384]**{草案}**服务接口部署的变更** *[*改变服务接口部署应当可以在不重新编译涉及的自适应应用程序的情况下完成。 -这意味着以下服务接口部署的变更可以在不需要重新编译自适应应用程序的情况下完成：


- changes to the concrete type of ServiceInterfaceDeployment and the composed ServiceMethodDeployment, ServiceFieldDeployment, and ServiceEventDeployment (e.g., changing a SomeipServiceInterfaceDeployment to a UserDefinedServiceInterfaceDeployment)

> 更改具体类型的ServiceInterfaceDeployment以及组合的ServiceMethodDeployment、ServiceFieldDeployment和ServiceEventDeployment（例如，将SomeipServiceInterfaceDeployment更改为UserDefinedServiceInterfaceDeployment）

- changes to one or more attributes of meta-classes derived from ServiceInterfaceDeployment, ServiceMethodDeployment, ServiceFieldDeployment, and ServiceEventDeployment (e.g., changing the value of SomeipEventDeployment.separationTime)

> 对来自ServiceInterfaceDeployment、ServiceMethodDeployment、ServiceFieldDeployment和ServiceEventDeployment的元类的一个或多个属性进行更改（例如，更改SomeipEventDeployment.separationTime的值）

- backwards-compatible changes to the technology specific service version number of the ServiceInterfaceDeployment.

> 对技术特定服务版本号的ServiceInterfaceDeployment进行向后兼容的更改

*♩(RS_CM_00315)*


Note that changes to SomeipServiceVersion.majorVersion are an exception here, since any change to SomeipServiceVersion.majorVersion indicates an incompatible change of the ServiceInterface and thus affects the involved adaptive applications mandating a re-compilation of the involved adaptive applications.

> 注意，对SomeipServiceVersion.majorVersion的更改是一个例外，因为对SomeipServiceVersion.majorVersion的任何更改都表明服务接口的不兼容变化，从而影响涉及的自适应应用程序，这就要求重新编译涉及的自适应应用程序。


**[SWS_CM_10385]**{DRAFT} **Change of Service Instance Deployment** *[*A change of the service instance deployment shall be possible without re-compiling the involved adaptive applications. -This means that the following changes in the service instance deployment shall be possible without the need for a re-compilation of the adaptive applications:

> **[SWS_CM_10385]**{草案} **服务实例部署的变更** *[*服务实例部署的变更应该可以在不重新编译涉及的自适应应用程序的情况下进行。 -这意味着下列服务实例部署的变更可以在不需要重新编译自适应应用程序的情况下进行：


- changes to the concrete type of ProvidedApServiceInstance and/or RequiredApServiceInstance (e.g., changing a ProvidedSomeipServiceInstance to a ProvidedUserDefinedServiceInstance and a RequiredSomeipServiceInstance to a RequiredUserDefinedServiceInstance)

> 对ProvidedApServiceInstance和/或RequiredApServiceInstance的具体类型进行更改（例如，将ProvidedSomeipServiceInstance更改为ProvidedUserDefinedServiceInstance，将RequiredSomeipServiceInstance更改为RequiredUserDefinedServiceInstance）

- changes to one or more attributes of meta-class derived from ProvidedApServiceInstance and/or RequiredApServiceInstance (e.g., changing the value of the SomeipProvidedEventGroup.multicastThreshold or the SomeipSdServerServiceInstanceConfig.serviceOfferTimeToLive).

> 对来自ProvidedApServiceInstance和/或RequiredApServiceInstance的元类的一个或多个属性进行更改（例如，更改SomeipProvidedEventGroup.multicastThreshold或SomeipSdServerServiceInstanceConfig.serviceOfferTimeToLive的值）。

- backwards-compatible changes to the technology specific service version number of the ServiceInterfaceDeployment.

> 对ServiceInterfaceDeployment的技术特定服务版本号进行向下兼容的更改


*♩(RS_CM_00315)* Note that changes to SomeipServiceVersion.majorVersion are an exception here, since any change to SomeipServiceVersion.majorVersion indicates an incompatible change of the ServiceInterface and thus affects

> *♩(RS_CM_00315)* 但是，对SomeipServiceVersion.majorVersion的更改是一个例外，因为对SomeipServiceVersion.majorVersion的任何更改都表示服务接口的不兼容变化，因此会产生影响。


the involved adaptive applications mandating a re-compilation of the involved adaptive applications.

> 参与的自适应应用程序需要重新编译参与的自适应应用程序。


**[SWS_CM_10386]**{DRAFT} **Change of Network Configuration** *[*A change of the network configuration shall be possible without re-compiling the involved adaptive applications. -This means that the following changes in the network configuration shall be possible without the need for a re-compilation of the adaptive applications:

> **[SWS_CM_10386]**{草案} **网络配置的变更** *[*更改网络配置时，不需要重新编译相关的自适应应用程序。-这意味着，在不需要重新编译自适应应用程序的情况下，可以对网络配置进行以下变更：


- changes to one or more attributes of a concrete ServiceInstanceToMachineMapping (e.g., changing the value of the SomeipServiceInstanceToMachineMapping.udpPort or the SomeipServiceInstanceToMachineMapping.tcpPort.

> 更改具体ServiceInstanceToMachineMapping的一个或多个属性（例如，更改SomeipServiceInstanceToMachineMapping.udpPort或SomeipServiceInstanceToMachineMapping.tcpPort的值）。

*♩(RS_CM_00315)*


Abstract network protocol bindings for service ports shall be specified inside the service instance manifest to deploy network bindings of service instances.

> 抽象网络协议绑定服务端口应该在服务实例清单中指定以部署服务实例的网络绑定。


**[SWS_CM_10590]**{DRAFT} **Abstract Network Protocol Binding** *[*The usage of abstract network protocol binding for ProvidedApServiceInstance and RequiredApServiceInstance shall be supported to deploy network bindings of ServiceInterfaces. An abstract network protocol binding shall cover SOME/IP, DDS and UserDefined protocols and is specified inside the service instance manifest. It is used with an InstanceSpecifier and shall be specified as followed:

> **[SWS_CM_10590]**{草稿} **抽象网络协议绑定** *[*应支持使用抽象网络协议绑定来部署ProvidedApServiceInstance和RequiredApServiceInstance的网络绑定。抽象网络协议绑定应涵盖SOME/IP、DDS和UserDefined协议，并在服务实例清单中指定。它使用InstanceSpecifier，并应按照以下方式指定：

\<port context\>::\<port name\>, where:


- \<port context\> specifies the instantiation context of the port which might be an instantiation path or any other unique identifiable information.

> - \<端口上下文\> 指定端口的实例化上下文，可能是实例化路径或其他唯一可识别的信息。
- \<port name\> specifies the port name.


Note: it is possible to specify multiple technology bindings for a port (Multi-Binding).*♩*

> 注意：可以为端口指定多种技术绑定（多绑定）。

*(RS_CM_00200, RS_AP_00137)*


**[SWS_CM_10416]**{DRAFT} **Reception of a malformed message** *[*In case any network binding does receive a message, which it identifies as malformed, the message shall be discarded and the error shall not be propagated to the application.*♩(RS_CM_00005)*

> 如果任何网络绑定接收到一条消息，识别为格式不正确，则该消息将被丢弃，错误不会传播到应用程序。♩（RS_CM_00005）


Note: The incident should also be logged if logging is configured and the corresponding network binding supports it.

> 注意：如果配置了日志记录，并且相应的网络绑定支持，也应记录此事件。

### SOME/IP Network binding

SOME/IP supports different kind of bindings:

### SOME/IP Events:

- uni-cast is one-to-one communication
- multi-cast is one-to-many communication


In case the active subscriptions will reach the multi-cast-threshold the communication paradigm will be switched from uni-cast to multi-cast to gain a better network utilization. Below the multi-cast-threshold SOME/IP is maintaining for a subscription a single unicast communication.

> 如果活动订阅达到多播阈值，通信范式将从单播转换为多播，以获得更好的网络利用率。在多播阈值以下，SOME/IP 为订阅保持单一的单播通信。

### SOME/IP Events:

- many-to-one communication using multiple uni-cast communications


**[SWS_CM_10000] SOME/IP Compliance** *[*The SOME/IP network binding shall implement the SOME/IP Protocol and the SOME/IP Service Discovery Protocol defined in

> **[SWS_CM_10000] SOME/IP 符合性** *[*SOME/IP 网络绑定应实施在中定义的SOME/IP协议和SOME/IP服务发现协议。

[5] and [12].*♩(RS_CM_00204, RS_CM_00205)*


**[SWS_CM_10013] Header Byte order** *[*All headers shall be encoded in network byte order Big Endian (MostSignificantByteFirst) [RFC 791].*♩(RS_CM_00204, RS_SOMEIP_00026)*

> **[SWS_CM_10013] 首部字节顺序** *[*所有首部都应以网络字节顺序大端（最高有效字节优先）[RFC 791]编码。*♩(RS_CM_00204, RS_SOMEIP_00026)*


**[SWS_CM_10172] Payload Byte order definition** *[*The byte order of the parameters inside the payload shall be defined by byteOrder of ApSomeipTransformationProps.*♩(RS_CM_00204, RS_SOMEIP_00026)*

> **[SWS_CM_10172] 协议负载字节顺序定义** *[*协议负载中参数的字节顺序由ApSomeipTransformationProps的byteOrder定义。♩(RS_CM_00204, RS_SOMEIP_00026)*


**[SWS_CM_10240]**{DRAFT} **Session handling state** *[*If ApSomeipTransformationProps.sessionHandling is present and set to value SOMEIPTransformerSessionHandlingEnum.sessionHandlingActive, the Session handling shall be Active. If ApSomeipTransformationProps.sessionHandling is present and set to value SOMEIPTransformerSessionHandlingEnum.sessionHandlingInactive, the Session handling shall be Inactive.*♩(RS_CM_00204, RS_SOMEIP_00012)*

> 如果ApSomeipTransformationProps.sessionHandling存在并设置为SOMEIPTransformerSessionHandlingEnum.sessionHandlingActive，则会话处理应为Active。如果ApSomeipTransformationProps.sessionHandling存在并设置为SOMEIPTransformerSessionHandlingEnum.sessionHandlingInactive，则会话处理应为Inactive（RS_CM_00204，RS_SOMEIP_00012）。

### Static Service Connection


**[SWS_CM_02201] Static service connection** *[*The static connection of services which are bound to SOME/IP protocols shall be preformed by statically pre-configured application end-points as described in the TPS_ManifestSpecification for a ProvidedSomeipServiceInstance by [TPS_MANI_03312], [TPS_MANI_03313] and for a RequiredSomeipServiceInstance by [TPS_MANI_03314], [TPS_MANI_03315], [TPS_MANI_03316].*♩(RS_CM_00710)*

> **[SWS_CM_02201] 静态服务连接** *[*根据[TPS_MANI_03312]、[TPS_MANI_03313]为提供的SOME/IP协议服务实例，以及根据[TPS_MANI_03314]、[TPS_MANI_03315]和[TPS_MANI_03316]为所需的SOME/IP协议服务实例，按照TPS_ManifestSpecification中所述的静态预配置应用终端，进行静态连接。♩(RS_CM_00710)*


**[SWS_CM_02202] Service Discovery is bypassed by static service connection** *[*The service discovery protocols are bypassed in case of a static service connection.*♩ (SWS_CM_02201)*

> **[SWS_CM_02202] 静态服务连接绕过了服务发现协议** *[*在静态服务连接的情况下，服务发现协议被绕过了。♩ (SWS_CM_02201)*


**[SWS_CM_02203] Service versioning is not checked at runtime in case of a static service connection** *[*Service versions are not checked at run-time in case of a static service connection since the Service Discovery has been bypassed.*♩(SWS_CM_02201)*

> **[SWS_CM_02203] 在静态服务连接的情况下，运行时不检查服务版本** *[*由于已经绕过了服务发现，因此在静态服务连接的情况下不检查服务版本。*♩(SWS_CM_02201)*

Note: ara::com language APIs are agnostic to static service connection.

### Service Discovery


**[SWS_CM_11374] Periodic link state monitoring** *[*The SOME/IP network binding shall periodically monitor and obtain the current link state of the underlying network interfaces.

> [SWS_CM_11374] 定期链路状态监测
SOME/IP 网络绑定应定期监测并获取底层网络接口的当前链路状态。


Note: This information is required since the behavior of SOME/IP service discovery is influenced by the current link state as well as by changes in the link state*♩()*

> 注意：由于SOME/IP服务发现的行为受当前链路状态以及链路状态变化的影响，因此需要此信息。


**[SWS_CM_00201] Start of service discovery protocol on Server side** *[*The registration of a new offered service which is bound to SOME/IP by invoking the OfferService method (see [[SWS_CM_00101](#_bookmark522)]) of the ServiceSkeleton class shall trigger the start of the initial wait phase of the SOME/IP service discovery protocol after link up according to [PRS_SOMEIPSD_00133].*♩(RS_CM_00204, RS_CM_00101, RS_SOMEIPSD_00024, RS_SOMEIPSD_00013)*

> **[SWS_CM_00201] 服务器端服务发现协议的开始** *[*通过调用ServiceSkeleton类的OfferService方法（参见[[SWS_CM_00101](#_bookmark522)])注册一个新提供的SOME/IP服务时，应根据[PRS_SOMEIPSD_00133]触发SOME/IP服务发现协议的初始等待阶段的开始。*♩（RS_CM_00204，RS_CM_00101，RS_SOMEIPSD_00024，RS_SOMEIPSD_00013）*


The different phases of SOME/IP Service Discovery on the Server side are configured in the Manifest in the SomeipSdServerServiceInstanceConfig referenced in ProvidedSomeipServiceInstance element in the role sdServerConfig. The configuration is described in more detail in TPS_ManifestSpecification by

> 服务器端的SOME/IP服务发现的不同阶段在清单中配置，该清单中的SomeipSdServerServiceInstanceConfig引用了角色sdServerConfig中的ProvidedSomeipServiceInstance元素。详细的配置信息可以在TPS_ManifestSpecification中找到。

- [TPS_MANI_03012] (Initial Wait Phase),
- [TPS_MANI_03013] (Repetition Phase),
- [TPS_MANI_03014] (Main Phase).


The corresponding timing parameters for these phases are configured via InitialSdDelayConfig in the role initialOfferBehavior, RequestResponseDelay in the role requestResponseDelay, and TimeValue in attribute offerCyclicDelay. The sharing of timers is described in [TPS_MANI_03230].

> 这些阶段的相应时序参数可通过角色initialOfferBehavior中的InitialSdDelayConfig、角色requestResponseDelay中的RequestResponseDelay以及属性offerCyclicDelay中的TimeValue来配置。定时器的共享方式可参见[TPS_MANI_03230]。


**[SWS_CM_00209] Start of service discovery protocol on Client side** *[*The search for a new service which is bound to SOME/IP by invoking the FindService methods (see [[SWS_CM_00122](#_bookmark550)] and [[SWS_CM_00622](#_bookmark551)]) or the StartFindService methods (see [[SWS_CM_00123](#_bookmark552)] and [[SWS_CM_00623](#_bookmark554)]) of the ServiceProxy class shall trigger the start of the initial wait phase of the SOME/IP service discovery protocol after link up according to [PRS_SOMEIPSD_00397].*♩(RS_CM_00204, RS_CM_00102, RS_SOMEIPSD_00024, RS_SOMEIPSD_00008)*

> 开始客户端服务发现协议

通过调用FindService方法（参见[[SWS_CM_00122](#_bookmark550)]和[[SWS_CM_00622](#_bookmark551)])或StartFindService方法（参见[[SWS_CM_00123](#_bookmark552)]和[[SWS_CM_00623](#_bookmark554)])的ServiceProxy类，搜索绑定到SOME/IP的新服务，在链接建立后，应根据[PRS_SOMEIPSD_00397]触发SOME/IP服务发现协议的初始等待阶段的开始。♩（RS_CM_00204，RS_CM_00102，RS_SOMEIPSD_00024，RS_SOMEIPSD_00008）


Note for [[SWS_CM_00201](#_bookmark43)] and [[SWS_CM_00209](#_bookmark44)]: See also [PRS_SOMEIPSD_00395], [PRS_SOMEIPSD_00397], [PRS_SOMEIPSD_00399], [PRS_SOMEIPSD_-

> 注意[[SWS_CM_00201](#_bookmark43)]和[[SWS_CM_00209](#_bookmark44)]：另请参阅[PRS_SOMEIPSD_00395]，[PRS_SOMEIPSD_00397]，[PRS_SOMEIPSD_00399]，[PRS_SOMEIPSD_-

00416], [PRS_SOMEIPSD_00435], [PRS_SOMEIPSD_00752], [PRS_SOMEIPSD_-

00133], [PRS_SOMEIPSD_00805] and [PRS_SOMEIPSD_00751].


The different phases of SOME/IP Service Discovery on the Client side are configured in the Manifest in the SomeipSdClientServiceInstanceConfig referenced in RequiredSomeipServiceInstance element in the role sdClientConfig. The configuration is described in more detail in TPS_ManifestSpecification by

> 在客户端上，SOME/IP服务发现的不同阶段在Manifest中配置，在sdClientConfig角色的RequiredSomeipServiceInstance元素中引用SomeipSdClientServiceInstanceConfig。详细配置信息可以在TPS_ManifestSpecification中找到。

- [TPS_MANI_03026] (Initial Wait Phase),
- [TPS_MANI_03027] (Repetition Phase).


The corresponding timing parameters for these phases are configured via InitialSdDelayConfig in the role initialFindBehavior, and RequestResponseDelay in the role requestResponseDelay. The sharing of timers is described in [TPS_MANI_03231].

> 这些阶段的相应时序参数可通过角色initialFindBehavior中的InitialSdDelayConfig配置，以及角色requestResponseDelay中的RequestResponseDelay配置。定时器共享的描述可参见[TPS_MANI_03231]。


**[SWS_CM_00202] SOME/IP FindService message** *[*The fields in the SOME/IP FindService message shall be as follows:

> **[SWS_CM_00202] SOME/IP 查找服务消息** *[*SOME/IP 查找服务消息中的字段如下：


- The Type field and the TTL field shall be set to values suitable for a FindService entry, which means that

> 类型字段和TTL字段应设置为适合FindService条目的值，这意味着


  The Type field shall be set to FindService (see [PRS_SOMEIPSD_00351] for numerical value)

> 字段类型应设置为FindService（请参阅[PRS_SOMEIPSD_00351]以获取数值）

  TTL for FindService messages shall not be used, and the value may be set to an arbitrary value. The field is only defined in the protocol for backward compatibility.

> 找服务消息的TTL不应使用，值可以设置为任意值。该字段仅在协议中定义，以便向后兼容。

- The Service ID field shall be set to a value derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID字段应设置为从Manifest中定义serviceInterfaceId的SomeipServiceInterfaceDeployment元素派生的值。

- The Instance ID shall be set to a value derived from the Manifest where the RequiredSomeipServiceInstance element defines the requiredServiceInstanceId for the SomeipServiceInterfaceDeployment that is referenced by the RequiredSomeipServiceInstance in the role serviceInterfaceDeployment. If the requiredServiceInstanceId is set to \"ALL\" then 0xFFFF shall be used.

> 实例ID应设置为从Manifest派生的值，其中RequiredSomeipServiceInstance元素为SomeipServiceInterfaceDeployment定义所需的requiredServiceInstanceId，该SomeipServiceInterfaceDeployment由角色serviceInterfaceDeployment引用的RequiredSomeipServiceInstance引用。如果requiredServiceInstanceId设置为“ALL”，则应使用0xFFFF。

- The Major Version field of the RequiredSomeipServiceInstance that is searched shall be set to a value derived from the Manifest where the SomeipServiceVersion element that is aggregated by the SomeipServiceInterfaceDeployment in the role serviceInterfaceVersion defines the majorVersion.

> 要搜索的RequiredSomeipServiceInstance的主版本字段应设置为从清单中派生的值，其中由SomeipServiceInterfaceDeployment以serviceInterfaceVersion角色聚合的SomeipServiceVersion元素定义了majorVersion。

- The Minor Version field of the RequiredSomeipServiceInstance that is searched shall be set to a value derived from the Manifest from the requiredMinorVersion attribute in the RequiredSomeipServiceInstance.

> 要搜索的RequiredSomeipServiceInstance的Minor Version字段应设置为从RequiredSomeipServiceInstance的Manifest中的requiredMinorVersion属性中获得的值。


  If versionDrivenFindBehavior is set to minimumMinorVersion then the Minor Version Field shall be set to 0xFFFF FFFF and all found services with a minor version smaller than the requiredMinorVersion shall not be considered for service discovery.

> 如果versionDrivenFindBehavior设置为minimumMinorVersion，那么Minor Version字段将被设置为0xFFFF FFFF，并且所有比所需的Minor Version小的已发现的服务将不被用于服务发现。

  If versionDrivenFindBehavior is set to exactOrAnyMinorVersion then the Minor Version Field shall be set with the requiredMinorVersion.

> 如果versionDrivenFindBehavior设置为exactOrAnyMinorVersion，则Minor Version字段应设置为requiredMinorVersion。

  If the minorVersion is set to \"ALL\", then the Minor Version Field shall be set to 0xFFFF FFFF.

> 如果minorVersion被设置为“ALL”，那么Minor Version字段应被设置为0xFFFF FFFF。

- Configuration Option shall be used in the find message if at least one capabilityRecord is defined in the RequiredSomeipServiceInstance element. The content of the Configuration Option shall be derived from the key/value pairs defined in each capabilityRecord.

> 如果RequiredSomeipServiceInstance元素中定义了至少一个capabilityRecord，则应在查找消息中使用配置选项。配置选项的内容应源自每个capabilityRecord中定义的键/值对。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00102, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005, RS_SOMEIPSD_00008, RS_SOMEIPSD_00010)*

> *♩(RS_CM_00204、RS_CM_00200、RS_CM_00102、RS_SOMEIPSD_00006、RS_SOMEIPSD_00005、RS_SOMEIPSD_00008、RS_SOMEIPSD_00010)*


**[SWS_CM_10202] Version blocklist** *[*The service connection of a RequiredSomeipServiceInstance with a certain SomeipServiceVersion shall not be considered for service discovery for this instance if this SomeipServiceVersion is listed inside a RequiredSomeipServiceInstance.blocklistedVersion.*♩ (RS_CM_00701)*

> **[SWS_CM_10202] 版本黑名单** *[*如果某个SomeipServiceVersion被列入RequiredSomeipServiceInstance.blocklistedVersion，则不会考虑该实例的服务发现的服务连接。*♩ (RS_CM_00701)*


**[SWS_CM_00203] SOME/IP OfferService message** *[*The fields in the SOME/IP OfferService message shall be as follows:

> **[SWS_CM_00203] SOME/IP 提供服务消息** *[*SOME/IP提供服务消息中的字段应如下：


- The Type field and the TTL field shall be set to values suitable for a OfferService entry, which means that

> 类型字段和TTL字段应设置为适合OfferService条目的值，这意味着


  The Type field shall be set to OfferService (see [PRS_SOMEIPSD_00356] for numerical value).

> 字段类型应设置为OfferService（参见[PRS_SOMEIPSD_00356]查看数值）。

  The TTL field shall be set to a value derived from the Manifest where the SomeipSdServerServiceInstanceConfig element that is referenced by the ProvidedSomeipServiceInstance in the role sdServerConfig defines the serviceOfferTimeToLive.

> TTL字段的值应该从Manifest中派生，其中SomeipSdServerServiceInstanceConfig元素由ProvidedSomeipServiceInstance在sdServerConfig角色中引用，定义了serviceOfferTimeToLive。

- The Service ID field shall be set to a value derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID字段应设置为从清单中定义服务接口ID的SomeipServiceInterfaceDeployment元素派生的值。

- The Instance ID shall be set to a value derived from the Manifest where the ProvidedSomeipServiceInstance element defines the serviceInstanceId for the SomeipServiceInterfaceDeployment that is referenced by the ProvidedSomeipServiceInstance in the role serviceInterfaceDeployment.

> 实例ID应设置为从清单中派生的值，其中ProvidedSomeipServiceInstance元素为由ProvidedSomeipServiceInstance在服务接口部署中引用的SomeipServiceInterfaceDeployment定义的serviceInstanceId。

- Major Version field of the SomeipServiceInterfaceDeployment that is offered shall be set to a value derived from the Manifest where the SomeipServiceVersion element that is aggregated by the SomeipServiceInterfaceDeployment in the role serviceInterfaceVersion defines the majorVersion.

> 在提供的SomeipServiceInterfaceDeployment的主版本字段中，应将其设置为从Manifest派生的值，其中由SomeipServiceInterfaceDeployment在角色serviceInterfaceVersion中聚合的SomeipServiceVersion元素定义主版本号。

- Minor Version field of the SomeipServiceInterfaceDeployment that is offered shall be set to a value derived from the Manifest where the SomeipServiceVersion element that is aggregated by the SomeipServiceInterfaceDeployment in the role serviceInterfaceVersion defines the minorVersion.

> 在提供的SomeipServiceInterfaceDeployment中，次版本字段应设置为从清单中派生的值，其中由SomeipServiceInterfaceDeployment在serviceInterfaceVersion角色中聚合的SomeipServiceVersion元素定义了minorVersion。
- The Endpoint Option(s) shall be set in the following way:


  An IPv4 Endpoint Option shall be used if the Machine to which the ProvidedSomeipServiceInstance is mapped with the ServiceInstanceToMachineMapping provides an EthernetCommunicationConnector that refers to a NetworkEndpoint in the role unicastNetworkEndpoint where an IPv4 Address is configured in the Ipv4Configuration element.

> 如果提供的SomeipServiceInstance映射到的机器提供指向角色unicastNetworkEndpoint的网络端点的以太网通信连接器，其中Ipv4Configuration元素配置了IPv4地址，则应使用IPv4端点选项。

  An IPv6 Endpoint Option shall be used if the Machine to which the ProvidedSomeipServiceInstance is mapped with the ServiceInstanceToMachineMapping provides an EthernetCommunicationConnector that refers to a NetworkEndpoint in the role unicastNetworkEndpoint where an IPv6 Address is configured in the Ipv6Configuration element.

> 如果提供的SomeipServiceInstance映射到的机器提供的以太网通信连接器指向一个在unicastNetworkEndpoint角色中具有IPv6地址配置的网络端点，则应使用IPv6端点选项。

  The Transport Layer Protocol used in the IPv4 Endpoint option and/or IPv6 Endpoint option shall be derived from the Manifest where the SomeipServiceInstanceToMachineMapping element that maps the ProvidedSomeipServiceInstance to an EthernetCommunicationConnector of a Machine defines the transport protocol and the port number.

> 传输层协议在IPv4端点选项和/或IPv6端点选项中使用的，将由清单定义，其中将ProvidedSomeipServiceInstance映射到机器的EthernetCommunicationConnector定义了传输协议和端口号。

*∗* UDP shall be used if SomeipServiceInstanceToMachineMapping.

udpPort is configured.


*∗* TCP shall be used ifSomeipServiceInstanceToMachineMapping. tcpPort is configured. In case the port number (SomeipServiceInstanceToMachineMapping.udpPort or SomeipServiceInstanceToMachineMapping.tcpPort) is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that value shall be used.

> 如果配置了SomeipServiceInstanceToMachineMapping.tcpPort，则应使用TCP。如果端口号（SomeipServiceInstanceToMachineMapping.udpPort或SomeipServiceInstanceToMachineMapping.tcpPort）被配置为0，则应使用*临时*端口。如果端口号被配置为一个不为0的值，则应使用此值。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00101, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005, RS_SOMEIPSD_00010, RS_SOMEIPSD_00013, RS_SOMEIPSD_00025)*

> *(RS_CM_00204，RS_CM_00200，RS_CM_00101，RS_SOMEIPSD_00006，RS_SOMEIPSD_00005，RS_SOMEIPSD_00010，RS_SOMEIPSD_00013，RS_SOMEIPSD_00025)*


**[SWS_CM_11373] Cyclic interval of OfferService messages** *[*If attribute SomeipSdServerServiceInstanceConfig.offerCyclicDelay is configured in SomeipSdServerServiceInstanceConfig and is greater than 0, in the Main Phase an OfferService entry shall be sent cyclically with an interval defined by configuration item SomeipSdServerServiceInstanceConfig.offerCyclicDelay.

> 如果SomeipSdServerServiceInstanceConfig中配置了SomeipSdServerServiceInstanceConfig.offerCyclicDelay属性并且大于0，在主阶段，将按照SomeipSdServerServiceInstanceConfig.offerCyclicDelay中定义的间隔循环发送OfferService条目。


If SomeipSdServerServiceInstanceConfig.offerCyclicDelay is 0, no OfferService entries shall be sent in Main Phase for this Server Service Instance.*♩()*

> 如果SomeipSdServerServiceInstanceConfig.offerCyclicDelay为0，则不会在主阶段为此服务器服务实例发送OfferService条目。


**[SWS_CM_00204] SOME/IP StopOffer message** *[*The fields in the SOME/IP StopOffer message shall be as follows:

> **[SWS_CM_00204] SOME/IP 停止提供消息** *[*SOME/IP停止提供消息中的字段应如下：


- The Type field and the TTL field shall be set to values suitable for a StopOffer entry, which means that

> 类型字段和TTL字段应设置为适合StopOffer条目的值，这意味着


  The Type field shall be set to OfferService (see [PRS_SOMEIPSD_00356] for numerical value)

> 字段类型应设置为OfferService（参见[PRS_SOMEIPSD_00356]查看数值）
  The TTL fields shall be set to 0x000000 (see [PRS_SOMEIPSD_00364])
- The Service ID field shall be set to the same value as in the OfferService message.
- The Instance ID field shall be set to the same value as in the OfferService message.
- The Major Version field shall be set to the same value as in the OfferService message.
- The Minor Version field shall be set to the same value as in the OfferService message.
- IPv4 Endpoint Option shall be set to the same value as in the OfferService message.
- IPv6 Endpoint Option shall be set to the same value as in the OfferService message.
- Configuration Option shall be set to the same value as in the OfferService message.


*♩(RS_CM_00204, RS_CM_00105, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005, RS_SOMEIPSD_00010, RS_SOMEIPSD_00014)*

> *♩（RS_CM_00204，RS_CM_00105，RS_SOMEIPSD_00006，RS_SOMEIPSD_00005，RS_SOMEIPSD_00010，RS_SOMEIPSD_00014）*


**[SWS_CM_10377] Sending SOME/IP SubscribeEventgroup messages initial** *[*The subscription to *at least one* Event (ServiceInterface.event) of an Eventgroup (SomeipEventGroup) by invoking the Subscribe method (see [[SWS_CM_00141](#_bookmark559)]) of the specific Event class of the ServiceProxy class shall cause the sending of a SOME/IP SubscribeEventgroup messages in case there is no active subscription for the particular Eventgroup (either because there was no previous subscription to this particular Eventgroup or the TTL of every received SubscribeGroupAck message (see [[SWS_CM_00206](#_bookmark48)]) for the particular Eventgroup has already expired).

> 发送SOME/IP订阅事件组消息初始化：通过调用服务代理类的特定事件类的订阅方法（参见SWS_CM_00141）订阅某一事件组（SomeipEventGroup）的至少一个事件（ServiceInterface.event），如果对特定事件组没有活动订阅（无论是因为之前对该特定事件组没有订阅，还是收到的每个SubscribeGroupAck消息（参见SWS_CM_00206）的TTL已经过期），则会发送SOME/IP订阅事件组消息。


The subscription to *at least one* Event of an Eventgroup by invoking the Subscribe method (see [[SWS_CM_00141](#_bookmark559)]) of the specific Event class of the ServiceProxy class shall *not* cause the sending of a SOME/IP SubscribeEventgroup messages in case there is an active subscription for the particular Eventgroup (because there was some previous subscription to this particular Eventgroup and the TTL of at least one received SubscribeGroupAck message (see [[SWS_CM_00206](#_bookmark48)]) for the particular Eventgroup has not yet expired).

> 调用特定事件类的ServiceProxy类的Subscribe方法（参见[[SWS_CM_00141](#_bookmark559)）订阅某个事件组中的至少一个事件，在当前有活动订阅的情况下（因为之前已经订阅了这个特定的事件组，且至少一个接收到的SubscribeGroupAck消息的TTL（参见[[SWS_CM_00206](#_bookmark48)）尚未过期），不会导致发送SOME/IP SubscribeEventgroup消息。


The client shall explicitly request Initial Events for Field notifier according to [PRS_SOMEIPSD_00703] and [PRS_SOMEIPSD_00811].*♩(RS_CM_00204, RS_CM_00200, RS_CM_00103, RS_SOMEIPSD_00006, RS_SOMEIPSD_00015)*

> 客户应根据[PRS_SOMEIPSD_00703]和[PRS_SOMEIPSD_00811]明确请求Field Notifier的初始事件，（RS_CM_00204，RS_CM_00200，RS_CM_00103，RS_SOMEIPSD_00006，RS_SOMEIPSD_00015）


**[SWS_CM_10381] Sending SOME/IP SubscribeEventgroup messages renewal** *[*If the TTL of an active subscription for a particular Eventgroup is about to expire and there is *at least one* active subscription for an Event of this Eventgroup, a SubscribeEventgroup message shall be sent to refresh the active subscription to

> **[SWS_CM_10381] 发送SOME/IP订阅事件组消息更新** *[*如果特定事件组的活动订阅的TTL即将到期，且该事件组至少有一个活动订阅，则应发送SubscribeEventgroup消息以刷新活动订阅。


the particular Eventgroup.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00103, RS_SOMEIPSD_00006, RS_SOMEIPSD_00015)*

> 特定的事件组。♩（RS_CM_00204，RS_CM_00200，RS_CM_00103，RS_SOMEIPSD_00006，RS_SOMEIPSD_00015）


**[SWS_CM_00205] Content of SOME/IP SubscribeEventgroup message** *[*The fields in the SOME/IP SubscribeEventgroup message shall be as follows:

> **[SWS_CM_00205] SOME/IP 订阅事件组消息的内容** *[*SOME/IP 订阅事件组消息中的字段应如下所示：


- The Type field and the TTL field shall be set to values suitable for a SubscribeEventgroup entry, which means that

> 类型字段和TTL字段应设置为适用于SubscribeEventgroup条目的值，这意味着


  The Type field shall be set to SubscribeEventgroup (see [PRS_SOMEIPSD_00386] for numerical value)

> 字段类型应设置为SubscribeEventgroup（参见[PRS_SOMEIPSD_00386]以获取数值）

  The TTL field shall be set to a value derived from Manifest, where the RequiredSomeipServiceInstance element aggregates the SomeipRequiredEventGroup in the role requiredEventGroup. The SomeipRequiredEventGroup aggregates the sdClientEventGroupTimingConfig where the timeToLive is defined.

> TTL字段应设置为从Manifest中派生的值，其中RequiredSomeipServiceInstance元素聚合了所需的EventGroup中的SomeipRequiredEventGroup。SomeipRequiredEventGroup聚合sdClientEventGroupTimingConfig，其中定义了时间生存期。
- The Service ID shall be taken from the offer message.
- The Instance ID shall be taken from the offer message.
- Major Version shall be derived from the offer message.

- The Eventgroup ID field shall be derived from Manifest where the RequiredSomeipServiceInstance element aggregates the SomeipRequiredEventGroup in the role requiredEventGroup. The SomeipRequiredEventGroup contains the eventGroup reference to the SomeipEventGroup where the eventGroupId is defined.

> 事件组ID字段应从Manifest派生，其中RequiredSomeipServiceInstance元素将SomeipRequiredEventGroup聚合在所需的requiredEventGroup角色中。SomeipRequiredEventGroup包含对SomeipEventGroup的事件组引用，其中定义了事件组ID。

- IPv4 Endpoint Option shall be sent if the offer message contains an IPv4 Endpoint Option. In this case the IPv4 Address sent in the IPv4 Endpoint Option of the SubscribeEventgroup message is configured in the Manifest where the RequiredSomeipServiceInstance element is mapped with the ServiceInstanceToMachineMapping to an EthernetCommunicationConnector of a Machine. The EthernetCommunicationConnector refers to a NetworkEndpoint in the role unicastNetworkEndpoint where an IPv4 Address is configured in theIpv4Configuration element.

> 如果报文包含IPv4端点选项，则应发送IPv4端点选项。在这种情况下，在SubscribeEventgroup报文中发送的IPv4地址在清单中配置，其中RequiredSomeipServiceInstance元素映射到Machine的EthernetCommunicationConnector。 EthernetCommunicationConnector引用角色unicastNetworkEndpoint中的NetworkEndpoint，其中Ipv4Configuration元素中配置了IPv4地址。

- IPv6 Endpoint Option shall be sent if the offer message contains an IPv6 Endpoint Option. In this case the IPv6 Address sent in the IPv6 Endpoint Option of the SubscribeEventgroup message is configured in the Manifest where the RequiredSomeipServiceInstance element is mapped with the ServiceInstanceToMachineMapping to an EthernetCommunicationConnector of a Machine. The EthernetCommunicationConnector refers to a NetworkEndpoint in the role unicastNetworkEndpoint where an IPv6 Address is configured in theIpv6Configuration element.

> 如果报文包含IPv6端点选项，则应发送IPv6端点选项。在这种情况下，在订阅事件组消息中发送的IPv6地址在清单中配置，其中RequiredSomeipServiceInstance元素映射到机器的ServiceInstanceToMachineMapping上，以EthernetCommunicationConnector参考。EthernetCommunicationConnector引用unicastNetworkEndpoint角色中的NetworkEndpoint，其中Ipv6Configuration元素中配置了IPv6地址。

- The Transport Layer Protocol used in the IPv4 Endpoint option and/or IPv6 Endpoint option shall be derived from the Manifest where the SomeipEventGroup points either to SomeipEventDeployments where the transportProtocol

> 在IPv4端点选项和/或IPv6端点选项中使用的传输层协议应从Manifest派生，其中SomeipEventGroup指向SomeipEventDeployments，其中transportProtocol。


is set to udp or to tcp. The SomeipServiceInstanceToMachineMapping element that maps the RequiredSomeipServiceInstance to an EthernetCommunicationConnector of a Machine the transport protocol and the port number.

> SomeipServiceInstanceToMachineMapping元素将RequiredSomeipServiceInstance映射到机器的EthernetCommunicationConnector，用于设置传输协议和端口号。


- The UDP port shall be derived from SomeipServiceInstanceToMachineMapping.udpPort. In case the port number (SomeipServiceInstanceToMachineMapping.udpPort) is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that value shall be used.

> UDP 端口应从SomeipServiceInstanceToMachineMapping.udpPort中派生。如果端口号（SomeipServiceInstanceToMachineMapping.udpPort）被配置为0，则应使用*临时*端口。如果端口号被配置为与0不同的值，则应使用该值。

- The TCP port shall be derived from SomeipServiceInstanceToMachineMapping.tcpPort. In case the port number (SomeipServiceInstanceToMachineMapping.tcpPort) is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that value shall be used.

> TCP端口应从SomeipServiceInstanceToMachineMapping.tcpPort中获取。如果端口号（SomeipServiceInstanceToMachineMapping.tcpPort）被配置为0，则应使用*临时*端口。如果端口号被配置为非0的值，则应使用该值。

```{=html}
<!--->
```

- The InitialDataRequested flag shall be set to 1 for fields and to 0 for events.
- Reserved shall be set to 0.
- Counter shall be set to 0.


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00103, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005, RS_SOMEIPSD_00015)*

> *♩(RS_CM_00204，RS_CM_00200，RS_CM_00103，RS_SOMEIPSD_00006，RS_SOMEIPSD_00005，RS_SOMEIPSD_00015)*


**Note:** In AUTOSAR Adaptive Platform (and ara::com) there are currently no use cases in having parallel subscribes by the same subscriber to the same eventgroup of the same service (, with the only difference being in the endpoint).

> **注意：** 在AUTOSAR Adaptive Platform（和ara :: com）中，目前没有使用同一个订阅者对同一个服务的同一个事件组进行并行订阅（仅端点不同）的用例。


**[SWS_CM_00206] SOME/IP SubscribeEventgroupAck message** *[*The fields in the SOME/IP SubscribeEventgroupAck message shall be as follows:

> **[SWS_CM_00206] SOME/IP 订阅事件组确认消息** *[*SOME/IP 订阅事件组确认消息的字段如下：


- The Type field and the TTL field shall be set to values suitable for a SubscribeEventgroupAck entry, which means that

> 类型字段和TTL字段应设置为适用于SubscribeEventgroupAck条目的合适值，这意味着


  The Type field shall be set to SubscribeEventgroupAck (see [PRS_SOMEIPSD_00391] for numerical value)

> 字段类型应设置为SubscribeEventgroupAck（参见[PRS_SOMEIPSD_00391]了解其数值）。

  The TTL field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupAck message (see [PRS_SOMEIPSD_00391])

> TTL字段应设置为与被此SubscribeEventgroupAck消息回复的SubscribeEventgroup消息中的值相同（参见[PRS_SOMEIPSD_00391]）。

- The Service ID field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupAck message.

> 服务ID字段应设置为与由此SubscribeEventgroupAck消息响应的SubscribeEventgroup消息中的相同值。

- The Instance ID field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupAck message.

> 该实例ID字段应设置为与此SubscribeEventgroupAck消息回复的SubscribeEventgroup消息中相同的值。

- The Major Version field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupAck message.

> 主版本字段应设置为与被此SubscribeEventgroupAck消息响应的SubscribeEventgroup消息中的值相同。

- The Eventgroup ID field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupAck message.

> 该事件组ID字段应设置为与回复此SubscribeEventgroupAck消息的SubscribeEventgroup消息中相同的值。
- The Multicast Option(s) shall be set in the following way


  An IPv4 Multicast Option shall be derived from the Manifest if a multicastThreshold with a value greater 0 is defined for the SomeipProvidedEventGroup and a ipv4MulticastIpAddress is defined for the same SomeipProvidedEventGroup.

> 如果为SomeipProvidedEventGroup定义了值大于0的multicastThreshold，并且为同一个SomeipProvidedEventGroup定义了ipv4MulticastIpAddress，则应从Manifest中派生出一个IPv4多播选项。

  An IPv6 Multicast Option shall be derived from the Manifest if a multicastThreshold with a value greater 0 is defined for the SomeipProvidedEventGroup and a ipv6MulticastIpAddress is defined for the same SomeipProvidedEventGroup.

> 如果为SomeipProvidedEventGroup定义了大于0的multicastThreshold值并且为同一个SomeipProvidedEventGroup定义了ipv6MulticastIpAddress，则可以从Manifest中派生出IPv6多播选项。

  The Transport Layer Protocol shall be set to UDP. Only UDP is supported as transport layer protocol in the IPv4 Multicast Option and/or IPv6 Multicast Option.

> 传输层协议必须设置为UDP。在IPv4多播选项和/或IPv6多播选项中，只支持UDP作为传输层协议。

  The UDP Port shall be derived from the the Manifest where the ProvidedSomeipServiceInstance that aggregates the SomeipProvidedEventGroup has the eventMulticastUdpPort defined.

> UDP 端口应从清单中派生，其中聚合SomeipProvidedEventGroup的ProvidedSomeipServiceInstance定义了eventMulticastUdpPort。
- The InitialDataRequested flag shall be set to 1 for fields and to 0 for events.
- Reserved shall be set to 0.
- Counter shall be set to 0.


*♩(RS_CM_00204, RS_SOMEIPSD_00015, RS_SOMEIPSD_00006, RS_SOMEIPSD_00002, RS_SOMEIPSD_00003, RS_SOMEIPSD_00005)*

> *♩(RS_CM_00204, RS_SOMEIPSD_00015, RS_SOMEIPSD_00006, RS_SOMEIPSD_00002, RS_SOMEIPSD_00003, RS_SOMEIPSD_00005)*

*♩(RS_CM_00204，RS_SOMEIPSD_00015，RS_SOMEIPSD_00006，RS_SOMEIPSD_00002，RS_SOMEIPSD_00003，RS_SOMEIPSD_00005)*


**[SWS_CM_00208] SOME/IP SubscribeEventgroupNack message** *[*The fields in the SOME/IP SubscribeEventgroupNack message shall be as follows:

> **[SWS_CM_00208] SOME/IP 订阅事件组Nack消息** *[*SOME/IP SubscribeEventgroupNack消息的字段如下：


- The Type field and the TTL field shall be set to values suitable for a SubscribeEventgroupNack entry, which means that

> 将类型字段和TTL字段设置为适用于SubscribeEventgroupNack条目的合适值，这意味着


  The type field shall be set to SubscribeEventgroupAck (see [PRS_SOMEIPSD_00394] for numerical value)

> 字段类型应设置为SubscribeEventgroupAck（参见[PRS_SOMEIPSD_00394]以获取数值）
  The TTL field shall be set to 0x000000 (see [PRS_SOMEIPSD_00394])

- The Service ID field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupNack message.

> 服务ID字段应设置为与此SubscribeEventgroupNack消息回复的SubscribeEventgroup消息中的相同值。

- The Instance ID field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupNack message.

> 该实例ID字段应设置为与此SubscribeEventgroupNack消息回复的SubscribeEventgroup消息中相同的值。

- The Major Version field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupNack message.

> 主版本字段应设置为与此SubscribeEventgroupNack消息回复的SubscribeEventgroup消息中的相同值。

- The Eventgroup ID field shall be set to the same value as in the SubscribeEventgroup message that is answered by this SubscribeEventgroupNack message.

> 事件组ID字段应设置为与此SubscribeEventgroupNack消息回复的SubscribeEventgroup消息中的值相同。
- The InitialDataRequested flag shall be set to 1 for fields and to 0 for events.
- Reserved shall be set to 0.
- Counter shall be set to 0.

*♩(RS_CM_00204, RS_SOMEIPSD_00016, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005)*


**[SWS_CM_10378] Sending SOME/IP StopSubscribeEventgroup messages** *[*Stopping the subscription of an Event (ServiceInterface.event) of an Eventgroup (SomeipEventGroup) by invoking the Unsubscribe method (see [[SWS_CM_00151](#_bookmark560)]) of the specific Event class of the ServiceProxy class shall *not* cause the sending of a SOME/IP StopSubscribeEventgroup message if there are still active subscriptions for other Events of the same Eventgroup.

> [SWS_CM_10378] 发送SOME/IP StopSubscribeEventgroup消息*[*停止对服务（ServiceInterface.event）的事件组（SomeipEventGroup）的订阅，通过调用特定事件类的Unsubscribe方法（参见[[SWS_CM_00151]（#_bookmark560）]），如果对同一事件组的其他事件仍有活动订阅，则不会发送SOME/IP StopSubscribeEventgroup消息。


Stopping the subscription of the *last* Event of an Eventgroup by invoking the Unsubscribe method (see [[SWS_CM_00151](#_bookmark560)]) of the specific Event class of the ServiceProxy class shall cause the sending of a SOME/IP StopSubscribeEventgroup message.*♩(RS_CM_00204, RS_CM_00104, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005, RS_SOMEIPSD_00017)*

> 停止订阅服务代理类的特定事件类的Unsubscribe方法（参见[[SWS_CM_00151](#_bookmark560)）中的最后一个事件组，应发送SOME/IP StopSubscribeEventgroup消息。 ♩（RS_CM_00204，RS_CM_00104，RS_SOMEIPSD_00006，RS_SOMEIPSD_00005，RS_SOMEIPSD_00017）


**[SWS_CM_00207] Content of SOME/IP StopSubscribeEventgroup message** *[*The fields in the SOME/IP StopSubscribeEventgroup message shall be as follows:

> **[SWS_CM_00207] SOME/IP 停止订阅事件组消息的内容** *[*SOME/IP 停止订阅事件组消息的字段如下：


- The Type field and the TTL field shall be set to values suitable for a StopSubscribeEventgroup entry, which means that

> 字段"类型"和"TTL"应设置为适用于StopSubscribeEventgroup条目的值，这意味着


  The Type field shall be set to SubscribeEventgroup (see [PRS_SOMEIPSD_00386] for numerical value)

> 字段类型应设置为SubscribeEventgroup（参见[PRS_SOMEIPSD_00386]以获取数值）
  The TTL field shall be set to 0x000000 (see [PRS_SOMEIPSD_00389])
- The Service ID field shall be set to the same value as in the SubscribeEventgroup message.
- The Instance ID field shall be set to the same value as in the SubscribeEventgroup message.
- The Major Version field shall be set to the same value as in the SubscribeEventgroup message.
- The Eventgroup ID field shall be set to the same value as in the SubscribeEventgroup message.
- IPv4 Endpoint Option shall be set to the same value as in the SubscribeEventgroup message.
- IPv6 Endpoint Option shall be set to the same value as in the SubscribeEventgroup message.
- The InitialDataRequested flag shall be set to 1 for fields and to 0 for events.
- Reserved shall be set to 0.
- Counter shall be set to 0.


*♩(RS_CM_00204, RS_CM_00104, RS_SOMEIPSD_00006, RS_SOMEIPSD_00005, RS_SOMEIPSD_00017)*

> *♩(RS_CM_00204，RS_CM_00104，RS_SOMEIPSD_00006，RS_SOMEIPSD_00005，RS_SOMEIPSD_00017)*


**[SWS_CM_11375] Link loss on Client side** *[*In case the SOME/IP network binding detects a link loss on the client side, the SOME/IP service discovery shall react according to [PRS_SOMEIPSD_00752] (i.e., re-enter the initial wait phase once the link is up again and the service is still requested).*♩()*

> **[SWS_CM_11375] 客户端连接丢失** *[*如果SOME/IP网络绑定检测到客户端发生连接丢失，那么SOME/IP服务发现应根据[PRS_SOMEIPSD_00752]（即，一旦连接恢复并且仍然请求服务时，重新进入初始等待阶段）进行反应。*♩()*


**[SWS_CM_11376] Link loss on Server side** *[*In case the SOME/IP network binding detects a link loss on the server side, the SOME/IP service discovery shall react according to [PRS_SOMEIPSD_00751] (i.e., re-enter the initial wait phase once the link is up again and the service is still requested).*♩()*

> 如果SOME/IP网络绑定检测到服务器端的链路丢失，SOME/IP服务发现应根据[PRS_SOMEIPSD_00751]（即，一旦链路恢复，并且仍然请求服务时，重新进入初始等待阶段）作出反应。

### Accumulation of SOME/IP messages


**[SWS_CM_10387] Data accumulation for UDP data transmission** *[*To allow for the transmission of multiple SOME/IP event, method request and method response messages within a single UDP datagram, data accumulation for UDP data transmission shall be supported.*♩(RS_CM_00204)*

> **[SWS_CM_10387] UDP 数据传输的数据积累** *[*为了允许在单个 UDP 数据报中传输多个 SOME/IP 事件、方法请求和方法响应消息，应支持 UDP 数据传输的数据积累。*♩（RS_CM_00204）*


**[SWS_CM_10388] Enabling of data accumulation for UDP data transmission** *[*Data accumulation for UDP data transmission over the udpPort and unicastNetworkEndpoint defined on the EthernetCommunicationConnector that is referenced by a SomeipServiceInstanceToMachineMapping shall be enabled if the attribute SomeipServiceInstanceToMachineMapping.udpCollectionBufferSizeThreshold is set to a value. In this case all event and method messages that are configured for data accumulation shall be aggregated in a buffer until a transmission trigger (see [[SWS_CM_10389](#_bookmark52)] and [[SWS_CM_10390](#_bookmark53)]) arrives and the data transmission starts.*♩(RS_CM_00204)*

> [SWS_CM_10388] 对于由SomeipServiceInstanceToMachineMapping引用的EthernetCommunicationConnector上定义的udpPort和unicastNetworkEndpoint的UDP数据传输，如果将SomeipServiceInstanceToMachineMapping.udpCollectionBufferSizeThreshold设置为某个值，则应启用数据累积。在这种情况下，所有配置为数据累积的事件和方法消息都将聚合到缓冲区中，直到传输触发器（参见[[SWS_CM_10389](#_bookmark52)]和[[SWS_CM_10390](#_bookmark53)])到达并数据传输开始。*♩(RS_CM_00204)*


**[SWS_CM_10389] Configuration of a data accumulation on a ProvidedSomeipServiceInstance for transmission over UDP** *[*For a ProvidedSomeipServiceInstance all method responses and events for which the udpCollectionTrigger is set to never shall be aggregated in a buffer until a trigger arrives that starts the data transmission.

> 为ProvidedSomeipServiceInstance，所有udpCollectionTrigger设置为永不的方法响应和事件将被聚合到一个缓冲区，直到触发器到达开始数据传输。

The following trigger options shall be supported:

- a SOME/IP message needs to be transmitted for which the udpCollectionTrigger is set to always.

- the udpCollectionBufferTimeout is reached for one of the SOME/IP message already aggregated in the buffer.

> 聚合缓冲区中的某个SOME/IP消息已达到udpCollectionBufferTimeout。
- the buffer size defined by the attribute udpCollectionBufferSizeThreshold is reached.

- adding the method response or event to the buffer would lead to a message larger than the maximum possible size (e.g. MTU size). In this case the actual buffer shall be triggered before handling the new event or method response.

> 增加方法响应或事件到缓冲区会导致消息大小超过最大可能大小（例如MTU大小）。在这种情况下，应该在处理新的事件或方法响应之前触发实际的缓冲区。

*♩(RS_CM_00204)*


**[SWS_CM_10390] Configuration of a data accumulation on a RequiredSomeipServiceInstance for transmission over UDP** *[*For a RequiredSomeipServiceInstance all method requests for which the udpCollectionTrigger is set to never shall be aggregated in a buffer until a trigger arrives that starts the data transmission.

> [SWS_CM_10390] 对于RequiredSomeipServiceInstance，所有udpCollectionTrigger设置为never的方法请求都应在缓冲区中聚合，直到触发器触发数据传输开始。

The following trigger options shall be supported:

- a SOME/IP message needs to be transmitted for which the udpCollectionTrigger is set to always.

- the udpCollectionBufferTimeout is reached for one of the SOME/IP message already aggregated in the buffer.

> 已在缓冲区中聚合的某些/IP消息之一已达到udpCollectionBufferTimeout。
- the buffer size defined by the attribute udpCollectionBufferSizeThreshold is reached.

- adding the method request or event to the buffer would lead to a message larger than the maximum possible size (e.g. MTU size). In this case the actual buffer shall be triggered before handling the new event or method response.

> 添加方法请求或事件到缓冲区将导致消息大小超过最大可能大小（例如MTU大小）。在这种情况下，应在处理新的事件或方法响应之前触发实际的缓冲区。

*♩(RS_CM_00204)*


In the following sections the term \"sending of a SOME/IP message shall be requested\" will be used to describe the fact that the sending of the message is requested but may be deferred due to data accumulation for UDP data transmission according to [[SWS_CM_10388](#_bookmark51)], [[SWS_CM_10389](#_bookmark52)], and [[SWS_CM_10390](#_bookmark53)].

> 在接下来的章节中，“发送SOME / IP消息”一词将用于描述由于根据[[SWS_CM_10388](#_bookmark51)]，[[SWS_CM_10389](#_bookmark52)]和[[SWS_CM_10390](#_bookmark53)]的UDP数据传输而请求发送消息的事实，但可能由于数据积累而被推迟。

### Execution context of message reception actions


In the following sections the term \"upon reception\" will be used to describe the fact that certain actions (e.g, the deserialization of the payload according to [[SWS_CM_10294](#_bookmark65)]) will be performed at a point in time between the actual reception of a message and the call of the corresponding API (e.g., the GetNewSamples (see [[SWS_CM_00701](#_bookmark570)]) method of the respective Event class). This specification deliberately does not explicitly state whether these actions will be performed in the context of message reception, in the context of the API call, or in a completely seperate execution context to leave room for potential optimizations of a concrete ara::com implementation.

> 在接下来的部分，术语“接收后”将用于描述某些动作（例如，根据[[SWS_CM_10294](#_bookmark65)）反序列化有效负载）将在实际接收消息和调用相应API（例如，GetNewSamples（参见[[SWS_CM_00701](#_bookmark570)）方法）之间的某个时间点执行。本规范故意不明确说明这些操作是在消息接收上下文中执行，还是在API调用上下文中执行，或者在完全独立的执行上下文中执行，以为具体的ara :: com实现留下优化的空间。


The only restriction imposed here refers to the execution context of the EventReceiveHandler (see [[SWS_CM_00309](#_bookmark481)]). -Executing the EventReceiveHandler in the context of the GetNewSamples (see [[SWS_CM_00701](#_bookmark570)]) method is not allowed,

> 此处施加的唯一限制是关于EventReceiveHandler的执行上下文（参见[[SWS_CM_00309](#_bookmark481)]]）。不允许在GetNewSamples（参见[[SWS_CM_00701](#_bookmark570)）]）方法的上下文中执行EventReceiveHandler。


since according to [[SWS_CM_00181](#_bookmark573)] the EventReceiveHandlershall use the GetNewSamples method to access the retrieved event data.

> 根据[[SWS_CM_00181](#_bookmark573)]，事件接收处理程序应使用GetNewSamples方法访问检索的事件数据。


**[SWS_CM_11270]**{DRAFT} **Selecting elements of the ServiceInterface for SecOC transmission** *[*It is possible to define which elements of the ServiceInterface of the particular AdaptivePlatformServiceInstance shall be securedby SecOC. The selection of ServiceInterface elements is done by the ServiceInterfaceElementSecureComConfigthat is aggregated by AdaptivePlatformServiceInstance.

> **[SWS_CM_11270]**{草案} **选择特定AdaptivePlatformServiceInstance的ServiceInterface元素以进行SecOC传输** *[*可以定义哪些ServiceInterface元素由SecOC保护。 ServiceInterface元素的选择是由AdaptivePlatformServiceInstance聚合的ServiceInterfaceElementSecureComConfig完成的。

The following configuration in the ServiceInterfaceElementSecureComConfig

is applicable:

- ### Methods


The roles methodCall and methodReturn identify the method(s) that shall be sprotected by SecOC with the configuration settings that are available in the ServiceInterfaceElementSecureComConfig element.

> 方法调用和方法返回的角色确定了应用SecOC保护的方法，而ServiceInterfaceElementSecureComConfig元素中提供了可用的配置设置。

- ### Events


The role event identifies the event(s) that shall be protected by SecOC with the configuration settings that are availble in the ServiceInterfaceElementSecureComConfig element.

> 角色事件确定将由SecOC保护的事件，并且可以在ServiceInterfaceElementSecureComConfig元素中获取相应的配置设置。

- ### Fields


The roles fieldNotifier, getterCall, getterReturn, setterCall and setterReturn identify the field content that shall be protected by SecOC with the configuration settings that are available in the ServiceInterfaceElementSecureComConfig element.

> 字段Notifier、getterCall、getterReturn、setterCall 和setterReturn标识将通过ServiceInterfaceElementSecureComConfig元素中可用的配置设置由SecOC保护的字段内容。

*♩(RS_CM_00801, RS_CM_00803)*

### Handling Events


**[SWS_CM_10287] Conditions for sending of a SOME/IP event message** *[*The sending of a SOME/IP event message shall be requested by invoking the Send method of the respective Event class (see [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)] and [[SWS_CM_90437](#_bookmark532)]) if there is static service connection according to [SWS_CM_02201] or if there is at least one active subscriber and the offer of the service containing the event has not been stopped (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called). An active subscriber is an adaptive application that has invoked the Subscribe method of the respective Event class (see [[SWS_CM_00141](#_bookmark559)]) and has not canceled the subscription by invoking the Unsubscribe method of the respective Event class (see [[SWS_CM_00151](#_bookmark560)]) and where the subscription has not yet expired since the TTL contained in the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has been exceeded.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_SOMEIP_00017)*

> 发送SOME/IP事件消息的条件：

如果按照[SWS_CM_02201]有静态服务连接，或者至少有一个活动的订阅者，并且包含事件的服务的报价没有被停止（要么是因为在SOME/IP OfferService消息（参见[SWS_CM_00203]）中包含的TTL已经过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见[SWS_CM_00111]）已被调用），则可以通过调用相应事件类的Send方法（参见[SWS_CM_00162]和[SWS_CM_90437]）来请求发送SOME/IP事件消息。活动订阅者是已经调用相应事件类的Subscribe方法（参见[SWS_CM_00141]）并且尚未通过调用相应事件类的Unsubscribe方法（参见[SWS_CM_00151]）取消订阅，且订阅尚未过期（即SOME/IP SubscribeEventgroup消息（参见[SWS_CM_00205]）中包含的TTL未超过）的应用程序。


**[SWS_CM_10288] Transport protocol for sending of a SOME/IP event message** *[*The SOME/IP event message shall be transmitted using the transport protocol defined via the SomeipServiceInterfaceDeployment.eventDeployment.transportProtocol attribute (see [TPS_MANI_03050]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00010)*

> **[SWS_CM_10288] 发送SOME/IP事件消息的传输协议** *[*SOME/IP事件消息应使用通过SomeipServiceInterfaceDeployment.eventDeployment.transportProtocol属性定义的传输协议进行传输（参见[TPS_MANI_03050]）。*♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00010）*


**[SWS_CM_10289] Source of a SOME/IP event message** *[*The SOME/IP event message shall use the unicast IP address and port taken from the IPv4/v6 Endpoint Option (see [PRS_SOMEIPSD_00307] and [PRS_SOMEIPSD_00315]) of the SOME/IP Of-

> **[SWS_CM_10289] SOME / IP事件消息的来源** *[*SOME / IP事件消息应使用从SOME / IP的IPv4 / v6端点选项（参见[PRS_SOMEIPSD_00307]和[PRS_SOMEIPSD_00315]）获取的单播IP地址和端口。


ferService message ([[SWS_CM_00203](#_bookmark45)]) or the server address which has been statically pre-configured by the static service connection according to [SWS_CM_02201] as source address and source port for the transmission.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00042)*

> 服务器消息（[[SWS_CM_00203](#_bookmark45)]) 或者根据[SWS_CM_02201]静态配置的静态服务连接的服务器地址，用作传输的源地址和源端口♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00042）*。


**[SWS_CM_10290] Destination of a SOME/IP event message** *[*The SOME/IP event message shall use the multicast IP address and the port taken from the IPv4/v6 Multicast Option (see [PRS_SOMEIPSD_00326] and [PRS_SOMEIPSD_00333]) of the SOME/IP SubscribeEventgroupAck message (see [[SWS_CM_00206](#_bookmark48)]) or the client address which has been statically pre-configured by the static service connection according to [SWS_CM_02201] as destination address and destination port for the transmission if the threshold defined by the multicastThreshold attribute of the SomeipProvidedEventGroup that is aggregated by the ProvidedSomeipServiceInstance in the role eventGroup in the Manifest has been reached (see [PRS_SOMEIPSD_00134]). The SOME/IP event message shall use the unicast IP address and the port taken from the IPv4/v6 Endpoint Option (see [PRS_SOMEIPSD_00307] and [PRS_SOMEIPSD_00315]) of the SOME/IP SubscribeEventgroup message ([[SWS_CM_00205](#_bookmark47)]) as destination address and destination port for the transmission if this threshold has not been reached (see [PRS_SOMEIPSD_00134]). In case multiple Endpoint Options have been contained in the SOME/IP SubscribeEventgroup message, the one matching the selected transport protocol (see [[SWS_CM_10289](#_bookmark58)]) shall be used.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00042)*

> 事件信息报文的目的地应使用SOME/IP订阅事件组确认消息（参见[SWS_CM_00206]）的IPv4/v6多播选项（参见[PRS_SOMEIPSD_00326]和[PRS_SOMEIPSD_00333]）中的多播IP地址和端口，或者根据[SWS_CM_02201]静态配置的客户端地址作为传输的目的地地址和目的端口，如果达到了Manifest中聚合的SomeipProvidedEventGroup的multicastThreshold属性定义的阈值（参见[PRS_SOMEIPSD_00134]）。如果没有达到这个阈值，则SOME/IP事件报文应使用SOME/IP订阅事件组消息（参见[SWS_CM_00205]）中的IPv4/v6端点选项（参见[PRS_SOMEIPSD_00307]和[PRS_SOMEIPSD_00315]）中的单播IP地址和端口作为目的地地址和目的端口进行传输（参见[PRS_SOMEIPSD_00134]）。如果SOME/IP订阅事件组消息中包含多个端点选项，则应使用与所选传输协议匹配的端点选项（参见[SWS_CM_10289]）。


**[SWS_CM_10291] Content of the SOME/IP event message** *[*The entries in the SOME/IP event message shall be as follows:

> **[SWS_CM_10291] SOME/IP事件信息的内容** *[*SOME/IP事件信息的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从清单中派生，其中SomeipServiceInterfaceDeployment元素定义了eventDeployment.eventId，并将0x8000加到eventDeployment.eventId上。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效载荷的长度，单位为字节，增加8（SOME / IP头的第二部分，由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) is unused for event messages (according to [PRS_SOMEIP_00702]) and thus shall be set to 0x0000.

> 客户端ID（参见[PRS_SOMEIP_00702]）对事件消息未使用（根据[PRS_SOMEIP_00702]），因此应设置为0x0000。

- In case of inactive Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID (see [PRS_SOMEIP_00703]) is unused for event messages and thus shall be set to 0x0000 (see [PRS_SOMEIP_00932]) and [PRS_SOMEIP_00925]).

> 在处理非活动会话的情况下，请参见[[SWS_CM_10240](#_bookmark40)]，会话ID（参见[PRS_SOMEIP_00703]）对于事件消息不使用，因此应设置为0x0000（参见[PRS_SOMEIP_00932]和[PRS_SOMEIP_00925]）。


In case of active Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID is used for event messages and thus shall be incremented (with proper wrap around) upon every transmission of an event message (see [PRS_SOMEIP_00933], [PRS_SOMEIP_00934], [PRS_SOMEIP_00521], and [PRS_SOMEIP_-

> 在活动会话处理的情况下，请参见[[SWS_CM_10240](#_bookmark40)]，会话ID用于事件消息，因此每次发送事件消息时都应该增加（并进行适当的环绕）（参见[PRS_SOMEIP_00933]，[PRS_SOMEIP_00934]，[PRS_SOMEIP_00521]和[PRS_SOMEIP_-]）。

00925]).


The information whether the Session Handling is activated or deactivated for an event can be derived from the sessionHandling attribute contained in the ApSomeipTransformationProps that is referenced by the TransformationPropsToServiceInterfaceElementMapping that in turn points to the event.

> 可以从指向该事件的TransformationPropsToServiceInterfaceElementMapping引用的ApSomeipTransformationProps中包含的sessionHandling属性中获得该事件的会话处理是否已激活或停用的信息。

- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义服务接口版本的主要版本。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to NOTIFICATION

(0x02).


- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for event messages and thus (according to [PRS_SOMEIP_00925]) shall be set to E_OK (0x00).

> 返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对于事件消息没有使用，因此（根据[PRS_SOMEIP_00925]）应设置为E_OK（0x00）。

- The Payload shall contain the serialized payload (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) according to the SOME/IP serialization rules.

> 负载应包含根据SOME/IP序列化规则序列化的负载（即由事件角色的ServiceInterface组成的序列化VariableDataPrototype）。

*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_-*


*SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004)* The serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> *SOMEIP_00022、RS_SOMEIP_00003、RS_SOMEIP_00004）的序列化规则在[7.5.1.9]（#序列化有效负载）节中有解释。


**[SWS_CM_10292] Checks for a received SOME/IP event message** *[*Upon reception of a SOME/IP event message the following checks shall be conducted:

> 收到SOME/IP事件消息后，应进行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.

- Use the Length (see [PRS_SOMEIP_00042]) being larger than 8 in combination with the Message type (see [PRS_SOMEIP_00055]) being set to NOTIFICATION to determine that the received SOME/IP message is actually an event.

> 使用长度（参见[PRS_SOMEIP_00042]）大于8，结合消息类型（参见[PRS_SOMEIP_00055]）设置为通知，可以确定收到的SOME/IP消息实际上是一个事件。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches 0x8000 + the eventId attribute of one of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment.

> 验证方法ID（参见[PRS_SOMEIP_00245]）与SomeipServiceInterfaceDeployment的SomeipEventDeployment的eventId属性+ 0x8000是否匹配。
- Verify that the Client ID (see [PRS_SOMEIP_00702]) is set to 0x0000.

- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 验证接口版本（参见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion相匹配。

- Verify that the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is set to E_OK (0x00).

> 验证返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为E_OK（0x00）。


If any of the above checks fails the received SOME/IP event message shall be discarded and and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014)*

> 如果上述检查中任何一项失败，则应丢弃所收到的SOME/IP事件消息，并记录事件（如果ara :: com实现启用了日志记录）。*♩（RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00019，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00008，RS_SOMEIP_00014）*


**[SWS_CM_10293] Identifying the right event** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_00245]) and 0x8000 + the eventId attribute of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment, the right event shall be identified.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00022)*

> 使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性以及方法ID（参见[PRS_SOMEIP_00245]）和0x8000 + SomeipEventDeployments的eventId属性，应识别出正确的事件。（RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00022）


**[SWS_CM_10379] Silently discarding SOME/IP event messages for unsubscribed events** *[*If the event identified according to [[SWS_CM_10293](#_bookmark62)] does not have an active subscription because the Subscribe method (see [[SWS_CM_00141](#_bookmark559)]) of the specific Event class of the ServiceProxy class has not been called, or the Unsubscribe method (see [[SWS_CM_00151](#_bookmark560)]) of the specific Event class of the ServiceProxy class has been called, or the TTL of the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has expired, and if there is no static service connection according to [SWS_CM_02201], the received SOME/IP event message shall be silently discarded (i.e., [[SWS_CM_10294](#_bookmark65)], [[SWS_CM_10295](#_bookmark66)], and [[SWS_CM_10296](#_bookmark64)] shall *not* be performed).*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004)*

> [SWS_CM_10379] 如果根据[[SWS_CM_10293](#_bookmark62)]确定的事件没有活动的订阅，因为没有调用特定事件类的ServiceProxy类的Subscribe方法（参见[[SWS_CM_00141](#_bookmark559)），或者调用特定事件类的ServiceProxy类的Unsubscribe方法（参见[[SWS_CM_00151](#_bookmark560)），或者SOME/IP SubscribeEventgroup消息的TTL（参见[[SWS_CM_00205](#_bookmark47)）已过期，而且如果没有根据[SWS_CM_02201]的静态服务连接，则收到的SOME/IP事件消息将被静默丢弃（即，[[SWS_CM_10294](#_bookmark65)，[[SWS_CM_10295](#_bookmark66)，[[SWS_CM_10296](#_bookmark64)]不会执行）。♩(RS_CM_00204，RS_CM_00203，RS_SOMEIP_00004)


**[SWS_CM_10296] Invoke receive handler** *[*In case a receive handler was registered using the SetReceiveHandler method (see [[SWS_CM_00181](#_bookmark573)]) of the respective Event class for the event determined according to [[SWS_CM_10293](#_bookmark62)] this registered receive handler shall be invoked.*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004)*

> **[SWS_CM_10296] 调用接收处理器** *[*如果使用该事件类的SetReceiveHandler方法（参见[[SWS_CM_00181](#_bookmark573)）注册了接收处理器，根据[[SWS_CM_10293](#_bookmark62)]确定的事件，则应调用该注册的接收处理器。*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004)*


**[SWS_CM_10294] Deserializing the payload** *[*Based on the event determined according to [[SWS_CM_10293](#_bookmark62)] the Payload of the SOME/IP event message (i.e., the serialized VariableDataPrototype composed by the ServiceInterface in role event) shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00028)* The serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> 根据[[SWS_CM_10293](#_bookmark62)]确定的事件，以服务接口在事件角色中组成的序列化变量数据原型（即SOME/IP事件消息的有效负载）应按照SOME/IP序列化规则进行反序列化。 序列化规则在[7.5.1.9](#serialization-of-payload)节中有解释。


**[SWS_CM_10295] Providing the received event data** *[*The deserialized payload containing the event data shall be provided via the GetNewSamples (see [[SWS_CM_00701](#_bookmark570)]) method of the respective Event class for the event determined according to [[SWS_CM_10293](#_bookmark62)].*♩(RS_CM_00204, RS_CM_00202, RS_SOMEIP_00004)*

> **[SWS_CM_10295] 提供接收到的事件数据** *[*反序列化的包含事件数据的有效负载应通过相应的事件类的GetNewSamples方法（参见[[SWS_CM_00701](#_bookmark570)），根据[[SWS_CM_10293](#_bookmark62)确定的事件来提供。*♩(RS_CM_00204, RS_CM_00202, RS_SOMEIP_00004)*


**[SWS_CM_10360]**{DRAFT} **Failures in sending a SOME/IP event message** *[*If the sending of the SOME/IP event message fails locally (due to a network error which is notified to the ara::com implementation), the ara::com implementation shall return an error indicating \"network binding failure\" in the Result of the Send() method of the respective Event class (see [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)] and [[SWS_CM_90437](#_bookmark532)]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_CM_00004)*

> 如果SOME/IP事件消息的发送在本地失败（由于网络错误已经通知ara :: com实现），那么ara :: com实现将在相应事件类的Send（）方法的结果中返回一个指示“网络绑定失败”的错误（参见[[SWS_CM_00162]（#sws_cm_00162-send-event-where-application-is-responsible-for-the-data）]和[[SWS_CM_90437]（#_bookmark532）]）。*♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00005，RS_CM_00004）*

### Handling Triggers


**[SWS_CM_10511]**{DRAFT} **Conditions for sending of a SOME/IP trigger** *[*The sending of a SOME/IP trigger shall be requested by invoking the Send method of the respective Trigger class (see [[SWS_CM_00721](#_bookmark535)]) if there is static service connection according to [SWS_CM_02201] or if there is at least one active subscriber and the offer of the service containing the trigger has not been stopped (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called). An active subscriber is an adaptive application that has invoked the Subscribe method of the respective Trigger class (see [[SWS_CM_00723](#_bookmark579)]) and has not canceled the subscription by invoking the Unsubscribe method of the respective Trigger class (see [[SWS_CM_00810](#_bookmark580)]) and where the subscription has not yet expired since the TTL contained in the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has been exceeded.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_SOMEIP_-*

> 发送SOME/IP触发器的条件：如果有按照[SWS_CM_02201]的静态服务连接，或者至少有一个活动订阅者，且包含触发器的服务未停止（要么是因为SOME/IP OfferService消息（参见[[SWS_CM_00203](#_bookmark45)）中包含的TTL已过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见[[SWS_CM_00111](#_bookmark523)）已被调用），则可以通过调用相应触发器类的Send方法（参见[[SWS_CM_00721](#_bookmark535)）来请求发送SOME/IP触发器。活动订阅者是调用相应触发器类的Subscribe方法（参见[[SWS_CM_00723](#_bookmark579)）并且未通过调用相应触发器类的Unsubscribe方法（参见[[SWS_CM_00810](#_bookmark580)）取消订阅，且订阅未过期（即SOME/IP SubscribeEventgroup消息（参见[[SWS_CM_00205](#_bookmark47)）中包含的TTL未超过）的应用程序。

*00017)*


Please note that in the Manifest configuration the SomeipServiceInterfaceDeployment.eventDeployment is used to configure triggers in the same way as events. The only difference is that in case of a trigger the SomeipEventDeployment will reference the Trigger in the role trigger. Therefore the following specification items described in chapter [7.5.1.5](#handling-events) are also valid for Triggers since a trigger defines a special kind of an event.

> 请注意，在Manifest配置中，SomeipServiceInterfaceDeployment.eventDeployment用于以与事件相同的方式配置触发器。唯一的区别是，在触发器的情况下，SomeipEventDeployment将在角色触发器中引用触发器。因此，第7.5.1.5节中描述的以下规范项目也适用于触发器，因为触发器定义了一种特殊类型的事件。

- [[SWS_CM_10288](#_bookmark57)]
- [[SWS_CM_10289](#_bookmark58)]
- [[SWS_CM_10290](#_bookmark59)]


**[SWS_CM_10512]**{DRAFT} **Content of the SOME/IP trigger** *[*The entries in the SOME/IP trigger shall be as follows:

> **[SWS_CM_10512]**{草案} **SOME/IP 触发器的内容** *[*SOME/IP 触发器中的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应该从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义eventDeployment.eventId，通过将0x8000添加到eventDeployment.eventId。
- The Length (see [PRS_SOMEIP_00042]) shall be set to 8

- The Client ID (see [PRS_SOMEIP_00702]) is unused for triggers (according to [PRS_SOMEIP_00702]) and thus shall be set to 0x0000.

> 客户端ID（参见[PRS_SOMEIP_00702]）未用于触发器（根据[PRS_SOMEIP_00702]），因此应设置为0x0000。

- In case of inactive Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID (see [PRS_SOMEIP_00703]) is unused for triggers and thus shall be set to 0x0000 (see [PRS_SOMEIP_00932]) and [PRS_SOMEIP_00925]).

> 在处理非活动会话的情况下，请参阅[[SWS_CM_10240](#_bookmark40)]，会话ID（参见[PRS_SOMEIP_00703]）不用于触发器，因此应设置为0x0000（参见[PRS_SOMEIP_00932]和[PRS_SOMEIP_00925]）。


In case of active Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID is used for triggers and thus shall be incremented (with proper wrap around) upon every transmission of an trigger (see [PRS_SOMEIP_00933], [PRS_SOMEIP_00934], [PRS_SOMEIP_00521], and [PRS_SOMEIP_00925]).

> 在活动会话处理的情况下，请参见[[SWS_CM_10240](#_bookmark40)]，会话ID用于触发器，因此在每次发送触发器时应递增（适当地包装）（请参见[PRS_SOMEIP_00933]，[PRS_SOMEIP_00934]，[PRS_SOMEIP_00521]和[PRS_SOMEIP_00925]）。


The information whether the Session Handling is activated or deactivated for a trigger can be derived from the sessionHandling attribute contained in the ApSomeipTransformationProps that is referenced by the TransformationPropsToServiceInterfaceElementMapping that in turn points to the trigger.

> 可以从指向触发器的ApSomeipTransformationProps中包含的sessionHandling属性中获取触发器的会话处理是否激活或停用的信息。

- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceVersion.majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to NOTIFICATION

(0x02).


- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for triggers and thus (according to [PRS_SOMEIP_00925]) shall be set to E_OK (0x00).

> 返回代码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对触发器无用，因此（根据[PRS_SOMEIP_00925]）应设置为E_OK（0x00）。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004)*

> *♩(RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00041，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004)*


**[SWS_CM_10513]**{DRAFT} **Checks for a received SOME/IP trigger** *[*Upon reception of a SOME/IP trigger the following checks shall be conducted:

> **[SWS_CM_10513]**{草案} **检查收到的SOME/IP触发器** *[*收到SOME/IP触发器后，应进行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.

- Use the Length (see [PRS_SOMEIP_00042]) being equal to 8 in combination with the Message type (see [PRS_SOMEIP_00055]) being set to NOTIFICATION to determine that the received SOME/IP message is actually a trigger.

> 使用长度（参见[PRS_SOMEIP_00042]）等于8，结合消息类型（参见[PRS_SOMEIP_00055]）设置为通知，以确定接收到的SOME/IP消息实际上是触发器。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches 0x8000 + the eventId attribute of one of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment.

> 验证方法ID（参见[PRS_SOMEIP_00245]）是否与SomeipServiceInterfaceDeployment中的SomeipEventDeployments的eventId属性加上0x8000相匹配。
- Verify that the Client ID (see [PRS_SOMEIP_00702]) is set to 0x0000.

- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 验证接口版本（参见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion相匹配。

- Verify that the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is set to E_OK (0x00).

> 验证返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为E_OK（0x00）。


If any of the above checks fails the received SOME/IP trigger shall be discarded and and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00019, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00008, RS_SOMEIP_00014)*

> 如果上述任何一个检查失败，收到的SOME / IP触发器将被丢弃，并且事件将被记录（如果ara :: com实现启用了日志记录）。♩（RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00019，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00008，RS_SOMEIP_00014）


**[SWS_CM_10514]**{DRAFT} **Identifying the right trigger** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_00245]) and 0x8000 + the eventId attribute of the SomeipEventDeployments of the SomeipServiceInterfaceDeployment, the right trigger shall be identified.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00022)*

> 使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性，以及方法ID（参见[PRS_SOMEIP_00245]）和0x8000 + SomeipEventDeployments的eventId属性，应识别出正确的触发器（参见RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00022）。


**[SWS_CM_10515]**{DRAFT} **Silently discarding SOME/IP triggers for unsubscribed triggers** *[*If the trigger identified according to [[SWS_CM_10514](#_bookmark69)] does not have an active subscription because the Subscribe method (see [[SWS_CM_00723](#_bookmark579)]) of the specific Trigger class of the ServiceProxy class has not been called, or the Unsubscribe method (see [[SWS_CM_00810](#_bookmark580)]) of the specific Trigger class of the ServiceProxy class has been called, or the TTL of the SOME/IP SubscribeTriggergroup message (see [[SWS_CM_00205](#_bookmark47)]) has expired, and if there is no static service connection according to [SWS_CM_02201], the received SOME/IP trigger shall be silently discarded (i.e., [[SWS_CM_00226](#_bookmark582)], and [[SWS_CM_00249](#_bookmark584)] shall *not* be performed).*♩ (RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004)*

> 如果根据[[SWS_CM_10514](#_bookmark69)]确定的触发器没有活动的订阅，因为没有调用服务代理类的订阅方法（参见[[SWS_CM_00723](#_bookmark579)），或者调用了特定触发器类的取消订阅方法（参见[[SWS_CM_00810](#_bookmark580)），或者SOME/IP订阅触发组消息的TTL（参见[[SWS_CM_00205](#_bookmark47)）已过期，并且如果没有根据[SWS_CM_02201]的静态服务连接，则收到的SOME/IP触发器将被静默丢弃（即[[SWS_CM_00226](#_bookmark582)]和[[SWS_CM_00249](#_bookmark584)]*不*执行）。（RS_CM_00204，RS_CM_00203，RS_SOMEIP_00004）


**[SWS_CM_10516]**{DRAFT} **Invoke receive handler** *[*In case a receive handler was registered using the SetReceiveHandler method (see [[SWS_CM_00249](#_bookmark584)]) of the respective Trigger class for the trigger determined according to [[SWS_CM_10514](#_bookmark69)] this registered receive handler shall be invoked.*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004)*

> **[SWS_CM_10516]**{草案} **调用接收处理程序** *[*如果使用相应触发类的SetReceiveHandler方法（参见[[SWS_CM_00249](#_bookmark584)])注册了接收处理程序，根据[[SWS_CM_10514](#_bookmark69)]确定的触发器，应调用注册的接收处理程序。*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004)*


**[SWS_CM_10517]**{DRAFT} **Failures in sending a SOME/IP trigger** *[*If the sending of the SOME/IP trigger fails locally (due to a network error which is notified to the ara::com implementation), the ara::com implementation shall return an error indicating \"network binding failure\" in the Result of the Send() method of the respective Trigger class (see [[SWS_CM_00721](#_bookmark535)]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_CM_00004)*

> 如果SOME/IP触发器的发送在本地失败（由于ara :: com实施通知的网络错误），ara :: com实施将在相应触发器类的Send（）方法的结果中返回指示“网络绑定失败”的错误（请参见[[SWS_CM_00721]（＃_bookmark535）]）。 ♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00005，RS_CM_00004）

### Handling Method Calls


**[SWS_CM_10297] Conditions for sending of a SOME/IP request message** *[*The sending of a SOME/IP request message shall be requested by invoking the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) if there is static service connection according to [SWS_CM_02201] or if the providing service instance has not stopped offering the service (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called).*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007)*

> 发送SOME/IP请求消息的条件需要通过调用相应的方法类的函数调用运算符（operator()）来请求（参见SWS_CM_00196），如果按照SWS_CM_02201存在静态服务连接，或者提供服务实例没有停止提供服务（要么是因为SOME/IP OfferService消息（参见SWS_CM_00203）中包含的TTL已经过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见SWS_CM_00111）已被调用）。（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007）


**[SWS_CM_10441] Failures in sending of a SOME/IP request message** *[*If the sending of the SOME/IP request message fails locally (in a way which is notified to the ara::com implementation), the ara::com implementation shall make the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) ready according to [[SWS_CM_10440](#_bookmark437)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007)*

> 如果SOME/IP请求消息的发送在本地失败（ara::com实现会通知），ara::com实现应按照[[SWS_CM_10440](#_bookmark437)]使相应的Method类的函数调用操作符（operator()）返回的Future准备就绪。（参考RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007）


**[SWS_CM_10298] Transport protocol for sending of a SOME/IP request message** *[*The SOME/IP request message shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.methodDeployment.transportProtocol in the Manifest.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_00010)*

> **[SWS_CM_10298] 发送SOME/IP请求消息的传输协议** *[*SOME/IP请求消息应使用Manifest中SomeipServiceInterfaceDeployment.methodDeployment.transportProtocol属性定义的传输协议进行传输。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_00010)*


**[SWS_CM_10299] Source of a SOME/IP request message** *[*The SOME/IP request message shall use the unicast IP address defined in the Manifest by the Ipv4Configuration/Ipv6Configuration attribute of the NetworkEndpoint that is referenced (in role unicastNetworkEndpoint) by the EthernetCommunicationConnector of a Machine which in turn is mapped to the RequiredSomeipServiceInstance by means of a SomeipServiceInstanceToMachineMapping as source address for the transmission. The port number configured via udpPort shall be used to derive the source port for the transmission in case the selected transport protocol (see [[SWS_CM_10298](#_bookmark71)]) is UDP. If this port number is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that port shall be used. The port number configured via tcpPort shall be used to derive the source port for the transmission in case the selected transport protocol (see [[SWS_CM_10298](#_bookmark71)]) is TCP. If this port number is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that port shall be used.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00010)*

> 该SOME/IP请求消息的源地址应使用Manifest中通过参考（以unicastNetworkEndpoint角色）的EthernetCommunicationConnector映射到RequiredSomeipServiceInstance的Ipv4Configuration / Ipv6Configuration属性定义的单播IP地址。使用udpPort配置的端口号来派生发送的源端口号，如果选择的传输协议（参见[SWS_CM_10298]）是UDP。如果此端口号配置为0，则应使用*临时*端口。如果端口号被配置为除0以外的值，则必须使用该端口号。使用tcpPort配置的端口号来派生发送的源端口号，如果选择的传输协议（参见[SWS_CM_10298]）是TCP。如果此端口号配置为0，则应使用*临时*端口。如果端口号被配置为除0以外的值，则必须使用该端口号。（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00010）


**[SWS_CM_10300] Destination of a SOME/IP request message** *[*The SOME/IP request message shall use the unicast IP address and port taken from the IPv4/v6 Endpoint Option (see [PRS_SOMEIPSD_00307] and [PRS_SOMEIPSD_00315]) of the SOME/IP OfferService message ([[SWS_CM_00203](#_bookmark45)]) or the server address which has been statically pre-configured by the static service connection according to [SWS_CM_02201] as destination address and destination port for the transmission. In case multiple Endpoint Options have been contained in the SOME/IP OfferService message, the one matching the selected transport protocol (see [[SWS_CM_10298](#_bookmark71)]) shall be used.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007)*

> 该SOME/IP请求消息的目的地应使用从SOME/IP OfferService消息（参见[SWS_CM_00203]）中的IPv4/v6端点选项（参见[PRS_SOMEIPSD_00307]和[PRS_SOMEIPSD_00315]）提取的单播IP地址和端口，或者根据[SWS_CM_02201]静态配置的服务器地址作为传输的目的地址和目的端口。如果SOME/IP OfferService消息中包含多个端点选项，则应使用与所选传输协议（参见[SWS_CM_10298]）匹配的端点选项。（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007）


**[SWS_CM_10301] Content of the SOME/IP request message** *[*The entries in the SOME/IP request message shall be as follows:

> **[SWS_CM_10301] SOME / IP请求消息的内容** *[*SOME / IP请求消息中的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the methodDeployment.methodId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了methodDeployment.methodId。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效载荷的长度，以字节为单位增加8（SOME / IP标头的第二部分由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) shall be set to a value that uniquely identifies the client within a Machine. This may be achived by dynamically generating unique client IDs upon construction of the ServiceProxy.

> 客户端ID（参见[PRS_SOMEIP_00702]）应设置为一个在机器内唯一标识客户端的值。这可以通过在构建ServiceProxy时动态生成唯一的客户端ID来实现。

- The Session ID (see [PRS_SOMEIP_00703]) shall be set to 0x0001 for the first call of a particular method by a given client and shall be incremented by 1 after each call performed by this client for the respective method (see [PRS_SOMEIP_00533]). Once the Session ID reaches 0xFFFF, it shall wrap around and start with 0x0001 again (see [PRS_SOMEIP_00521]).

> 会话ID（参见[PRS_SOMEIP_00703]）在特定客户端对特定方法的第一次调用时应设置为0x0001，并且在此客户端对同一方法的每次调用后均应递增1（参见[PRS_SOMEIP_00533]）。一旦会话ID达到0xFFFF，它将重新从0x0001开始（参见[PRS_SOMEIP_00521]）。
- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceVersion.majorVersion。

- The Message Type (see [PRS_SOMEIP_00055]) shall be set to REQUEST_NO_RETURN (0x01) in case the ClientServerOperation referenced by methodDeployment.method contains a fireAndForget attribute which is set to true. The Message Type shall be set to REQUEST (0x00) otherwise.

> 消息类型（参见[PRS_SOMEIP_00055]）应根据methodDeployment.method引用的ClientServerOperation中的fireAndForget属性是否设置为true来设置为REQUEST_NO_RETURN（0x01）。否则，消息类型应设置为REQUEST（0x00）。

- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for request messages and thus (according to [PRS_SOMEIP_00920]) shall be set to E_OK (0x00).

> 返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对于请求消息不可用，因此（根据[PRS_SOMEIP_00920]）应设置为E_OK（0x00）。

- The Payload shall contain the serialized payload (i.e., the ArgumentDataPrototypes of the ClientServerOperation with direction set to in and inout serialized according to their order) according to the SOME/IP serialization rules.

> 负载应该包含序列化的负载（即，ClientServerOperation的ArgumentDataPrototypes，方向设置为in和inout，按照它们的顺序序列化），根据SOME/IP序列化规则。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_00003, RS_SOMEIP_00012, RS_SOMEIP_00021, RS_SOMEIP_00025, RS_SOMEIP_00041)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> *♩(RS_CM_00204、RS_CM_00200、RS_CM_00212、RS_CM_00213、RS_SOMEIP_00006、RS_SOMEIP_00007、RS_SOMEIP_00003、RS_SOMEIP_00012、RS_SOMEIP_00021、RS_SOMEIP_00025、RS_SOMEIP_00041)* SOME/IP 序列化规则在[7.5.1.9]（#serialization-of-payload）节中解释。


**[SWS_CM_10302] Checks for a received SOME/IP request message** *[*Upon reception of a SOME/IP request message the following checks shall be conducted:

> 收到SOME/IP请求消息时，应进行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.
- Verify that the Length (see [PRS_SOMEIP_00042]) is larger than 7.

- Use the Message Type (see [PRS_SOMEIP_00055]) which is set to either REQUEST_NO_RETURN (0x01) or REQUEST (0x00) to determine that the received SOME/IP message is actually a SOME/IP request message.

> 使用消息类型（参见[PRS_SOMEIP_00055]），该类型设置为REQUEST_NO_RETURN（0x01）或REQUEST（0x00），以确定接收到的SOME/IP消息实际上是SOME/IP请求消息。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches the methodId attribute of one of the SomeipMethodDeployments of the SomeipServiceInterfaceDeployment.

> 请验证方法ID（参见[PRS_SOMEIP_00245]）与SomeipServiceInterfaceDeployment的SomeipMethodDeployments的methodId属性是否匹配。

- Verify that the Message Type (see [PRS_SOMEIP_00055]) is set to REQUEST_NO_RETURN (0x01) in case the the ClientServerOperation referenced by methodDeployment.method of the SomeipMethodDeployment with matching methodId attribute contains a fireAndForget attribute which is set to true. Verify that the Message Type is set to REQUEST (0x00) otherwise.

> 请确认消息类型（参见[PRS_SOMEIP_00055]）在methodDeployment.method引用的ClientServerOperation中的fireAndForget属性设置为true时设置为REQUEST_NO_RETURN（0x01）。否则，请确认消息类型设置为REQUEST（0x00）。

- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 验证接口版本（参见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion匹配。

- Verify that the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is set to E_OK (0x00).

> 验证返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为E_OK（0x00）。


If any of the above checks fails the received SOME/IP request message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation). In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to either E_WRONG_PROTOCOL_VERSION, E_UNKNOWN_SERVICE, E_WRONG_INTERFACE_VERSION, E_UNKNOWN_METHOD, or E_WRONG_MESSAGE_TYPE (see [PRS_SOMEIP_00191]) shall be sent to the requester, depending on the detected error.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_00003, RS_SOMEIP_00019, RS_SOMEIP_00021, RS_SOMEIP_00008, RS_SOMEIP_00014)*

> 如果以上任何检查失败，则应丢弃收到的SOME / IP请求消息，并记录事件（如果为ara :: com实施启用了日志记录）。如果收到请求消息（参见[PRS_SOMEIP_00055]），另外，还将根据检测到的错误，将带有返回代码设置为E_WRONG_PROTOCOL_VERSION、E_UNKNOWN_SERVICE、E_WRONG_INTERFACE_VERSION、E_UNKNOWN_METHOD或E_WRONG_MESSAGE_TYPE（参见[PRS_SOMEIP_00191]）的错误消息发送给请求方（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007，RS_SOMEIP_00003，RS_SOMEIP_00019，RS_SOMEIP_00021，RS_SOMEIP_00008，RS_SOMEIP_00014）。


**[SWS_CM_10303] Identifying the right method** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_00245]) and the methodId attribute of the SomeipMethodDeployments of the SomeipServiceInterfaceDeployment, the right method shall be identified.*♩ (RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_00021)*

> 使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性，以及方法ID（参见[PRS_SOMEIP_00245]）和SomeipMethodDeployments的methodId属性，可以确定正确的方法。（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007，RS_SOMEIP_00021）


**[SWS_CM_10304] Deserializing the payload** *[*Based on the method determined according to [[SWS_CM_10303](#_bookmark75)] the Payload of the SOME/IP request message shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_-*

> **[SWS_CM_10304] 反序列化有效载荷** *[*根据[[SWS_CM_10303](#_bookmark75)]确定的方法，SOME/IP请求消息的有效载荷应根据SOME/IP序列化规则反序列化。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_-*)


*00028)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> *00028)* 章节[7.5.1.9](#serialization-of-payload)中解释了SOME/IP的序列化规则。


**[SWS_CM_10306] Invoke the method event driven** *[*In case a MethodCallProcessingMode of either kEvent or kEventSingleThread has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the deserialized payload containing the method data (i.e., method ID and input arguments) shall be used to invoke the service method (see [[SWS_CM_00191](#_bookmark537)]) identified according to [[SWS_CM_10303](#_bookmark75)] of the ServiceSkeleton class as a consequence to the reception of the SOME/IP request message.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007)*

> 如果在ServiceSkeleton的构造函数中传入了kEvent或kEventSingleThread类型的MethodCallProcessingMode（参见[[SWS_CM_00130](#_bookmark525)），则应使用反序列化的负载（即方法ID和输入参数）来调用服务方法（参见[[SWS_CM_00191](#_bookmark537)），该方法的标识由[[SWS_CM_10303](#_bookmark75) ]确定，作为收到SOME / IP请求消息的结果。♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007）


**[SWS_CM_10307] Invoke the method polling** *[*In case a MethodCallProcessingMode of kPoll has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the deserialized payload containing the method data (i.e., method ID and input arguments) shall be used to invoke the service method (see [[SWS_CM_00191](#_bookmark537)]) identified according to [[SWS_CM_10303](#_bookmark75)] of the ServiceSkeleton class upon a call to the ProcessNextMethodCall method (see [[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)]) of the ServiceSkeleton class.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007)*

> 如果kPoll的MethodCallProcessingMode已经传递给ServiceSkeleton的构造函数（参见[[SWS_CM_00130](#_bookmark525)），则应使用反序列化的有效负载（即方法ID和输入参数）来调用服务方法（参见[[SWS_CM_00191](#_bookmark537)），根据[[SWS_CM_10303](#_bookmark75)]确定ServiceSkeleton类，在调用ServiceSkeleton类的ProcessNextMethodCall方法（参见[[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)）时调用。♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007）


**[SWS_CM_10447]**{DRAFT} **Dealing with unmodelled ApApplicationErrors** *[*If the service method (see [[SWS_CM_00191](#_bookmark537)]) returnes an ApApplicationError different from the modeled ones (i.e., different from the ones referenced by the ClientServerOperation in role possibleApError or in role possibleApErrorSet.apApplicationError),treating this as a violation according to [SWS_CORE_00003]. No message shall be sent back to the client.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007)*

> **[SWS_CM_10447]**{草案} **处理未建模的ApApplicationErrors** *[*如果服务方法（参见[[SWS_CM_00191](#_bookmark537)）返回的ApApplicationError与建模的ApApplicationError（即在ClientServerOperation中role possibleApError或role possibleApErrorSet.apApplicationError中引用的错误）不同，则根据[SWS_CORE_00003]将其视为违规。不应向客户端发送任何消息。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007)*


**[SWS_CM_10308] Conditions for sending of a SOME/IP response message** *[*The sending of a SOME/IP response message shall be requested upon availability of a result of the ara::core::Future, which either contains a valid value or an ara::core::ErrorCode matching one of the possible ApApplicationErrors referenced by the ClientServerOperation in the role possibleApError or in role possibleApErrorSet.apApplicationError of the service method (see [[SWS_CM_10306](#_bookmark77)] and [[SWS_CM_10307](#_bookmark78)]) in case the Message Type of the corresponding SOME/IP request message was set to REQUEST (0x00).*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007)*

> 发送SOME/IP响应消息的条件是：当ara :: core :: Future提供了有效值或者一个与客户端服务操作中可能的ApApplicationErrors之一（参见[SWS_CM_10306]和[SWS_CM_10307]）匹配的ara :: core :: ErrorCode时，要求发送SOME/IP响应消息。如果相应的SOME/IP请求消息的消息类型被设置为REQUEST（0x00），则也应该发送SOME/IP响应消息（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007）。


**[SWS_CM_10309] Transport protocol for sending of a SOME/IP response message** *[*The SOME/IP response message shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.methodDeployment.transportProtocol in the Manifest.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00010)*

> **[SWS_CM_10309] 发送SOME/IP响应消息的传输协议** *[*SOME/IP响应消息应使用Manifest中SomeipServiceInterfaceDeployment.methodDeployment.transportProtocol属性定义的传输协议进行传输。*♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00010）*


**[SWS_CM_10310] Source of a SOME/IP response message** *[*The SOME/IP response message shall use the unicast IP address defined in the Manifest by the Ipv4Configuration/Ipv6Configuration attribute of the NetworkEndpoint that is referenced (in role unicastNetworkEndpoint) by the EthernetCommunicationConnector of a Machine which in turn is mapped to the ProvidedSomeipServiceInstance by means of a SomeipServiceInstanceToMachineMapping as source address for the transmission. The port number configured via udpPort shall be used to derive the source port for the transmission in case the selected transport protocol (see [[SWS_CM_10309](#_bookmark79)]) is UDP. If this port number is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that port shall be used. The port number configured via tcpPort shall be used to derive the source port for the transmission in case the selected transport protocol (see [[SWS_CM_10309](#_bookmark79)]) is TCP. If this port number is configured to 0, an *ephemeral* port shall be used. If the port number is configured to a value different from 0 exactly that port shall be used.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00010)*

> SOME/IP响应消息的源地址应使用清单中定义的单播IP地址，该IP地址由EthernetCommunicationConnector所引用的NetworkEndpoint的Ipv4Configuration/Ipv6Configuration属性定义，而EthernetCommunicationConnector又通过SomeipServiceInstanceToMachineMapping映射到提供的SomeipServiceInstance。如果所选传输协议（参见[[SWS_CM_10309](#_bookmark79)])是UDP，则应使用udpPort配置的端口号来派生传输的源端口号。如果该端口号配置为0，则应使用*临时*端口号。如果端口号配置为非0值，则应使用该非0值。如果所选传输协议（参见[[SWS_CM_10309](#_bookmark79)])是TCP，则应使用tcpPort配置的端口号来派生传输的源端口号。如果该端口号配置为0，则应使用*临时*端口号。如果端口号配置为非0值，则应使用该非0值。(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00010)


**[SWS_CM_10311] Destination of a SOME/IP response message** *[*The SOME/IP response message shall use the unicast source IP address and the source port of the corresponding received SOME/IP request message (see [[SWS_CM_10299](#_bookmark72)]) as destination address and destination port for the transmission.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007)*

> **[SWS_CM_10311] SOME/IP 响应消息的目标** *[*SOME/IP 响应消息应使用相应接收的 SOME/IP 请求消息的单播源 IP 地址和源端口作为传输的目标地址和目标端口（参见[[SWS_CM_10299](#_bookmark72)])。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007)*


**[SWS_CM_10312] Content of the SOME/IP response message** *[*The entries in the SOME/IP response message shall be as follows:

> **[SWS_CM_10312] SOME / IP响应消息的内容** *[*SOME / IP响应消息中的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceId。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the methodDeployment.methodId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest派生，其中SomeipServiceInterfaceDeployment元素定义了methodDeployment.methodId。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效负载的长度，以字节为单位增加8（SOME/IP头的第二部分，由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) shall be copied from the corresponding SOME/IP request message (see [[SWS_CM_10301](#_bookmark74)]).

> 客户端ID（参见[PRS_SOMEIP_00702]）应从相应的SOME/IP请求消息（参见[[SWS_CM_10301](#_bookmark74)]）中复制。

- The Session ID (see [PRS_SOMEIP_00703]) shall be copied from the corresponding SOME/IP request message (see [[SWS_CM_10301](#_bookmark74)]).

> 会话ID（参见[PRS_SOMEIP_00703]）应从相应的SOME / IP请求消息（参见[[SWS_CM_10301]（＃_bookmark74）]）中复制。
- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceVersion.majorVersion。

- The Message Type (see [PRS_SOMEIP_00055]) shall be set to ERROR (0x81) in case the ClientServerOperation returned one of the possible ApApplicationErrors referenced by the ClientServerOperation in role possibleApError or in role possibleApErrorSet.apApplicationError[^1^](#_bookmark84). The Message Type shall be set to RESPONSE (0x80) otherwise.

> 消息类型（参见[PRS_SOMEIP_00055]）应该在客户端服务操作返回其在possibleApError角色或possibleApErrorSet.apApplicationError角色中引用的可能的ApApplicationErrors之一时设置为错误（0x81）。否则，消息类型应设置为响应（0x80）。

- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) shall be set to E_NOT_OK (0x01) in case the ClientServerOperation raised one of the possible ApApplicationErrors referenced by the ClientServerOperation in role possibleApError or in role possibleApErrorSet.apApplicationError. The Return Code shall be set to E_OK (0x00) otherwise.

> 返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）应该设置为E_NOT_OK（0x01），如果ClientServerOperation引发了在possibleApError或possibleApErrorSet.apApplicationError角色中引用的可能的ApApplicationError之一。否则，返回码应设置为E_OK（0x00）。

- The Payload shall contain the serialized payload according to the SOME/IP serialization rules. In case of NO raised ApApplicationError, the ArgumentDataPrototypes of the ClientServerOperation with direction set to inout and out shall be serialized according to their order. -otherwise in case of a raised ApApplicationError, which is represented as an ara::core::ErrorCode contained in the ara::core::Result, the payload shall contain the serialized application error according to [[SWS_CM_10428](#_bookmark83)].

> 负载应根据SOME / IP序列化规则包含序列化的负载。如果没有引发ApApplicationError，具有方向设置为inout和out的ClientServerOperation的ArgumentDataPrototypes将按其顺序进行序列化。否则，如果引发了由ara :: core :: ErrorCode表示的ara :: core :: Result的ApApplicationError，则负载将根据[[SWS_CM_10428]（# _bookmark83）]包含序列化的应用程序错误。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00003, RS_SOMEIP_00012, RS_SOMEIP_00021, RS_SOMEIP_00025, RS_SOMEIP_00041, RS_SOMEIP_00008)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> *♩（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00003，RS_SOMEIP_00012，RS_SOMEIP_00021，RS_SOMEIP_00025，RS_SOMEIP_00041，RS_SOMEIP_00008）SOME / IP序列化规则在[7.5.1.9]（＃序列化有效负载）部分解释。


**[SWS_CM_10428] payload representing application error** *[*A raised application error shall be represented by a SOME/IP union: The type field of the union shall be set to 0x01. The element of the union with type field set to 0x01 shall be a SOME/IP struct with the following elements in depicted order:

> **[SWS_CM_10428] 表示应用程序错误的有效载荷** *[*应通过SOME/IP联合体表示抛出的应用程序错误：联合体的类型字段应设置为0x01。具有类型字段设置为0x01的联合体的元素应为具有以下元素的SOME/IP结构，按照所示顺序：


1Note that this is in fact an incompatibility with the AUTOSAR classic platform (i.e., in cases where an AUTOSAR adaptive platform server operates with an AUTOSAR classic platform client) which defines that a Message Type of RESPONSE (0x80) shall be used in case an ApApplicationError is raised. -Please consult the release notes of the AUTOSAR classic platform regarding details about this incompatibility issue and how to create a project specific work-around.

> 注意，这实际上是AUTOSAR经典平台的不兼容（即，在AUTOSAR自适应平台服务器与AUTOSAR经典平台客户端一起运行的情况下），其定义在出现ApApplicationError时使用响应消息类型（0x80）。-请参阅AUTOSAR经典平台的发布说明，了解有关此不兼容性问题以及如何创建项目特定的解决方案的详细信息。


- an uint64 representing the ApApplicationErrorDomain.value, to which the raised ApApplicationError belongs (ApApplicationError.errorDomain).

> 一个uint64表示触发的ApApplicationError所属的ApApplicationErrorDomain.value（ApApplicationError.errorDomain）。

- an int32 representing the ApApplicationError.errorCode, which is represented on binding level as ara::core::ErrorCode::Value().

> 一个int32表示ApApplicationError.errorCode，它在绑定层面上表示为ara::core::ErrorCode::Value()。


Additionally, following SOME/IP Transformation property values for the ApApplicationError are hard coded:

> 此外，下列SOME/IP转换属性值已经为ApApplicationError硬编码：

- sizeOfUnionLengthField/=32bit
- sizeOfUnionTypeSelectorField/=8bit
- sizeOfStructLengthField/=16bit
- sizeOfStringLengthField/=16bit
- byte-Order=network-byte-order(big endian)
- TLV for struct=no
- alignment=no
- String encoding=UTF-8
- String BOM=true
- String null-termination=true

*♩(RS_SOMEIP_00014)*


**[SWS_CM_10313] Checks for a received SOME/IP response message** *[*Upon reception of a SOME/IP response message the following checks shall be conducted:

> 收到SOME/IP响应消息后，应进行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.
- Verify that the Length (see [PRS_SOMEIP_00042]) is larger than 7.

- Use the Message Type (see [PRS_SOMEIP_00055]) which is set to either RESPONSE (0x80) or ERROR (0x81) to determine that the received SOME/IP message is actually a SOME/IP response message or error response message.

> 使用消息类型（参见[PRS_SOMEIP_00055]），该消息类型设置为RESPONSE（0x80）或ERROR（0x81），以确定接收到的SOME / IP消息实际上是SOME / IP响应消息或错误响应消息。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中的SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches the methodId attribute of one of the SomeipMethodDeployments of the SomeipServiceInterfaceDeployment.

> 确认方法ID（参见[PRS_SOMEIP_00245]）与SomeipServiceInterfaceDeployment的SomeipMethodDeployment的methodId属性相匹配。

- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 确认接口版本（参见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion匹配。

- Verify that the Client ID (see [PRS_SOMEIP_00702]) matches the client from the corresponding SOME/IP request message (see [[SWS_CM_10301](#_bookmark74)]).

> 验证客户端ID（参见[PRS_SOMEIP_00702]）与相应SOME/IP请求消息中的客户端（参见[[SWS_CM_10301](#_bookmark74)）匹配。

- The Session ID (see [PRS_SOMEIP_00703]) matches the client from the corresponding SOME/IP request message (see [[SWS_CM_10301](#_bookmark74)]).

> 会话 ID（参见[PRS_SOMEIP_00703]）与相应的SOME/IP请求消息中的客户端匹配（参见[[SWS_CM_10301](#_bookmark74)]）。


If any of the above checks fails the received SOME/IP response message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00003, RS_SOMEIP_00012, RS_SOMEIP_00019, RS_SOMEIP_00021, RS_SOMEIP_00025, RS_SOMEIP_00041, RS_SOMEIP_00008, RS_SOMEIP_00014)*

> 如果上述任何一项检查失败，收到的SOME/IP响应消息将被丢弃，并且（如果ara :: com实现启用了日志记录）将记录事件（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00003，RS_SOMEIP_00012，RS_SOMEIP_00019，RS_SOMEIP_00021，RS_SOMEIP_00025，RS_SOMEIP_00041，RS_SOMEIP_00008，RS_SOMEIP_00014）。


**[SWS_CM_10314] Identifying the right method** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_00245]) and the methodId attribute of the SomeipMethodDeployments of the SomeipServiceInterfaceDeployment, the right method shall be identified.*♩ (RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00006, RS_SOMEIP_00007, RS_SOMEIP_00021)*

> 使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性，以及方法ID（参见[PRS_SOMEIP_00245]）和SomeipMethodDeployments的methodId属性，可以确定正确的方法（参见[RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00006，RS_SOMEIP_00007，RS_SOMEIP_00021]）。


**[SWS_CM_10315] Discarding orphaned responses** *[*In case the method call has been canceled according to [[SWS_CM_00194](#_bookmark436)] in the mean time, the received response/error messages of the canceled methods shall be ignored.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*

> **[SWS_CM_10315] 丢弃孤立的响应** *[*如果根据[[SWS_CM_00194](#_bookmark436)]取消了方法调用，则应忽略已取消方法的收到的响应/错误消息。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*


**[SWS_CM_10357] Distinguishing errors from normal responses** *[*The Message Type (see [PRS_SOMEIP_00055]) and the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) of the SOME/IP message shall be used to determine whether the received SOME/IP message is a normal response (Message Type set to RESPONSE (0x80) **and** Return Code set to 0x0) or an error response (Message Type set to ERROR (0x81) **or** Return Code set to a value different from 0x0)[2](#_bookmark90) w.r.t. the further processing according to [[SWS_CM_10316](#_bookmark89)], [[SWS_CM_10358](#_bookmark91)], [[SWS_CM_10429](#_bookmark92)], [[SWS_CM_10430](#_bookmark93)] and [[SWS_CM_10317](#_bookmark94)].*♩(RS_CM_00204, RS_SOMEIP_00008)*

> [SWS_CM_10357] 区分错误和正常响应
消息类型（参见[PRS_SOMEIP_00055]）和返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）应使用SOME / IP消息来确定接收到的SOME / IP消息是正常响应（消息类型设置为RESPONSE（0x80）**和**返回码设置为0x0）还是错误响应（消息类型设置为ERROR（0x81）**或**返回码设置为与0x0不同的值）[2]（＃_bookmark90），关于根据[[SWS_CM_10316]（＃_bookmark89）]，[[SWS_CM_10358]（＃_bookmark91）]，[[SWS_CM_10429]（＃_bookmark92）]，[[SWS_CM_10430]（＃_bookmark93）]和[[SWS_CM_10317]（＃_bookmark94）]进行进一步处理的进一步处理。*♩（RS_CM_00204，RS_SOMEIP_00008）*


**[SWS_CM_10316] Deserializing the payload normal response messages** *[*Based on the method determined according to [[SWS_CM_10314](#_bookmark86)] the Payload of the response message shall be deserialized according to the SOME/IP serialization rules. -Therefore the ArgumentDataPrototypes with direction set to inout and out shall be deserialized according to their order.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00028)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> [SWS_CM_10316] 根据[[SWS_CM_10314](#_bookmark86)]确定的方法，应根据SOME/IP序列化规则反序列化响应消息的有效负载。因此，具有方向设置为inout和out的ArgumentDataPrototypes应按其顺序反序列化。♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00028)SOME/IP序列化规则在[7.5.1.9](#serialization-of-payload)节中有解释。


**[SWS_CM_10442] Failures during deserialization of response messages** *[*In case of failures during deserialization of response messages, the ara::com

> **[SWS_CM_10442] 响应消息反序列化期间的故障** *[*当发生响应消息反序列化期间的故障时，ara :: com


2The additional case of SOME/IP response messages with a Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) set to a value different from 0x0 is in place for the sake of compatibility with the AUTOSAR classic platform (i.e., AUTOSAR adaptive platform client and AUTOSAR classic platform server) which defines that a Message Type of RESPONSE (0x80) shall be used even in case ApApplicationErrors are raised.

> 针对兼容性（即AUTOSAR自适应平台客户端和AUTOSAR经典平台服务器）而设置的，SOME/IP响应消息的额外情况，其返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为一个与0x0不同的值。即使发生ApApplicationErrors，也应使用消息类型RESPONSE（0x80）。


implementation shall make the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) ready according to [[SWS_CM_10440](#_bookmark437)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00028)*

> 实现应根据[[SWS_CM_10440]](#_bookmark437)使用各自方法类的函数调用运算符（operator()）返回的未来准备就绪[[SWS_CM_00196]](#_bookmark586)。♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00028)


**[SWS_CM_10358] Identifying the right application error in a message with Message Type set to RESPONSE (0x80)** *[*If the Return Code see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) contains a value larger than 0x1F the corresponding value of the ApApplicationError.errorCode attribute shall be determined by subtracting 0x1F from the Return Code value. Using this computed ApApplicationError.errorCode attribute value and the ApApplicationError.errorCode attribute of all ApApplicationErrors referenced in role possibleApError by the ClientServerOperation corresponding to the method determined according to [[SWS_CM_10314](#_bookmark86)], the right application error shall be identified.

> 如果Return Code的值大于0x1F，则ApApplicationError.errorCode属性的相应值应通过从Return Code值中减去0x1F来确定。使用此计算出的ApApplicationError.errorCode属性值以及根据[SWS_CM_10314]确定的方法对应的ClientServerOperation所引用的所有ApApplicationErrors的ApApplicationError.errorCode属性，应该确定正确的应用程序错误。


If this computed ApApplicationError.errorCode attribute value does not match any of the ApApplicationError.errorCode attributes of all ApApplicationErrors referenced in role possibleApError or in role possibleApErrorSet. apApplicationError by the ClientServerOperation, the error response message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation), and the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) shall be made ready according to [[SWS_CM_10440](#_bookmark437)].

> 如果计算出的ApApplicationError.errorCode属性值不匹配role possibleApError或role possibleApErrorSet中引用的所有ApApplicationError的ApApplicationError.errorCode属性，则由ClientServerOperation引用的apApplicationError，则应丢弃错误响应消息，并记录事件（如果ara :: com实现启用了日志记录），并根据[[SWS_CM_10440]]（#_bookmark437）准备相应的方法类（参见[[SWS_CM_00196]]（#_bookmark586））的函数调用运算符（operator（））返回的未来。


If this computed ApApplicationError.errorCode attribute value does match more than one of the ApApplicationError.errorCode attributes of all ApApplicationErrors referenced in role possibleApError or in role possibleApErrorSet.apApplicationError by the ClientServerOperation, the error response message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation), and the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) shall be made ready according to [[SWS_CM_10440](#_bookmark437)].*♩(RS_CM_00204, RS_SOMEIP_00008)*

> 如果计算出的ApApplicationError.errorCode属性值与role possibleApError或role possibleApErrorSet.apApplicationError中引用的所有ApApplicationError的ApApplicationError.errorCode属性中的一个或多个匹配，则应丢弃错误响应消息，并（如果ara :: com实施启用了日志记录）记录该事件，并根据[[SWS_CM_10440]]（#_bookmark437）使相应方法类（参见[[SWS_CM_00196]]（#_bookmark586））的函数调用符（operator（））返回的Future就绪。*♩（RS_CM_00204，RS_SOMEIP_00008）*


Note: This is for backward compatibility to old servers using RESPONSE (0x80) even in case of application errors.

> 注意：即使在应用程序出错的情况下，为了向旧服务器兼容，也使用RESPONSE（0x80）。


**[SWS_CM_10429] Identifying the right application error in a message with Message Type set to ERROR (0x81)** *[*If the Return Code see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) contains a value equal to 0x01 (E_NOT_OK) then the corresponding ApApplicationError shall be identfied by deserializing the Payload of the message according to the error payload format described in [[SWS_CM_10428](#_bookmark83)].*♩ (RS_CM_00204, RS_SOMEIP_00008)*

> 如果返回码参考[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]的值等于0x01（E_NOT_OK），则可以通过反序列化消息的有效负载（根据[[SWS_CM_10428](#_bookmark83)]中描述的错误有效负载格式）来识别相应的ApApplicationError。（RS_CM_00204，RS_SOMEIP_00008）


**[SWS_CM_10430] Handling invalid messages with Message Type set to ERROR (0x81)** *[*If the Return Code see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) contains a value NOT equal to 0x01 or the value is equal to 0x01, but either the contained payload does NOT comply with [[SWS_CM_10428](#_bookmark83)] or the application error identified by the deserialized ApApplicationErrorDomain.value and ApApplicationError.errorCode is not referenced in role possibleApError or in role possibleApErrorSet.apApplicationError by the related ClientServerOperation, the error response message shall be discarded, the incident shall be logged (if logging is enabled for the ara::com implementation), and the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) shall be made ready according to [[SWS_CM_10440](#_bookmark437)].*♩(RS_CM_00204, RS_SOMEIP_00008)*

> 如果返回码参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]的值不等于0x01，或者值等于0x01，但是包含的有效负载不符合[[SWS_CM_10428](#_bookmark83)]，或者反序列化的ApApplicationErrorDomain.value和ApApplicationError.errorCode没有被相关的ClientServerOperation在可能的ApError或可能的ApErrorSet.apApplicationError中引用，那么错误响应消息将被丢弃，事件将被记录（如果ara :: com实现启用了日志记录），并且相应的Method类的函数调用运算符（operator()）返回的Future将按照[[SWS_CM_10440](#_bookmark437)]准备就绪。(RS_CM_00204，RS_SOMEIP_00008)


**[SWS_CM_10317] Making the Future ready** *[*In order to make the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) ready, depending on the type or received message (see [[SWS_CM_10357](#_bookmark88)]) either the set_value operation (see [SWS_CORE_00345] and [SWS_CORE_00346]) or the SetError (see [SWS_CORE_00353]) operation of the Promise corresponding to this Future shall be invoked. This will unblock any blocking get, wait, wait_for, and wait_until calls that have been performed on this Future. -The set_value operation shall be invoked in case of a received normal response message using the deserialized payload according to [[SWS_CM_10316](#_bookmark89)] as an argument. The SetError operation shall be invoked in case of a received error response message using the determined application error according to [[SWS_CM_10358](#_bookmark91)] and [[SWS_CM_10429](#_bookmark92)] of type ara::core::ErrorCode as an argument.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215, RS_SOMEIP_00007, RS_SOMEIP_00008)*

> 为了使Future（参见[[SWS_CM_00196](#_bookmark586)）由函数调用运算符（operator()）返回的未来准备好，根据接收的消息类型或消息（参见[[SWS_CM_10357](#_bookmark88)），要么调用Promise相应的set_value操作（参见[SWS_CORE_00345]和[SWS_CORE_00346]），要么调用SetError操作（参见[SWS_CORE_00353]）。这将解除对此Future执行的任何阻塞get，wait，wait_for和wait_until调用。 -如果收到正常响应消息，则应使用根据[[SWS_CM_10316](#_bookmark89)]反序列化的有效负载作为参数调用set_value操作。如果收到错误响应消息，则应使用根据[[SWS_CM_10358](#_bookmark91)]和[[SWS_CM_10429](#_bookmark92)]确定的应用程序错误作为类型ara :: core :: ErrorCode的参数调用SetError操作。♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00215，RS_SOMEIP_00007，RS_SOMEIP_00008）


**[SWS_CM_10318] Invoke the notification function** *[*If a notification function has been registered with the Future's then method (see [[SWS_CM_00197](#_bookmark438)]), this notification function shall be invoked.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215, RS_SOMEIP_00007)*

> **[SWS_CM_10318]调用通知功能** *[*如果使用Future的then方法注册了通知功能（请参见[[SWS_CM_00197](#_bookmark438)]），则应调用该通知功能。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215, RS_SOMEIP_00007)*

### Handling Fields


**[SWS_CM_10319] Conditions for sending of a SOME/IP event message** *[*The sending of a SOME/IP event message shall be requested by invoking the Update method of the respective Field class (see [[SWS_CM_00119](#_bookmark548)]) or if the Future returned by the SetHandler registered with RegisterSetHandler (see [[SWS_CM_00116](#_bookmark546)]) becomes ready if there is static service connection according to [SWS_CM_02201] or if there is at least one active subscriber and the offer of the service containing the event has not been stopped (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called). An active subscriber is an adaptive application that has invoked the Subscribe method of the respective Field class (see [[SWS_CM_00120](#_bookmark440)]) and has not canceled the subscription by invoking the Unsubscribe method of the respective Field class (see [[SWS_CM_00120](#_bookmark440)]) and where the subscription has not yet expired since the TTL contained in the SOME/IP SubscribeEventgroup message (see [[SWS_CM_00205](#_bookmark47)]) has been exceeded.*♩(RS_CM_00204, RS_CM_00201, RS_-SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00005, RS_SOMEIP_00017, RS_SOMEIP_00018)*

> 发送SOME/IP事件消息的条件应通过调用各自字段类的Update方法（参见SWS_CM_00119）来请求，或者如果使用RegisterSetHandler注册的SetHandler返回的Future准备就绪（参见SWS_CM_00116），如果根据SWS_CM_02201有静态服务连接，或者如果至少有一个活动订阅者，并且包含事件的服务没有停止（要么是因为SOME/IP OfferService消息（参见SWS_CM_00203）中包含的TTL已过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见SWS_CM_00111）已被调用）。活动订阅者是调用相应字段类的Subscribe方法（参见SWS_CM_00120）并且没有通过调用相应字段类的Unsubscribe方法（参见SWS_CM_00120）取消订阅，并且订阅尚未到期（即SOME/IP SubscribeEventgroup消息（参见SWS_CM_00205）中包含的TTL未超过）的自适应应用程序。


**[SWS_CM_10320] Transport protocol for sending of a SOME/IP event message** *[*The SOME/IP event message shall be transmitted using UDP if the threshold defined by the multicastThreshold attribute of the SomeipProvidedEventGroup that is aggregated by the ProvidedSomeipServiceInstance in the role eventGroup in the Manifest has been reached (see [PRS_SOMEIPSD_00134]). The SOME/IP event message shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.fieldDeployment.notifier. transportProtocol in the Manifest if this threshold has not been reached (see [PRS_SOMEIPSD_00802]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00010)*

> **[SWS_CM_10320] 发送SOME/IP事件消息的传输协议** *[*如果在Manifest中聚合的SomeipProvidedEventGroup的multicastThreshold属性定义的阈值达到（参见[PRS_SOMEIPSD_00134]），则SOME/IP事件消息应使用UDP传输。 如果未达到此阈值，则SOME/IP事件消息应使用Manifest中SomeipServiceInterfaceDeployment.fieldDeployment.notifier. transportProtocol属性定义的传输协议传输（参见[PRS_SOMEIPSD_00802]）。*♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00009，RS_SOMEIP_00010）*


**[SWS_CM_10321] Source of a SOME/IP event message** *[*The source address and the source port of the SOME/IP event message shall set according to [[SWS_CM_10289](#_bookmark58)].*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042)*

> **[SWS_CM_10321] SOME/IP 事件消息的来源** *[*SOME/IP 事件消息的源地址和源端口应根据[[SWS_CM_10289](#_bookmark58)]设置。*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042)*


**[SWS_CM_10322] Destination of a SOME/IP event message** *[*The destination address and the destination port of the SOME/IP event message shall be set according to [[SWS_CM_10290](#_bookmark59)].*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042)*

> **[SWS_CM_10322] 用于SOME/IP事件消息的目的地** *[*根据[[SWS_CM_10290](#_bookmark59)]设置SOME/IP事件消息的目的地地址和目的端口。*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00042)*


**[SWS_CM_10323] Content of the SOME/IP event message** *[*The entries in the SOME/IP event message shall be as follows:

> **[SWS_CM_10323] SOME/IP事件消息的内容** *[*SOME/IP事件消息的条目应如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the eventDeployment.eventId by adding 0x8000 to the eventDeployment. eventId.

> 方法ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素通过将0x8000与eventDeployment.eventId相加来定义eventDeployment.eventId。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效负载的长度，以字节为单位增加8（SOME/IP标头的第二部分，由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) is unused for event messages (according to [PRS_SOMEIP_00702]) and thus shall be set to 0x0000.

> 客户端ID（参见[PRS_SOMEIP_00702]）对于事件消息（根据[PRS_SOMEIP_00702]）未使用，因此应设置为0x0000。

- In case of inactive Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID (see [PRS_SOMEIP_00703]) is unused for event messages and thus shall be set to 0x0000 (see [PRS_SOMEIP_00932]) and [PRS_SOMEIP_00925]).

> 如果是不活跃的会话处理，请参见[[SWS_CM_10240](#_bookmark40)]，会话ID（参见[PRS_SOMEIP_00703]）对于事件消息不使用，因此应设置为0x0000（参见[PRS_SOMEIP_00932]和[PRS_SOMEIP_00925]）。


In case of active Session Handling, see [[SWS_CM_10240](#_bookmark40)], the Session ID is used for event messages and thus shall be incremented (with proper wrap around) upon every transmission of an event message (see [PRS_SOMEIP_-00933], [PRS_SOMEIP_00934], [PRS_SOMEIP_00521], and [PRS_SOMEIP_-00925]).

> 在活动会话处理的情况下，参见[[SWS_CM_10240](#_bookmark40)]，会话ID用于事件消息，因此在每次发送事件消息时（参见[PRS_SOMEIP_-00933]，[PRS_SOMEIP_00934]，[PRS_SOMEIP_00521]和[PRS_SOMEIP_-00925]）应该增加（适当地绕回）。


The information whether the Session Handling is activated or deactivated for an event can be derived from the sessionHandling attribute contained in the ApSomeipTransformationProps that is referenced by the TransformationPropsToServiceInterfaceElementMapping that in turn points to the event.

> 可以从指向该事件的TransformationPropsToServiceInterfaceElementMapping中引用的ApSomeipTransformationProps中的sessionHandling属性中推断出为该事件所激活或停用的会话处理信息。

- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从清单中派生，其中SomeipServiceInterfaceDeployment元素定义了serviceInterfaceVersion.majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to NOTIFICATION (0x02).


- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for event messages and thus (according to [PRS_SOMEIP_00925]) shall be set to E_OK (0x00).

> 返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对于事件消息没有使用，因此（根据[PRS_SOMEIP_00925]）应设置为E_OK（0x00）。

- The Payload shall contain the serialized payload (i.e., the serialized Field composed by the ServiceInterface in role field) according to the SOME/IP serialization rules.

> 负载必须包含序列化的负载（即由ServiceInterface在角色字段组成的序列化字段），并根据SOME / IP序列化规则进行序列化。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00041, RS_SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00009)*

> *♩(RS_CM_00204，RS_CM_00200，RS_CM_00201，RS_SOMEIP_00041，RS_SOMEIP_00022，RS_SOMEIP_00003，RS_SOMEIP_00004，RS_SOMEIP_00009)*


The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> 解释SOME/IP序列化规则的部分在[7.5.1.9](#serialization-of-payload)中。


**[SWS_CM_10324] Checks for a received SOME/IP event message** *[*Upon reception of a SOME/IP event message the checks defined in [[SWS_CM_10292](#_bookmark61)] shall be conducted. If any of the above checks fails the received SOME/IP event message shall be discarded and and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00019, RS_-*

> 收到SOME/IP事件信息时，应执行[[SWS_CM_10292](#_bookmark61)]中定义的检查。如果以上任何检查失败，则应丢弃已收到的SOME/IP事件信息，并且（如果为ara :: com实现启用了日志记录）记录事件。


*SOMEIP_00022, RS_SOMEIP_00003, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00014)*

> *SOMEIP_00022、RS_SOMEIP_00003、RS_SOMEIP_00004、RS_SOMEIP_00009、RS_SOMEIP_00014*


**[SWS_CM_10325] Identifying the right event** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_00245]) and 0x8000 + the eventId attribute of the SomeipFieldDeployment.notifiers of the SomeipServiceInterfaceDeployment, the right event shall be identified.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00022)*

> **[SWS_CM_10325] 确定正确的事件** *[*使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性以及方法ID（参见[PRS_SOMEIP_00245]）和0x8000 + SomeipFieldDeployment.notifiers的eventId属性，可以确定正确的事件。*♩(RS_CM_00204, RS_CM_00200, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00022)*


**[SWS_CM_10380] Silently discarding SOME/IP event messages for unsubscribed events** *[*If the event identified according to [[SWS_CM_10325](#_bookmark103)] does not have an active subscription because the Subscribe method (see [[SWS_CM_00141](#_bookmark559)]) of the specific Field class of the ServiceProxy class has not been called, or the Unsubscribe method (see [[SWS_CM_00151](#_bookmark560)]) of the specific Field class of the ServiceProxy class has been called, or the TTL of the SOME/IP SubscribeEventgroup message

> **[SWS_CM_10380] 如果按照[[SWS_CM_10325](#_bookmark103)]确定的事件没有活动订阅，因为特定字段类的ServiceProxy类的Subscribe方法（参见[[SWS_CM_00141](#_bookmark559)）未被调用，或者特定字段类的ServiceProxy类的Unsubscribe方法（参见[[SWS_CM_00151](#_bookmark560)）已被调用，或者SOME/IP SubscribeEventgroup消息的TTL已过期，则会静默丢弃SOME/IP事件消息**


(see [[SWS_CM_00205](#_bookmark47)]) has expired, the received SOME/IP event message shall be silently discarded (i.e., [[SWS_CM_10326](#_bookmark106)], [[SWS_CM_10327](#_bookmark107)], and [[SWS_CM_10328](#_bookmark105)] shall *not* be performed).*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_SOMEIP_00009)*

> 如果[[SWS_CM_00205](#_bookmark47)]已过期，则收到的SOME/IP事件消息将被静默丢弃（即，不执行[[SWS_CM_10326](#_bookmark106)], [[SWS_CM_10327](#_bookmark107)], 和[[SWS_CM_10328](#_bookmark105)]）。♩（RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_SOMEIP_00009）


**[SWS_CM_10328] Invoke receive handler** *[*In case a ReceiveHandler was registered using the SetReceiveHandler method (see [[SWS_CM_00181](#_bookmark573)]) of the respective Field class for the event determined according to [[SWS_CM_10325](#_bookmark103)] this registered receive handler shall be invoked.*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_SOMEIP_00009)*

> **[SWS_CM_10328] 调用接收处理程序** *[*如果使用相应的Field类的SetReceiveHandler方法（参见[[SWS_CM_00181](#_bookmark573)）注册了ReceiveHandler，根据[[SWS_CM_10325](#_bookmark103)]确定的事件，则应调用注册的接收处理程序。*♩(RS_CM_00204, RS_CM_00203, RS_SOMEIP_00004, RS_SOMEIP_00009)*


**[SWS_CM_10326] Deserializing the payload** *[*Based on the event determined according to [[SWS_CM_10325](#_bookmark103)] the Payload of the SOME/IP event message (i.e., the serialized Field composed by the ServiceInterface in role field) shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00009, RS_SOMEIP_00028)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> [SWS_CM_10326] 反序列化有效载荷*[*根据[[SWS_CM_10325](#_bookmark103)]确定的事件，SOME / IP事件消息的有效载荷（即由服务接口组成的角色字段组成的序列化字段）应根据SOME / IP序列化规则进行反序列化。*♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00009，RS_SOMEIP_00028）* SOME / IP序列化规则在[7.5.1.9]（#serialization-of-payload）节中有解释。


**[SWS_CM_10327] Providing the received event data** *[*The deserialized payload containing the event data shall be provided via the GetNewSamples (see [[SWS_CM_00701](#_bookmark570)]) method of the respective Field class for the event determined according to [[SWS_CM_10325](#_bookmark103)].*♩(RS_CM_00204, RS_CM_00202, RS_SOMEIP_00004, RS_SOMEIP_00009)*

> **[SWS_CM_10327] 提供接收到的事件数据** *[*反序列化的包含事件数据的有效负载应该通过相应的Field类的GetNewSamples（参见[[SWS_CM_00701](#_bookmark570)）方法，根据[[SWS_CM_10325](#_bookmark103)]确定的事件提供。*♩（RS_CM_00204，RS_CM_00202，RS_SOMEIP_00004，RS_SOMEIP_00009）*


**[SWS_CM_10329] Conditions for sending of a SOME/IP request message** *[*The sending of a SOME/IP request message shall be requested by invoking the Set or Get method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)] and [[SWS_CM_00113](#_bookmark591)]) if the providing service instance has not stopped offering the service (either because the TTL contained in the SOME/IP OfferService message (see [[SWS_CM_00203](#_bookmark45)]) has expired or because the StopOfferService method (see [[SWS_CM_00111](#_bookmark523)]) of the ServiceSkeleton class has been called).*♩(RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> 发送SOME/IP请求消息的条件：如果提供服务实例没有停止提供服务（要么是因为SOME/IP OfferService消息（参见[[SWS_CM_00203](#_bookmark45)）中包含的TTL已过期，要么是因为ServiceSkeleton类的StopOfferService方法（参见[[SWS_CM_00111](#_bookmark523)）已被调用），则可以通过调用相应的Field类的Set或Get方法（参见[[SWS_CM_00112](#_bookmark588)]和[[SWS_CM_00113](#_bookmark591)）来请求发送SOME/IP请求消息。（参见RS_CM_00212，RS_CM_00213，RS_CM_00217，RS_CM_00218，RS_SOMEIP_00007，RS_SOMEIP_00009）


**[SWS_CM_10443] Failures in sending of a SOME/IP request message** *[*If the sending of the SOME/IP request message fails locally (in a way which is notified to the ara::com implementation), the ara::com implementation shall make the Future returned by the Set or Get method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)] and [[SWS_CM_00113](#_bookmark591)]) ready according to [[SWS_CM_10440](#_bookmark437)].*♩ (RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> 如果SOME / IP请求消息的发送在本地失败（以ara :: com实施通知的方式），那么ara :: com实施将根据[[SWS_CM_10440]]（#_bookmark437）使相应字段类的Set或Get方法返回的未来准备就绪。（RS_CM_00212，RS_CM_00213，RS_CM_00217，RS_CM_00218，RS_SOMEIP_00007，RS_SOMEIP_00009）


**[SWS_CM_10330] Transport protocol for sending of a SOME/IP request message** *[*The SOME/IP request message for the Set method shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment. fieldDeployment.set.transportProtocol in the Manifest. The SOME/IP request message for the Get method shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.fieldDeployment. get.transportProtocol respectively.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00010)*

> **[SWS_CM_10330] 发送SOME/IP请求消息的传输协议** *[*Set方法的SOME/IP请求消息应使用由Manifest中的SomeipServiceInterfaceDeployment.fieldDeployment.set.transportProtocol属性定义的传输协议进行传输。 Get方法的SOME/IP请求消息应使用由SomeipServiceInterfaceDeployment.fieldDeployment.get.transportProtocol属性定义的传输协议进行传输。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00010)*


**[SWS_CM_10331] Source of a SOME/IP request message** *[*The source address and the source port of the SOME/IP request message shall be set according to [[SWS_CM_10299](#_bookmark72)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00010)*

> [SWS_CM_10331] SOME/IP 请求消息的源地址和源端口应根据[[SWS_CM_10299](#_bookmark72)]设置。♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_00010）


**[SWS_CM_10332] Destination of a SOME/IP request message** *[*The destination address and the destination port of the SOME/IP request message shall be set according to [[SWS_CM_10300](#_bookmark73)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> **[SWS_CM_10332] SOME/IP 请求消息的目标** *[*SOME/IP 请求消息的目标地址和目标端口应根据[[SWS_CM_10300](#_bookmark73)]设置。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009)*


**[SWS_CM_10333] Content of the SOME/IP request message** *[*The entries in the SOME/IP request message shall be as follows:

> **[SWS_CM_10333] SOME/IP请求消息的内容** *[*SOME/IP请求消息中的条目应如下所示：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) for the Set method shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the fieldDeployment.set.methodId. The Method ID for the Get method shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the fieldDeployment.get.methodId.

> 方法ID（参见[PRS_SOMEIP_00245]）用于设置方法应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了fieldDeployment.set.methodId。用于获取方法的方法ID应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了fieldDeployment.get.methodId。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效负载的长度，单位为字节，加上8（SOME/IP头的第二部分，由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) shall be set to a value that uniquely identifies the client within a Machine. -This may be achieved by dynamically generating unique client IDs upon construction of the ServiceProxy.

> 客户端ID（参见[PRS_SOMEIP_00702]）应设置为在机器内唯一标识客户端的值。-这可以通过在构造ServiceProxy时动态生成唯一的客户端ID来实现。

- The Session ID (see [PRS_SOMEIP_00703]) shall be set to 0x0001 for the first call of the particular method by a given client and shall be incremented by 1 after each call performed by this client for the respective method (see [PRS_SOMEIP_00533]). Once the Session ID reaches 0xFFFF, it shall wrap around and start with 0x0001 again (see [PRS_SOMEIP_00521]).

> 会话ID（参见[PRS_SOMEIP_00703]）应为特定客户端对特定方法的首次调用设置为0x0001，并在该客户端对相应方法的每次调用后递增1（参见[PRS_SOMEIP_00533]）。一旦会话ID达到0xFFFF，它将重新开始并从0x0001开始（参见[PRS_SOMEIP_00521]）。
- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 界面版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口版本的majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to REQUEST (0x00).

- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is unused for request messages and thus (according to [PRS_SOMEIP_00920]) shall be set to E_OK (0x00).

> 返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）对于请求消息未使用，因此（根据[PRS_SOMEIP_00920]）应设置为E_OK（0x00）。

- The Payload for the request message for the Set method shall contain the serialized payload (i.e., the serialized Field composed by the ServiceInterface in role field) according to the SOME/IP serialization rules. The Payload for the request message for the Get method will be empty.

> 请求消息的有效负载（Payload）对于Set方法应按照SOME/IP序列化规则包含序列化的有效负载（即由服务接口在角色字段中组成的字段的序列化）。Get方法的请求消息的有效负载（Payload）为空。


*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_CM_00217, RS_CM_00218, RS_SOMEIP_00003, RS_SOMEIP_00012, RS_SOMEIP_00021, RS_SOMEIP_00025, RS_SOMEIP_-00041)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> *♩(RS_CM_00204、RS_CM_00200、RS_CM_00212、RS_CM_00213、RS_SOMEIP_00007、RS_SOMEIP_00009、RS_CM_00217、RS_CM_00218、RS_SOMEIP_00003、RS_SOMEIP_00012、RS_SOMEIP_00021、RS_SOMEIP_00025、RS_SOMEIP_-00041)*SOME/IP的序列化规则在[7.5.1.9]（#序列化有效负载）节中有解释。


**[SWS_CM_10334] Checks for a received SOME/IP request message** *[*Upon reception of a SOME/IP request message the following checks shall be conducted:

> 收到SOME/IP请求消息后，应进行以下检查：

- Verify that the Protocol Version (see [PRS_SOMEIP_00052]) is set to 0x01.
- Verify that the Length (see [PRS_SOMEIP_00042]) is larger than 7.

- Use the Message Type (see [PRS_SOMEIP_00055]) which is set to REQUEST (0x00) to determine that the received SOME/IP message is actually a SOME/IP request message.

> 使用设置为请求（0x00）的消息类型（参见[PRS_SOMEIP_00055]）来确定接收到的SOME/IP消息实际上是一条SOME/IP请求消息。

- Use the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element in the Manifest to determine the right ServiceInterface.

> 使用服务ID（参见[PRS_SOMEIP_00245]）和Manifest中的SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性来确定正确的服务接口。

- Verify that the Method ID (see [PRS_SOMEIP_00245]) matches the methodId attribute of one of the SomeipMethodDeployments of the SomeipServiceInterfaceDeployment.

> 验证方法ID（参见[PRS_SOMEIP_00245]）与SomeipServiceInterfaceDeployment的SomeipMethodDeployment的methodId属性是否匹配。
- Verify that the Message Type (see [PRS_SOMEIP_00055]) is set to REQUEST(0x00).


- Verify that the Interface Version (see [PRS_SOMEIP_00053]) matches SomeipServiceInterfaceDeployment.serviceInterfaceVersion. majorVersion.

> 验证接口版本（参见[PRS_SOMEIP_00053]）与SomeipServiceInterfaceDeployment.serviceInterfaceVersion.majorVersion匹配。

- Verify that the Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) is set to E_OK (0x00).

> 验证返回码（参见[PRS_SOMEIP_00058]和[PRS_SOMEIP_00191]）设置为E_OK（0x00）。


If any of the above checks fails the received SOME/IP request message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation). In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to either E_WRONG_PROTOCOL_VERSION, E_UNKNOWN_SERVICE, E_WRONG_INTERFACE_VERSION, E_UNKNOWN_METHOD, or E_WRONG_MESSAGE_TYPE (see [PRS_SOMEIP_00191]) shall be sent to the requester, depending on the detected error.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_-SOMEIP_00003, RS_SOMEIP_00019, RS_SOMEIP_00021, RS_SOMEIP_00008, RS_SOMEIP_00014)*

> 如果上述检查有任何一项失败，接收到的SOME/IP请求消息将被丢弃，并且（如果ara::com实现启用了日志记录）将记录下此事件。对于接收到的请求消息（参见[PRS_SOMEIP_00055]），另外，根据检测到的错误，还将向请求者发送一条带有返回码设置为E_WRONG_PROTOCOL_VERSION、E_UNKNOWN_SERVICE、E_WRONG_INTERFACE_VERSION、E_UNKNOWN_METHOD或E_WRONG_MESSAGE_TYPE（参见[PRS_SOMEIP_00191]）的错误消息。（RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_-SOMEIP_00003, RS_SOMEIP_00019, RS_SOMEIP_00021, RS_SOMEIP_00008, RS_SOMEIP_00014）


**[SWS_CM_10335] Identifying the right method** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_-00245]) and the methodId attribute of the SomeipFieldDeployment.sets and SomeipFieldDeployment.gets of the SomeipServiceInterfaceDeployment, the right method shall be identified.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00021)*

> 使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性以及方法ID（参见[PRS_SOMEIP_-00245]）和SomeipFieldDeployment.sets和SomeipFieldDeployment.gets的methodId属性，可以确定正确的方法。（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_CM_00217，RS_CM_00218，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_00021）


**[SWS_CM_10336] Deserializing the payload** *[*Based on the method determined according to [[SWS_CM_10335](#_bookmark115)] the Payload of the SOME/IP request message shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_-00028)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> 根据[[SWS_CM_10335](#_bookmark115)]确定的方法，按照SOME/IP序列化规则，应该对SOME/IP请求消息的有效负载进行反序列化。(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_-00028)有关SOME/IP序列化规则的说明，请参阅[7.5.1.9](#serialization-of-payload)节。


**[SWS_CM_10338] Invoke the registered set/get handlers event driven** *[*In case a MethodCallProcessingMode of either kEvent or kEventSingleThread has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the deserialized payload containing the method data (i.e., method ID and input arguments) shall be used to invoke a registered SetHandler resp. GetHandler (see [[SWS_CM_00114](#_bookmark543)] and [[SWS_CM_00116](#_bookmark546)]) of the Field class as a consequence to the reception of the SOME/IP request message.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> 如果将kEvent或kEventSingleThread传递给ServiceSkeleton的构造函数（参见[[SWS_CM_00130]（# _bookmark525）），则应使用反序列化的包含方法数据（即方法ID和输入参数）的有效负载来调用Field类的已注册的SetHandler resp. GetHandler（参见[[SWS_CM_00114]（# _bookmark543）]和[[SWS_CM_00116]（# _bookmark546）]）作为接收SOME/IP请求消息的结果。♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00220，RS_CM_00221，RS_SOMEIP_00007，RS_SOMEIP_00009）


**[SWS_CM_10339] Invoke the registered set/get handlers polling** *[*In case a MethodCallProcessingMode of kPoll has been passed to the constructor of the ServiceSkeleton (see [[SWS_CM_00130](#_bookmark525)]), the deserialized payload containing the method data (i.e., method ID and input arguments) shall be used to invoke a registered SetHandler resp. GetHandler (see [[SWS_CM_00114](#_bookmark543)] and [[SWS_CM_00116](#_bookmark546)]) of the Field class upon a call to the ProcessNextMethodCall method (see [[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)]) of the ServiceSkeleton class.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> 如果将kPoll作为构造函数ServiceSkeleton的MethodCallProcessingMode传递（参见[[SWS_CM_00130]（#_bookmark525）），则应使用反序列化的有效负载（即方法ID和输入参数）来调用Field类的注册SetHandler/GetHandler（参见[[SWS_CM_00114]（#_bookmark543）]和[[SWS_CM_00116]（#_bookmark546）]），在调用ServiceSkeleton类的ProcessNextMethodCall方法（参见[[SWS_CM_00199]（#sws_cm_00199-process-service-method-invocation）]）时。（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00220，RS_CM_00221，RS_SOMEIP_00007，RS_SOMEIP_00009）


**[SWS_CM_10340] Conditions for sending of a SOME/IP response message** *[*The sending of a SOME/IP response message shall be requested upon the return of a registered SetHandler resp. GetHandler (see [[SWS_CM_00114](#_bookmark543)] and [[SWS_CM_00116](#_bookmark546)]).*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> **[SWS_CM_10340] 发送SOME/IP响应消息的条件** *[*当注册的SetHandler或GetHandler返回时，应请求发送SOME/IP响应消息（参见[[SWS_CM_00114](#_bookmark543)]和[[SWS_CM_00116](#_bookmark546)]）。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00220, RS_CM_00221, RS_SOMEIP_00007, RS_SOMEIP_00009)*


**[SWS_CM_10341] Transport protocol for sending of a SOME/IP response message** *[*The SOME/IP response message for the Set method shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.fieldDeployment.set.transportProtocol in the Manifest. The SOME/IP response message for the Get method shall be transmitted using the transport protocol defined by the attribute SomeipServiceInterfaceDeployment.fieldDeployment.get.transportProtocol respectively.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00010)*

> [SWS_CM_10341] 设置和获取SOME/IP响应消息的传输协议
SOME/IP响应消息的传输协议由Manifest中的SomeipServiceInterfaceDeployment.fieldDeployment.set.transportProtocol和SomeipServiceInterfaceDeployment.fieldDeployment.get.transportProtocol属性定义。


**[SWS_CM_10342] Source of a SOME/IP response message** *[*The source address and the source port of the SOME/IP response message shall be set according to [[SWS_CM_10310](#_bookmark80)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00010)*

> **[SWS_CM_10342] SOME/IP 响应消息的源地址** *[*SOME/IP 响应消息的源地址和源端口应根据[[SWS_CM_10310](#_bookmark80)]设置。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00010)*


**[SWS_CM_10343] Destination of a SOME/IP response message** *[*The destination address and the destination port of the SOME/IP response message shall be set according to [[SWS_CM_10311](#_bookmark81)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> **[SWS_CM_10343] SOME/IP 响应消息的目的地** *[*SOME/IP 响应消息的目的地地址和目的地端口应根据[[SWS_CM_10311](#_bookmark81)]设置。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009)*


**[SWS_CM_10344] Content of the SOME/IP response message** *[*The entries in the SOME/IP response message shall be as follows:

> **[SWS_CM_10344] SOME/IP 响应消息的内容** *[*SOME/IP 响应消息中的条目如下：


- The Service ID (see [PRS_SOMEIP_00245]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceId.

> 服务ID（参见[PRS_SOMEIP_00245]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了服务接口ID。

- The Method ID (see [PRS_SOMEIP_00245]) for the Set method shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the fieldDeployment.set.methodId. The Method ID for the Get method shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the fieldDeployment.get.methodId.

> 方法ID（参见[PRS_SOMEIP_00245]）用于Set方法应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了fieldDeployment.set.methodId。用于Get方法的方法ID应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义了fieldDeployment.get.methodId。

- The Length (see [PRS_SOMEIP_00042]) shall be set to the length of the serialized payload in units of bytes incremented by 8 (second part of the SOME/IP header that is covered by the Length)

> 长度（参见[PRS_SOMEIP_00042]）应设置为序列化有效载荷的长度，以字节为单位增加8（SOME / IP头的第二部分由长度覆盖）。

- The Client ID (see [PRS_SOMEIP_00702]) shall be copied from the corresponding SOME/IP request message (see [[SWS_CM_10301](#_bookmark74)]).

> 客户端ID（参见[PRS_SOMEIP_00702]）应从相应的SOME/IP请求消息（参见[[SWS_CM_10301](#_bookmark74)]）中复制。

- The Session ID (see [PRS_SOMEIP_00703]) shall be copied from the corresponding SOME/IP request message (see [[SWS_CM_10301](#_bookmark74)]).

> 会话ID（参见[PRS_SOMEIP_00703]）应从相应的SOME/IP请求消息（参见[[SWS_CM_10301](#_bookmark74)]）中复制。
- The Protocol Version (see [PRS_SOMEIP_00052]) shall be set to 0x01.

- The Interface Version (see [PRS_SOMEIP_00053]) shall be derived from the Manifest where the SomeipServiceInterfaceDeployment element defines the serviceInterfaceVersion.majorVersion.

> 接口版本（参见[PRS_SOMEIP_00053]）应从Manifest中派生，其中SomeipServiceInterfaceDeployment元素定义服务接口版本的majorVersion。
- The Message Type (see [PRS_SOMEIP_00055]) shall be set to RESPONSE

(0x80).

- The Return Code (see [PRS_SOMEIP_00058] and [PRS_SOMEIP_00191]) shall be set to E_OK (0x00).

- The Payload shall contain the serialized payload (i.e., the serialized Field composed by the ServiceInterface in role field) which has either been provided by the value of the Future returned by the registered SetHandler resp. GetHandler or obtained internally) according to the SOME/IP serialization rules.

> 负载应包含序列化的负载（即由ServiceInterface在角色字段中组成的字段），该负载已通过由注册的SetHandler或GetHandler返回的Future的值提供，或根据SOME/IP序列化规则获得内部）。


*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00003, RS_SOMEIP_-00012, RS_SOMEIP_00021, RS_SOMEIP_00025, RS_SOMEIP_00041, RS_-SOMEIP_00008)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> *♩(RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00217，RS_CM_00218，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_00003，RS_SOMEIP_-00012，RS_SOMEIP_00021，RS_SOMEIP_00025，RS_SOMEIP_00041，RS_-SOMEIP_00008)* SOME/IP序列化规则在[7.5.1.9]（#序列化负载）节中有解释。


**[SWS_CM_10345] Checks for a received SOME/IP response message** *[*Upon reception of a SOME/IP response message the checks defined in [[SWS_CM_10313](#_bookmark85)] shall be conducted. If any of the above checks fails the received SOME/IP event message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00003, RS_SOMEIP_00012, RS_SOMEIP_00019, RS_SOMEIP_00021, RS_SOMEIP_00025, RS_SOMEIP_00041, RS_SOMEIP_00008, RS_SOMEIP_00014)*

> 当接收到SOME / IP响应消息时，将按照[[SWS_CM_10313](#_bookmark85)]中定义的检查进行检查。如果上述任何一项检查失败，则应丢弃收到的SOME / IP事件消息，并（如果ara :: com实现启用了日志记录）记录事件。♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_00003，RS_SOMEIP_00012，RS_SOMEIP_00019，RS_SOMEIP_00021，RS_SOMEIP_00025，RS_SOMEIP_00041，RS_SOMEIP_00008，RS_SOMEIP_00014）


**[SWS_CM_10346] Identifying the right method** *[*Using the Service ID (see [PRS_SOMEIP_00245]) and the serviceInterfaceId attribute of the SomeipServiceInterfaceDeployment element as well as the Method ID (see [PRS_SOMEIP_00245]) and the methodId attribute of the SomeipFieldDeployment.sets and SomeipFieldDeployment.gets of the SomeipServiceInterfaceDeployment, the right method shall be identified.*♩(RS_CM_00204, RS_CM_00200, RS_CM_00212, RS_CM_00213, RS_CM_00217, RS_CM_00218, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00021)*

> **[SWS_CM_10346] 确定正确的方法** *[*使用服务ID（参见[PRS_SOMEIP_00245]）和SomeipServiceInterfaceDeployment元素的serviceInterfaceId属性以及方法ID（参见[PRS_SOMEIP_00245]）和SomeipFieldDeployment.sets和SomeipFieldDeployment.gets的methodId属性，可以确定正确的方法。*♩（RS_CM_00204，RS_CM_00200，RS_CM_00212，RS_CM_00213，RS_CM_00217，RS_CM_00218，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_00021）*


**[SWS_CM_10347] Discarding orphaned responses** *[*Orphaned responses shall be discarded according to [[SWS_CM_10315](#_bookmark87)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213)*

> [SWS_CM_10347] 根据[[SWS_CM_10315](#_bookmark87)]，废弃孤立的响应(*RS_CM_00204, RS_CM_00212, RS_CM_00213*)。


**[SWS_CM_10348] Deserializing the payload** *[*Based on the method determined according to [[SWS_CM_10346](#_bookmark125)] the Payload of the SOME/IP response message shall be deserialized according to the SOME/IP serialization rules.*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_-00028)* The SOME/IP serialization rules are explained in section [7.5.1.9](#serialization-of-payload).

> 根据[[SWS_CM_10346](#_bookmark125)]确定的方法，按照SOME/IP序列化规则反序列化SOME/IP响应消息的有效负载（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_-00028）。SOME/IP序列化规则在[7.5.1.9](#serialization-of-payload)节中有解释。


**[SWS_CM_10444] Failures during deserialization of response messages** *[*In case of failures during deserialization of response messages, the ara::com implementation shall make the Future returned by the Set or Get method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)] and [[SWS_CM_00113](#_bookmark591)]) ready according to [[SWS_CM_10440](#_bookmark437)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_SOMEIP_00007, RS_SOMEIP_00009, RS_SOMEIP_00028)*

> 在反序列化响应消息时出现故障时，ara :: com实现应按照[[SWS_CM_10440（# _bookmark437）]]将相应字段类的Set或Get方法返回的Future准备就绪。（参见[[SWS_CM_00112（# _bookmark588）]]和[[SWS_CM_00113（# _bookmark591）]]）♩（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_SOMEIP_00007，RS_SOMEIP_00009，RS_SOMEIP_00028）


**[SWS_CM_10349] Making the Future ready** *[*In order to make the Future returned by the Set or Get method of the respective Field class (see [[SWS_CM_00113](#_bookmark591)] and [[SWS_CM_00112](#_bookmark588)]) ready, the set_value operation (see [SWS_CORE_00345] and [SWS_CORE_00346]) of the Promise corresponding to this Future shall be invoked using the deserialized payload as an argument. This will unblock any blocking get, wait, wait_for, and wait_until calls that have been performed on this Future.*♩ (RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> 为了使Set或Get方法返回的Future（参见[[SWS_CM_00113](#_bookmark591)]和[[SWS_CM_00112](#_bookmark588)）准备就绪，应使用反序列化的有效负载作为参数调用与此Future相对应的Promise的set_value操作（参见[SWS_CORE_00345]和[SWS_CORE_00346]）。这将解除对此Future执行的任何阻塞get、wait、wait_for和wait_until调用。（RS_CM_00204，RS_CM_00212，RS_CM_00213，RS_CM_00215，RS_SOMEIP_00007，RS_SOMEIP_00009）


**[SWS_CM_10350] Invoke the notification function** *[*Any registered notification function shall be invoked according to [[SWS_CM_10318](#_bookmark95)].*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215, RS_SOMEIP_00007, RS_SOMEIP_00009)*

> **[SWS_CM_10350] 调用通知功能** *[*根据[[SWS_CM_10318](#_bookmark95)]，应调用任何注册的通知功能。*♩(RS_CM_00204, RS_CM_00212, RS_CM_00213, RS_CM_00215, RS_SOMEIP_00007, RS_SOMEIP_00009)*


**[SWS_CM_10363]**{DRAFT} **Failures in sending a SOME/IP event message** *[*If the sending of the SOME/IP event message generated by a field update fails locally (due to a network error which is notified to the ara::com implementation), the ara::com implementation shall return an error indicating \"network binding failure\" in the Result of the Update() method of the respective Field class (see [[SWS_CM_00119](#_bookmark548)]).*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_CM_00004)*

> 如果由字段更新生成的SOME / IP事件消息的发送在本地失败（由ara :: com实现通知的网络错误），则ara :: com实现应在相应字段类的Update（）方法的结果中返回一个表示“网络绑定失败”的错误（参见[[SWS_CM_00119]（＃_bookmark548）]）。♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00005，RS_CM_00004）

### Serialization of Payload


**[SWS_CM_10034] Serialization of Payload** *[*The serialization of the payload shall be based on the definition of the ServiceInterface of the data.*♩(RS_CM_00204, RS_CM_00201, RS_SOMEIP_00004, RS_SOMEIP_00005, RS_SOMEIP_00028)*

> **[SWS_CM_10034] 载荷的序列化** *[*载荷的序列化应基于数据的ServiceInterface的定义。*♩（RS_CM_00204，RS_CM_00201，RS_SOMEIP_00004，RS_SOMEIP_00005，RS_SOMEIP_00028）*


**[SWS_CM_10169] Missing parameters** *[*To allow migration the deserialization shall ignore parameters attached to the end of previously known parameter list.*♩(RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_10169] 缺少参数** *[*为了允许迁移，反序列化应该忽略之前已知参数列表末尾附加的参数。*♩(RS_CM_00204, RS_CM_00202)*


This means: Parameters that were not defined in the ServiceInterface used to generate or parametrize the deserialization code but exist at the end of the serialized data will be ignored by the deserialization.

> 这意味着：在用于生成或参数化反序列化代码时未在ServiceInterface中定义的参数，但存在于序列化数据末尾的，将被反序列化忽略。


**[SWS_CM_10259] Seralization Padding** *[*After the serialized data of a variable data length DataPrototype a padding for alignment purposes shall be added for the configured alignment (see [[SWS_CM_10260](#_bookmark133)]) if the variable data length DataPrototype is not the last element in the serialized data stream.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)* This requirement does not apply for the serialization of extensible structs and methods (see chapter [7.5.1.9.4](#structured-data-types-structs)).

> [SWS_CM_10259] 变长数据原型序列化后，为了对齐的目的，将添加填充（参见[[SWS_CM_10260](#_bookmark133)），如果变长数据原型不是序列化数据流中的最后一个元素。♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）此要求不适用于可扩展结构和方法的序列化（参见第7.5.1.9.4节）。


**[SWS_CM_10260] Setting the alignment for a variable data length data element** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps. alignment is set for a variable data length data element, the value of SomeipDataPrototypeTransformationProps.someipTransformationProps.alignment shall define the alignment. This requirement does not apply for the serialization of extensible structs and methods.*♩(RS_CM_00204, RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)* (see chapter [7.5.1.9.4](#structured-data-types-structs))

> **[SWS_CM_10260] 设置可变数据长度数据元素的对齐** *[*如果SomeipDataPrototypeTransformationProps.someipTransformationProps.对齐被设置为可变数据长度数据元素，SomeipDataPrototypeTransformationProps.someipTransformationProps.对齐的值将定义对齐。此要求不适用于可扩展结构和方法的序列化。*♩(RS_CM_00204, RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*（参见[7.5.1.9.4]章节（结构数据类型（structs）））


**[SWS_CM_11262] Missing alignment for a variable data length data element** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps.alignment is not set for a variable data length data element, the value of TransformationPropsToServiceInterfaceElementMapping.transformationProps.alignment shall define the alignment. This requirement does not apply for the serialization of extensible structs and methods.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)* (see chapter [7.5.1.9.4](#structured-data-types-structs))

> **[SWS_CM_11262] 对于可变数据长度的数据元素缺少对齐：如果SomeipDataPrototypeTransformationProps.someipTransformationProps.alignment未设置，则TransformationPropsToServiceInterfaceElementMapping.transformationProps.alignment的值将定义对齐。此要求不适用于可扩展结构和方法的序列化（参见第7.5.1.9.4节）。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_11263] Precedence of alignment settings for a variable data length data element** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps.alignment and TransformationPropsToServiceInterfaceElementMapping.transformationProps.alignment are both not set for a variable data length data element, no alignment shall be applied.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_11263] 可变长度数据元素的对齐设置优先级** *[*如果SomeipDataPrototypeTransformationProps.someipTransformationProps.alignment和TransformationPropsToServiceInterfaceElementMapping.transformationProps.alignment都未为可变长度数据元素设置，则不应应用对齐。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10263] Padding for a fixed length data element** *[*After serialized fixed data length data elements, the SOME/IP network binding shall never add automatically a padding for alignment.*♩(RS_CM_00201, RS_CM_00211)*

> **[SWS_CM_10263] 固定长度数据元素的填充** *[*在序列化固定长度数据元素后，SOME/IP网络绑定永远不会自动添加用于对齐的填充。*♩(RS_CM_00201, RS_CM_00211)*

Note:


If the following data element shall be aligned, a padding element of according size needs to be explicitly inserted into the CppImplementationDataType.

> 如果需要对齐以下数据元素，则需要显式地将大小相应的填充元素插入到CppImplementationDataType中。


**[SWS_CM_10037] Alignment calculation** *[*Alignment shall always be calculated from start of SOME/IP message.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> [SWS_CM_10037] 计算对齐  *[*对齐总是从SOME/IP消息开始计算。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


This attribute defines the memory alignment. The SOME/IP network binding does not try to automatically align parameters but aligns as specified. The alignment is currently constraint to multiple of 1 Byte to simplify code generators.

> 这个属性定义了内存对齐。SOME/IP网络绑定不会尝试自动对齐参数，而是按照指定对齐。当前的对齐限制为1字节的倍数，以简化代码生成器。


SOME/IP payload should be placed in memory so that the SOME/IP payload is suitable aligned. For infotainment ECUs an alignment of 8 Bytes (i.e. 64 bits) should be achieved, for all ECU at least an alignment of 4 Bytes should be achieved. An efficient alignment is highly hardware dependent.

> 应将SOME/IP有效负载放置在内存中，以使SOME/IP有效负载具有适当的对齐。对于信息娱乐ECU，应实现8字节（即64位）的对齐，对于所有ECU，至少应实现4字节的对齐。高效对齐高度依赖硬件。


**[SWS_CM_10016] Deserializing of exceeded unexpected data** *[*If more data than expected shall be deserialized, the unexpected data shall be discarded. The known fraction shall be considered.*♩(RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_10016] 超出预期数据的反序列化** *[*如果需要反序列化的数据超出预期，则应丢弃意外的数据。应考虑已知部分。*♩（RS_CM_00204，RS_CM_00202）*


**[SWS_CM_11411] Deserializing incomplete data on the skeleton side** *[*If less data than expected shall be deserialized on the skeleton side the data shall be discarded and the incident shall be logged. In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to E_MALFORMED_MESSAGE (see [PRS_SOMEIP_00191]) shall be sent to the requester.*♩(RS_CM_00204, RS_CM_00202)*

> [SWS_CM_11411] 在骨架端反序列化不完整的数据。如果收到的数据比预期的少，则应丢弃该数据并记录事件。如果收到 REQUEST 消息（参见[PRS_SOMEIP_00055]），另外，还应发送带有返回代码设置为 E_MALFORMED_MESSAGE 的 ERROR 消息（参见[PRS_SOMEIP_00191]）给请求者（参见[RS_CM_00204，RS_CM_00202]）。


**[SWS_CM_11412] Deserializing incomplete data on the proxy side** *[*If less data than expected shall be deserialized on the proxy side and the data to be deserialized does not belong to a Field, the data shall be discarded and the incident shall be logged. In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to E_MALFORMED_MESSAGE (see [PRS_SOMEIP_00191]) shall be sent to the requester.*♩(RS_CM_00204, RS_CM_00202)*

> 如果在代理端反序列化的数据少于预期，且数据不属于字段，则应丢弃该数据并记录事件。 如果收到请求消息（参见[PRS_SOMEIP_00055]），另外，还应向请求者发送具有返回代码设置为E_MALFORMED_MESSAGE（参见[PRS_SOMEIP_00191]）的错误消息（参见RS_CM_00204，RS_CM_00202）。


**[SWS_CM_10017] Deserializing incomplete data on the proxy side belonging to a field and initValue defined** *[*If less data than expected shall be deserialized on the proxy side and the data to be deserialized belong to a Field and the initValue is defined, the initValue shall be used as a substitute for the missing data.*♩(RS_CM_00204, RS_CM_00202)*

> **[SWS_CM_10017] 在代理端反序列化属于字段和initValue定义的不完整数据** *[*如果在代理端反序列化的数据少于预期，并且要反序列化的数据属于字段和initValue定义，则initValue应用作为缺失数据的替代品。*♩(RS_CM_00204, RS_CM_00202)*


**[SWS_CM_11413] Deserializing incomplete data on the proxy side belonging to a field and initValue not defined** *[*If less data than expected shall be deserialized on the proxy side and the data to be deserialized belong to a Field and the initValue is not defined the data shall be discarded and the incident shall be logged. In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to E_MALFORMED_MESSAGE (see [PRS_SOMEIP_00191]) shall be sent to the requester.*♩(RS_CM_00204, RS_CM_00202)*

> 如果在代理端反序列化的数据少于预期，且数据属于某个字段，且初始值未定义，则该数据将被丢弃，并记录事件。如果收到请求消息（请参见[PRS_SOMEIP_00055]），另外，还应发送一条带有返回代码设置为E_MALFORMED_MESSAGE（请参见[PRS_SOMEIP_00191]）的错误消息给请求者（参见[RS_CM_00204]，[RS_CM_00202]）。

In the following the serialization of different parameters is specified.

### Basic Data Types


**[SWS_CM_10036] Serialization of supported StdCppImplementationDataTypes** *[*The primitive StdCppImplementationDataTypes defined in [13] which shall be supported for serialization are listed in Table [7.1](#_bookmark136).*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10036] 支持的 StdCppImplementationDataTypes 的序列化** *[*在[13]中定义的原始StdCppImplementationDataTypes，应支持序列化，列在表[7.1](#_bookmark136)中。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*



**Table 7.1: Primitive StdCppImplementationDataTypes supported for serialization**

> 表7.1：用于序列化的原始StdCppImplementationDataTypes支持


The Byte Order is specified common for all parameters by byteOrder of ApSomeipTransformationProps.

> 字节顺序由ApSomeipTransformationProps的字节顺序指定，适用于所有参数。

### Enumeration Data Types


**[SWS_CM_10361] Serializing Enumeration Data Type** *[*Enumeration Data Type shall be serialized according to [[SWS_CM_10036](#_bookmark135)] based on their underlying primitive StdCppImplementationDataType (i.e., the Primitive Cpp Implementation Data Type that is defined as the underlying type of the enumeration as defined in [SWS_LBAP_00027])*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10361] 序列化枚举数据类型** *[*枚举数据类型应根据[[SWS_CM_10036](#_bookmark135)]的基础原始StdCppImplementationDataType（即在[SWS_LBAP_00027]中定义为枚举的基础类型的原始Cpp实现数据类型）进行序列化*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*

### Scale Linear And Texttable Data Types


**[SWS_CM_10391] Serializing Scale Linear And Texttable Data Type** *[*Scale Linear And Texttable Data Type shall be serialized according to [[SWS_CM_10361](#_bookmark138)] based on the Enumeration Data Type they were specified with (see [SWS_LBAP_00031]).*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10391] 序列化线性比例和文本表数据类型** *[*根据指定的枚举数据类型（参见[SWS_LBAP_00031]），线性比例和文本表数据类型应按[[SWS_CM_10361](#_bookmark138)]进行序列化。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

### Structured Data Types (structs)


**[SWS_CM_10042] Serializing a struct Data Type** *[*A Structure Cpp Implementation Data Type shall be serialized in order of depth-first traversal.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10042] 序列化结构体数据类型** *[*一个结构体Cpp实现的数据类型应按深度优先遍历的顺序进行序列化。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


The SOME/IP network binding doesn't automatically align parameters of a struct.

> SOME/IP网络绑定不会自动对齐结构体的参数。


Insert reserved/padding elements into the AUTOSAR data type if needed for alignment, since the SOME/IP network binding shall not automatically add such padding.

> 在需要对齐时，将保留/填充元素插入AUTOSAR数据类型，因为SOME/IP网络绑定不会自动添加此类填充。


So if for example a struct includes a std::uint8_t and a std::uint32_t, they are just written sequentially into the buffer. This means that there is no padding between the uint8 and the first byte of the std::uint32_t; therefore, the std::uint32_t might not be aligned. So the system designer has to consider to add padding elements to the data type to achieve the required alignment or set it globally.

> 如果一个结构体包括一个std::uint8_t和一个std::uint32_t，它们就会被顺序写入缓冲区。这意味着在uint8和std::uint32_t的第一个字节之间没有填充，因此std::uint32_t可能不对齐。因此，系统设计者必须考虑添加填充元素到数据类型以达到所需的对齐或设置全局对齐。


Warning about unaligned structs or similar shall not be done in the SOME/IP network binding but only in the tool chain used to generate the SOME/IP network binding.

> 警告关于不对齐的结构体或类似的情况不应在SOME/IP网络绑定中进行，而应仅在用于生成SOME/IP网络绑定的工具链中进行。


The SOME/IP network binding does not automatically insert dummy/padding elements.

> SOME/IP网络绑定不会自动插入虚拟/填充元素。


SOME/IP allows to add a length field of 8, 16 or 32 bit in front of structs. The length field of a struct describes the number of bytes of the struct. This allows for extensible structs which allow better migration of interfaces.

> SOME/IP允许在结构前添加8、16或32位的长度字段。结构的长度字段描述结构的字节数。这允许可扩展的结构，从而更好地迁移接口。


**[SWS_CM_00252] Missing size of length field for structs** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField is set to a value equal to 0, no length field shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_00252] 结构体的长度字段缺失** *[*如果属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField设置为等于0，则不会在序列化的结构体前插入长度字段，而该结构体是通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义的ApSomeipTransformationProps。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10252]** *[*If attribute SomeipDataPrototypeTransformationProps. someipTransformationProps.sizeOfStructLengthField is set to a value greater 0, a length field shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField设置为大于0的值，则应在通过SomeipDataPrototypeTransformationProps定义的序列化结构之前插入长度字段（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）。


**[SWS_CM_10268] Setting the size length field for structs** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is set this attribute shall define the byte order for the length field that shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10268] 设置结构体的大小长度字段** *[*如果设置了属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，则该属性必须定义在序列化的结构体之前插入的长度字段的字节序，该结构体通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义。 ♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00253] Default size of length field for structs** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfStructLengthField is set to a value equal to 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField is not set, no length field shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField设置为等于0的值，并且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField未设置，则不会在序列化的结构前插入长度字段，其中ApSomeipTransformationProps通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义。


**[SWS_CM_00254] Precedence when setting size of length field for structs** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField is set to a value greater 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField is not set, a length field shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_00254] 当为结构设置长度字段时的优先级** *[*如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField设置了一个大于0的值，而属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField未设置，则应通过SomeipDataPrototypeTransformationProps.someipTransformationProps在序列化结构前插入一个长度字段。♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10269] Setting the byte order of the length field for structs** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, the attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder shall define the byte order for the length field that shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10269] 设置结构体长度字段的字节顺序** *[*如果设置了属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder，而没有设置属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，则属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder将定义序列化结构体前插入的长度字段的字节顺序，其中SomeipDataPrototypeTransformationProps.someipTransformationProps定义了ApSomeipTransformationProps。someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00255] Default size of length field for structs** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField is not set, no length field shall be inserted in front of the serialized struct.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_00255] 结构体的默认长度字段** *[*如果未设置属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField和属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField，则在序列化的结构体前不会插入长度字段。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10270] Default byte order for the length field of structs** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, a byte order of mostSignificantByteFirst (i.e., big endian) shall be used for the length field that shall be inserted in front of the serialized associative struct.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder未设置，并且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder未设置，则序列化的关联结构体前面插入的长度字段应使用最高字节优先（即大端）字节顺序。


**[SWS_CM_10253] Default data type for the length field of structs** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField defines the data type for the length field of a struct, the data shall be:

> 如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStructLengthField定义了结构体的长度字段的数据类型，那么该数据将为：

- *uint8* if sizeOfStructLengthField equals 1
- *uint16* if sizeOfStructLengthField equals 2
- *uint32* if sizeOfStructLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00256] Default data type for the length field of structs** *[*If TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField defines the the data type for the length field of a struct, the data shall be:

> 如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField定义结构体长度字段的数据类型，则数据应为：

- *uint8* if sizeOfStructLengthField equals 1
- *uint16* if sizeOfStructLengthField equals 2
- *uint32* if sizeOfStructLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10218] Scope of length field value for structs** *[*The serializing SOME/IP network binding shall write the size (in bytes) of the serialized struct (without the size of the length field) into the length field of the struct.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10218] 结构体的长度字段值的范围** *[*序列化SOME/IP网络绑定应将序列化结构体的大小（不包括长度字段的大小）写入结构体的长度字段中。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10219] Length greater than expected struct length** *[*If the length is greater than the expected length of a struct (as specified in the data type definition) a deserializing SOME/IP network binding shall only interpret the expected data and skip the unexpected.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10219]长度大于预期的结构长度** *[*如果长度大于结构的预期长度（在数据类型定义中指定），则反序列化一些/ IP网络绑定只会解释预期的数据并跳过意外的。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


To determine the start of the next expected data following the skipped unexpected part, the SOME/IP network binding can use the supplied length information.

> 为了确定下一个预期数据的开始，经过意外跳过的部分，SOME/IP网络绑定可以使用提供的长度信息。

**Figure 7.14: Serialization of Structs without Length Fields (Example)**
**Figure 7.15: Serialization of Structs with Length Fields (Example)**


**[SWS_CM_01046] Definition of tlvDataIdDefinition** *[*Regarding the definition of tlvDataIdDefinition see [TPS_MANI_01097] and [constr_1594] for details.*♩ (RS_CM_00204, RS_CM_00205, RS_SOMEIP_00050)*

> **[SWS_CM_01046] tlvDataIdDefinition 的定义** *[*关于 tlvDataIdDefinition 的定义，请参阅 [TPS_MANI_01097] 和 [constr_1594] 以获取详细信息。*♩ (RS_CM_00204, RS_CM_00205, RS_SOMEIP_00050)*

### Structured Datatypes and Arguments with Identifier and optional Members


To achieve enhanced forward and backward compatibility, an additional Data ID can be added in front of struct members or method arguments. The receiver then can skip unknown members/arguments, i.e. where the Data ID is unknown. New members/arguments can be added at arbitrary positions when Data IDs are transferred in the serialized byte stream.

> 为了实现更强的向前和向后兼容性，可以在结构成员或方法参数前面添加额外的数据ID。接收者可以跳过未知的成员/参数，即数据ID未知的情况。当数据ID在序列化字节流中传输时，可以在任意位置添加新的成员/参数。


Structs are modeled in the Manifest using CppImplementationDataType of category STRUCTURE and members are represented by CppImplementationDataTypeElements. Method arguments are represented by ArgumentDataPrototypes.

> 结构在清单中使用CppImplementationDataType的类别STRUCTURE建模，成员由CppImplementationDataTypeElements表示。方法参数由ArgumentDataPrototypes表示。


The assignment of Data IDs is modeled in the Manifest in the context of TransformationPropsToServiceInterfaceElementMapping. Refer to [6] for more details.

> 数据ID的分配在转换PropsToServiceInterface元素映射的背景下模型化了清单。有关更多详细信息，请参阅[6]。


Moreover, the usage of Data IDs allows describing structs with optional members. Whether a member is optional or not, is defined in the Manifest using the attribute CppImplementationDataTypeElement.isOptional.

> 此外，使用数据ID可以描述具有可选成员的结构。是否需要一个成员是可选的，可以在Manifest中使用属性CppImplementationDataTypeElement.isOptional来定义。


Whether an optional member is actually present in the struct or not, is to be determined during runtime. This is realized in the Adaptive Platform using the ara::core::Optional class template (see [8.1.2.6.3](#optional-data-types) Optional Data Types).

> 不管可选成员是否实际存在于结构中，都要在运行时确定。Adaptive Platform使用ara :: core :: Optional类模板实现了这一点（参见[8.1.2.6.3]（#optional-data-types）可选数据类型）。


In addition to the Data ID, a wire type encodes the datatype of the following member. Data ID and wire type are encoded in a so-called tag.

> 除了数据ID，线缆类型还编码了后面成员的数据类型。数据ID和线缆类型都被编码在所谓的标签中。

For more details, please refer to [5].


**[SWS_CM_90443] Wire type for non-dynamic data types** *[*If TransformationPropsToServiceInterfaceElementMapping.transformationProps. isDynamicLengthFieldSize is set to false or is not defined, the serializer shall use wire type 4 for serializing complex types and shall use the fixed size length fields. The size is defined in TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField, sizeOfArrayLengthField or sizeOfStringLengthField.*♩(RS_CM_00204)*

> 如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.isDynamicLengthFieldSize设置为false或未定义，序列化器应使用线类型4来序列化复杂类型，并且应使用固定大小的长度字段。大小由TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStructLengthField，sizeOfArrayLengthField或sizeOfStringLengthField定义。


**[SWS_CM_90444] Wire type for dynamic data types** *[*If TransformationPropsToServiceInterfaceElementMapping.transformationProps.isDynamicLengthFieldSize is set to true, the transformer shall use wire types 5,6,7 for serializing complex types and shall chose the size of the length field according to this wire type.*♩(RS_CM_00204)*

> **[SWS_CM_90444] 动态数据类型的线类型** *[*如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.isDynamicLengthFieldSize设置为true，则转换器应使用线类型5、6、7序列化复杂类型，并根据此线类型选择长度字段的大小。*♩（RS_CM_00204）*


**[SWS_CM_90445] A deserializer shall always be able to handle the wire types 4, 5, 6 and 7** *[*A deserializer shall always be able to handle the wire types 4, 5, 6 and 7 independent of the setting of TransformationPropsToServiceInterfaceElementMapping.transformationProps.isDynamicLengthFieldSize.*♩ (RS_CM_00204)*

> [SWS_CM_90445] 一个反序列化程序必须总是能够处理4、5、6和7这四种线类型，不受TransformationPropsToServiceInterfaceElementMapping.transformationProps.isDynamicLengthFieldSize的设置的影响。(RS_CM_00204)


**[SWS_CM_90446] Data ID** *[*If a Data ID is defined for an ArgumentDataPrototype or CppImplementationDataType by means of TransformationPropsToServiceInterfaceElementMapping.TlvDataIdDefinition.id, a tag shall be inserted in the serialized byte stream.*♩(RS_CM_00204)*

> **[SWS_CM_90446] 数据ID** *如果通过TransformationPropsToServiceInterfaceElementMapping.TlvDataIdDefinition.id为ArgumentDataPrototype或CppImplementationDataType定义了数据ID，则应在序列化的字节流中插入标记。♩(RS_CM_00204)*


Note: regarding existence of Data IDs, refer to [6]. Note: regarding existence of length field, refer to [5].

> 注意：关于数据ID的存在，参见[6]。注意：关于长度字段的存在，参见[5]。


Rationale: The length field is required to skip unknown members/arguments during deserialization.

> 理由：在反序列化过程中，需要长度字段来跳过未知的成员/参数。


**[SWS_CM_90451] Byte order for the length field of serialized structs** *[*TransformationPropsToServiceInterfaceElementMapping.transformationProps. byteOrder shall define the byte order for the length field.*♩(RS_CM_00204)*

> [SWS_CM_90451] 序列化结构体的长度字段的字节顺序 *[*TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder 应定义长度字段的字节顺序。*♩(RS_CM_00204)*


**[SWS_CM_90452] Default byte order for the length field of structs** *[*TransformationPropsToServiceInterfaceElementMapping.transformationProps. byteOrder is not defined, a byte order of mostSignificantByteFirst shall be used for the length field.*♩(RS_CM_00204)*

> **[SWS_CM_90452] 结构体的长度字段的默认字节顺序** *[*TransformationPropsToServiceInterfaceElementMapping.transformationProps.字节顺序未定义，长度字段应使用最高字节优先的字节顺序。*♩(RS_CM_00204)*

Regarding structure members and serialization examples, refer to [5].

### Strings


**[SWS_CM_10053] Strings encoding** *[*Strings shall be encoded using Unicode and terminated with a \"\\0\"-character.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10053] 字符串编码** *[*字符串应使用Unicode编码，以“\ 0”字符结尾。*♩(RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211)*


**[SWS_CM_10054] Supported encoding** *[*Different Unicode encoding shall be supported including UTF-8, UTF-16BE, and UTF-16LE. Since these encoding have a dynamic length of bytes per character, the maximum length in bytes is up to three times the length of characters in UTF-8 plus 1 Byte for the termination with a \"\\0\" or two times the length of the characters in UTF-16 plus 2 Bytes for a \"\\0\". UTF-8 character can be up to 6 bytes and an UTF-16 character can be up to 4 bytes.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*

> 支持不同的Unicode编码，包括UTF-8、UTF-16BE和UTF-16LE。由于这些编码每个字符的字节数是动态的，所以最大字节数是UTF-8字符长度的三倍加1个字节用于以“\0”结尾，或者是UTF-16字符长度的两倍加2个字节用于以“\0”结尾。UTF-8字符最多可以有6个字节，而UTF-16字符最多可以有4个字节。（RS_CM_00204、RS_CM_00201、RS_CM_00202、RS_CM_00211、RS_AP_00136）


**[SWS_CM_10285] Responsibility of proper string encoding** *[*The application provides the string always in the UTF-8 encoding. The SOME/IP binding has to re-encode the data to the on-the-wire encoding that is configured by ApSomeipTransformationProps.stringEncoding.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*

> **[SWS_CM_10285] 正确字符串编码的责任** *[*应用程序始终以UTF-8编码提供字符串。 SOME/IP绑定必须将数据重新编码为由ApSomeipTransformationProps.stringEncoding配置的通信编码。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*


**[SWS_CM_10055] UTF-16LE and UTF-16BE terminating bytes** *[*UTF-16LE and UTF-16BE strings shall be zero terminated with a \"\\0\" character. This means they shall end with (at least) two 0x00 Bytes.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10055] UTF-16LE 和 UTF-16BE 终止字节** *[*UTF-16LE 和 UTF-16BE 字符串应以“\0”字符终止。这意味着它们应以（至少）两个0x00字节结尾。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10056] UTF-16LE and UTF-16BE strings length** *[*UTF-16LE and UTF16BE strings shall have an even length.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10056] UTF-16LE 和 UTF-16BE 字符串长度** *[*UTF-16LE 和 UTF16BE 字符串的长度必须为偶数。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10057] Odd UTF-16LE and UTF-16BE string length** *[*For UTF-16LE and UTF-16BE strings having an odd length the last byte shall be silently removed by the receiving SOME/IP network binding.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10057] 奇数长度的 UTF-16LE 和 UTF-16BE 字符串** *[*接收 SOME/IP 网络绑定时，对于具有奇数长度的 UTF-16LE 和 UTF-16BE 字符串，将会静默地移除最后一个字节。♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10248] Odd UTF-16LE and UTF-16BE string length** *[*In case of UTF16LE and UTF-16BE strings having an odd length, after removal of the last byte, the two bytes before shall be 0x00 bytes (termination) for a string to be valid.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10248] 奇数长度的UTF-16LE和UTF-16BE字符串** *[*如果UTF16LE和UTF-16BE字符串的长度为奇数，则在删除最后一个字节后，前面的两个字节必须为0x00（终止），才能使字符串有效。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10058] String start byte(BOM)** *[*All strings shall always start with a Byte Order Mark (BOM).*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10058] 字符串起始字节（BOM）** *[*所有字符串都必须以字节顺序标记（BOM）开头。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


For the specification of BOM, see [14] and [15]. Please note that the BOM is used in the serialized strings to achieve compatibility with Unicode.

> 对于BOM的规范，请参见[14]和[15]。请注意，BOM在序列化字符串中用于实现与Unicode的兼容性。


**[SWS_CM_10459]**{OBSOLETE} **Legacy string serialization** *[*The legacy string serialization shall be triggered if a Unicode is detected and attribute ApSomeipTransformationProps.implementsLegacyStringSerialization is true.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10459]**{已过时} **传统字符串序列化** *[*如果检测到 Unicode 并且 ApSomeipTransformationProps.implementsLegacyStringSerialization 属性为 true，则触发传统字符串序列化。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10059] BOM checking by SOME/IP network binding implementation** *[*The receiving SOME/IP network binding implementation shall check the BOM and handle a missing BOM or a malformed BOM as an error by discarding the complete payload and logging the incident (if logging is enabled for the ara::com implementation).*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> [SWS_CM_10059] 通过SOME/IP网络绑定实现进行BOM检查。接收SOME/IP网络绑定实现应检查BOM，并将缺失的BOM或格式不正确的BOM处理为错误，丢弃整个有效负载并记录事件（如果ara :: com实现已启用日志记录）。♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）


**[SWS_CM_10060] BOM addition** *[*The BOM shall be added by the SOME/IP sending network binding implementation.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10060] 添加 BOM** *[*BOM 将由 SOME/IP 发送网络绑定实现添加。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10061] Supported encoding of CppImplementationDataType with category equal to STRING** *[*If a CppImplementationDataType with category equal to STRING is used in the context of a ServiceInterface then the encoding of this String DataType is UTF-8.*♩()*

> **[SWS_CM_10061] 如果在服务接口的上下文中使用具有类别等于STRING的CppImplementationDataType，则此String DataType的编码为UTF-8。**


This means that the CppImplementationDataType can only be mapped to an ApplicationDataType of category STRING where attribute swDataDefProps.swTextProps.baseType.baseTypeEncoding is set to the value UTF-8 as defined by [constr_5035]. If a CppImplementationDataType without an ApplicationDataType is used there is no formal description about the UTF-8 encoding in the ServiceInterface description.

> 这意味着CppImplementationDataType只能映射到一个ApplicationDataType类别为STRING，其中swDataDefProps.swTextProps.baseType.baseTypeEncoding被设置为[constr_5035]定义的值UTF-8。如果使用没有ApplicationDataType的CppImplementationDataType，在ServiceInterface描述中没有关于UTF-8编码的正式描述。


According to SOME/IP serialized strings start with a length field of 8, 16 or 32 bit which preceeds the actual string data. The value of this length field holds the length of the string including the BOM and any string termination in units of bytes.

> 根据SOME/IP序列化字符串，开头有一个8、16或32位的长度字段，其后是实际的字符串数据。该长度字段的值包含了字符串的长度，包括BOM和任何字符串结束符，以字节为单位。


**[SWS_CM_10271] Default size of length field for strings** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField is set to a value greater 0, a length field shall be inserted in front of the serialized string for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10271] 字符串的默认长度字段** *[*如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField设置为大于0的值，则应为其定义ApSomeipTransformationProps的序列化字符串插入长度字段。♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10272] Byte order of length field for strings** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is set this attribute shall define the byte order for the length field that shall be inserted in front of the serialized string for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10272] 字符串长度字段的字节序** *[*如果设置了属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，该属性应定义在序列化字符串前插入的长度字段的字节序，其中ApSomeipTransformationProps通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义。 someipTransformationProps。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10273] Size of length field for strings** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfStringLengthField is set to a value greater 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField is not set, a length field shall be inserted in front of the serialized struct for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10273] 字符串长度字段的大小** *[*如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStringLengthField被设置为一个大于0的值，并且SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField没有被设置，那么一个长度字段将被插入到通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义的序列化结构前面。♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10274] Setting byte order for the length field of strings** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, the attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder shall define the byte order for the length field that shall be inserted in front of the serialized string for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10274] 设置字符串长度字段的字节顺序** *[*如果设置了属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder，而未设置属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，则属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder应定义要插入序列化字符串前面的字节顺序，该字符串的ApSomeipTransformationProps由SomeipDataPrototypeTransformationProps.someipTransformationProps定义。 someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10275] Default size of length field for strings** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfStringLengthField is not set or set a value of 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField is not set or set to a value of 0, a length field of 4 bytes with the data type *uint32* shall be inserted in front of the serialized string.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10275] 字符串的默认长度字段** *[*如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStringLengthField未设置或设置为0，并且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField未设置或设置为0，则应在序列化字符串前插入4字节的数据类型为*uint32*的长度字段。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10276] Default byte order for the length field of strings** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, a byte order of mostSignificantByteFirst (i.e., big endian) shall be used for the length field that shall be inserted in front of the serialized string.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder未设置，并且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder未设置，则序列化字符串前方插入的长度字段将使用最高字节优先（即大端）的字节顺序。（参见RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）


**[SWS_CM_10277] Data type of the length field for strings** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField defines the the data type for the length field of a string, the data shall be:

> 如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfStringLengthField定义字符串长度字段的数据类型，则该数据应为：

- *uint8* if sizeOfStringLengthField equals 1
- *uint16* if sizeOfStringLengthField equals 2
- *uint32* if sizeOfStringLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10278] Data type of the length field for strings** *[*If TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfStringLengthField defines the the data type for the length field of a string, the data shall be:

> 如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfStringLengthField定义字符串的长度字段的数据类型，该数据应为：

- *uint8* if sizeOfStringLengthField equals 1
- *uint16* if sizeOfStringLengthField equals 2
- *uint32* if sizeOfStringLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10245] Serialization of strings** *[*Serialization of strings shall consist of the following steps:

> **[SWS_CM_10245] 字符串的序列化** *[*字符串的序列化应包括以下步骤：


1. Add the Length Field The value of the length field shall be filled with the number of bytes needed for the string (i.e., the result of ara::core::String::length ()), including the BOM and any string termination that needs to be added.

> 在长度字段中添加值，长度字段的值应填入字符串所需字节数（即ara::core::String::length()的结果），包括BOM和任何需要添加的字符串终止符。

2. Appending BOM right after the length field according to the configured ApSomeipTransformationProps.byteOrder, if BOM is not already available in the first 3 (UTF-8) bytes of the to be serialized array containing the string. If the BOM is already present, simply copy the BOM into the output buffer.

> 在根据配置的ApSomeipTransformationProps.byteOrder在长度字段之后附加BOM，如果BOM不在要序列化的字符串数组的前3（UTF-8）字节中已经存在。如果BOM已经存在，只需将BOM复制到输出缓冲区中即可。

3. Perform the re-encoding from UTF-8 to UTF-16 if the on-the-wire encoding is configured as UTF-16 by ApSomeipTransformationProps.stringEncoding. The re-encoding from UTF-8 to UTF-16BE shall be done if the configured ApSomeipTransformationProps.byteOrder is set to mostSignificantByteFirst. The re-encoding rom UTF-8 to to UTF-16LE shall be done if the configured ApSomeipTransformationProps.byteOrder is set to mostSignificantByteLast.

> 执行从UTF-8到UTF-16的重新编码，如果按照ApSomeipTransformationProps.stringEncoding配置的编码为UTF-16。如果配置的ApSomeipTransformationProps.byteOrder设置为mostSignificantByteFirst，则从UTF-8重新编码为UTF-16BE。如果配置的ApSomeipTransformationProps.byteOrder设置为mostSignificantByteLast，则从UTF-8重新编码为UTF-16LE。
4. Copying the string data into the output buffer.

5. Termination of the string with 0x00(UTF-8) or 0x0000 (UTF-16) if not terminated yet by appending 0x00(UTF-8) or 0x0000 (UTF-16).

> 结束字符串时，如果尚未通过附加0x00（UTF-8）或0x0000（UTF-16）来终止，则需要附加0x00（UTF-8）或0x0000（UTF-16）。

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*


**[SWS_CM_10247]**{DRAFT} **Deserialization of strings** *[*Deserialization of strings shall consist of the following steps:

> **[SWS_CM_10247]**{草案}**反序列化字符串** *[*反序列化字符串应包括以下步骤：


1. Check whether the string starts with a BOM. If not, the complete payload shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation). In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to E_MALFORMED_MESSAGE (see [PRS_SOMEIP_00191]) shall be sent to the requester.

> 检查字符串是否以BOM开头。如果不是，则应丢弃整个有效负载，并记录此事件（如果ara :: com实现启用了日志记录）。如果收到请求消息（参见[PRS_SOMEIP_00055]），另外，还应向请求者发送带有返回代码设置为E_MALFORMED_MESSAGE（参见[PRS_SOMEIP_00191]）的错误消息。

2. Check whether BOM has the same value as ApSomeipTransformationProps.byteOrder. If not, the complete payload shall be discarded and the incident shall be logged. In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to E_MALFORMED_MESSAGE (see [PRS_SOMEIP_00191]) shall be sent to the requester.

> 检查BOM是否与ApSomeipTransformationProps.byteOrder具有相同的值。如果不是，则应丢弃整个有效负载，并记录事件。对于收到的请求消息（请参见[PRS_SOMEIP_00055]），另外，还应向请求者发送带有返回代码设置为E_MALFORMED_MESSAGE（请参见[PRS_SOMEIP_00191]）的错误消息。
3. Remove the BOM

4. Silently discard the last byte of the string in case of an UTF-16 string with odd length (in bytes)

> 如果是UTF-16字符串且字节数为奇数，则静默丢弃最后一个字节。

5. Check whether the string terminates with 0x00 (UTF-8) or 0x0000 (UTF-16). If not, the complete payload shall be discarded and the incident shall be logged. In case of a received REQUEST message (see [PRS_SOMEIP_00055]), additionally, an ERROR message with return code set to E_MALFORMED_MESSAGE ( see [PRS_SOMEIP_00191]) shall be sent to the requester.

> 检查字符串是否以0x00（UTF-8）或0x0000（UTF-16）结尾。如果不是，则应丢弃整个有效负载，并记录事件。对于收到的REQUEST消息（参见[PRS_SOMEIP_00055]），另外，还应向请求者发送具有返回代码设置为E_MALFORMED_MESSAGE（参见[PRS_SOMEIP_00191]）的ERROR消息。

6. Perform the re-encoding from UTF-16 to UTF-8 if the on-the-wire encoding is configured as UTF-16 by ApSomeipTransformationProps.stringEncoding. The re-encoding from UTF-16BE to UTF-8 shall be done if the configured ApSomeipTransformationProps.byteOrder is set to mostSignificantByteFirst. The re-encoding from UTF-16LE to UTF-8 shall be done if the configured ApSomeipTransformationProps.byteOrder is set to mostSignificantByteLast.

> 如果ApSomeipTransformationProps.stringEncoding配置为UTF-16，请从UTF-16执行重新编码到UTF-8。如果配置的ApSomeipTransformationProps.byteOrder设置为mostSignificantByteFirst，则从UTF-16BE重新编码到UTF-8。如果配置的ApSomeipTransformationProps.byteOrder设置为mostSignificantByteLast，则从UTF-16LE重新编码到UTF-8。

7. Copy the string data (i.e., everything but the BOM and any string termination added during serialization).

> 复制字符串数据（即除了BOM和序列化时添加的任何字符串终止符以外的所有内容）。

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211, RS_AP_00136)*

### Vectors and arrays


SOME/IP supports arrays with static and dynamic length but there is no definition of vectors on this abstraction level. Therefore, vectors are mapped to arrays with dynamic length. The SOME/IP specification requires to add a length field of 8, 16 or 32 bit in front of data structures with dynamic length. The length field of arrays describes the total number of bytes. Note that this section uses only the term array which can also be used to realize vectors.

> SOME/IP 支持具有静态和动态长度的数组，但在此抽象层次上没有定义向量。因此，向量映射到具有动态长度的数组。SOME/IP 规范要求在具有动态长度的数据结构前添加 8 位、16 位或 32 位的长度字段。数组的长度字段描述总字节数。请注意，本节仅使用“数组”一词，也可以用它来实现向量。


**[SWS_CM_00257] Missing size of array length field** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is set to a value equal to 0, no length field shall be inserted in front of the serialized array for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransfor-mationProps. -Note that omitting the length field by setting someipTransformationProps.sizeOfArrayLengthField to 0 is only allowed for arrays with static length (i.e., fixed length arrays) though (see also [constr_3447]).*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_00257] 缺少数组长度字段** *[*如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField设置为等于0的值，则不会在为其定义ApSomeipTransformationProps的序列化数组前插入长度字段。 -注意，通过将someipTransformationProps.sizeOfArrayLengthField设置为0来省略长度字段仅适用于具有静态长度（即固定长度数组）（另见[constr_3447]）。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10256] Size of the length field for arrays** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is set to a value greater 0, a length field shall be inserted in front of the serialized array for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField设置为大于0的值，则必须在通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义的序列化数组之前插入长度字段(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)。


**[SWS_CM_10279] Setting byte order for the length field of strings** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is set this attribute shall define the byte order for the length field that shall be inserted in front of the serialized array for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10279] 设置字符串长度字段的字节顺序** *[*如果设置了SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder属性，该属性将定义用于为其定义ApSomeipTransformationProps的序列化数组前插入的长度字段的字节顺序。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00258] Default size of the length field for arrays** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField is set to a value equal to 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is not set, no length field shall be inserted in front of the serialized array for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps. -Note that omitting the length field by setting someipTransformationProps.sizeOfArrayLengthField to 0 is only allowed for arrays with static length (i.e., fixed length arrays) though (see also [constr_3447]).*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField设置为0，且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField未设置，则在通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义的序列化数组之前不会插入长度字段。注意，仅允许通过将someipTransformationProps.sizeOfArrayLengthField设置为0来省略长度字段（参见[constr_3447]），以便静态长度（即固定长度数组）。


**[SWS_CM_00259] Setting size of the length field for arrays** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField is set to a value greater 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is not set, a length field shall be inserted in front of the serialized array for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField设置为大于0的值，而属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField未设置，则应为通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义的序列化数组插入长度字段。(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)


**[SWS_CM_10280] Setting the byte order for size of length field for arrays** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, the attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder shall define the byte order for the length field that shall be inserted in front of the serialized array for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果设置了属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder，而没有设置属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，则属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder将定义序列化数组前插入的长度字段的字节顺序，该数组通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义ApSomeipTransformationProps。someipTransformationProps。（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）


**[SWS_CM_10258] Default size of the length field for arrays** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfArrayLengthField is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is not set, a length field of 4 bytes with the data type *uint32* shall be inserted in front of the serialized array.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果没有设置TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfArrayLengthField属性和SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField属性，序列化数组前面将插入一个4字节的长度字段，数据类型为uint32。(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)


**[SWS_CM_10281] Byte order of length field for arrays** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps. byteOrder is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, a byte order of mostSignificantByteFirst (i.e., big endian) shall be used for the length field that shall be inserted in front of the serialized array.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10281] 针对数组的长度字段的字节序** *[*如果未设置属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder 和属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，则应使用最高字节优先（即大端）的字节序为序列化数组前插入的长度字段。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10257] Datatype for the length field of arrays** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField defines the the data type for the length field of a array, the data shall be:

> **[SWS_CM_10257] 数组长度字段的数据类型** *[*如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField定义了数组的长度字段的数据类型，则该数据应为：

- *uint8* if sizeOfArrayLengthField equals 1
- *uint16* if sizeOfArrayLengthField equals 2
- *uint32* if sizeOfArrayLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00260] Datatype for the length field of arrays** *[*If TransformationPropsToServiceInterfaceElementMapping.transformationProps. sizeOfArrayLengthField defines the the data type for the length field of a array, the data shall be:

> **[SWS_CM_00260] 数组长度字段的数据类型** *[*如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField定义了数组的长度字段的数据类型，则该数据应为：

- *uint8* if sizeOfArrayLengthField equals 1
- *uint16* if sizeOfArrayLengthField equals 2
- *uint32* if sizeOfArrayLengthField equals 4

*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10076] Serializing arrays** *[*A array shall be serialized as the concatenation of the following elements:

> [SWS_CM_10076] 将数组序列化：将数组序列化为以下元素的连接：

- the length indicator which holds the length (in bytes) of the following array
- the array which contains the serialized elements of the array


where the size of the length field shall be determined as specified by ApSomeipTransformationProps.sizeOfArrayLengthField which applies to the array*♩ (RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 在哪里，长度字段的大小将按照ApSomeipTransformationProps.sizeOfArrayLengthField指定，这适用于数组*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*？


**[SWS_CM_10234] Vector representation** *[*A vector is represented in adaptive platform by a CppImplementationDataType with the category VECTOR. The payload is defined by a templateArgument that points with the templateType reference to the data type of elements that are contained in the vector. Note that vectors are realized with dynamic sized arrays on SOME/IP level.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> [SWS_CM_10234] 向量表示*[*在自适应平台上，一个向量由CppImplementationDataType表示，其类别为VECTOR。载荷由templateArgument定义，该templateArgument通过templateType引用指向包含在向量中的元素的数据类型。请注意，在SOME/IP层面上，向量是通过动态大小的数组实现的。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*

简体中文：[SWS_CM_10234] 向量表示*[*在自适应平台上，一个向量由CppImplementationDataType表示，其类别为VECTOR。载荷由templateArgument定义，该templateArgument通过templateType引用指向包含在向量中的元素的数据类型。请注意，在SOME/IP层面上，向量是通过动态大小的数组实现的。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10235] Array representation** *[*An array is represented in adaptive platform by an CppImplementationDataType with the category ARRAY. The payload is defined by a templateArgument that points with the templateType reference to the data type of elements that are contained in the array. Note that CppImplementationDataType with the category ARRAY are realized with fixed length arrays on SOME/IP level.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 在自适应平台上，数组由CppImplementationDataType类型的类别表示为ARRAY。有效负载由templateArgument定义，该templateArgument通过templateType引用指向包含在数组中的元素的数据类型。请注意，在SOME / IP级别上，使用固定长度数组实现具有类别ARRAY的CppImplementationDataType。（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）

In case of nested arrays, the same scheme applies.


**[SWS_CM_10222] Setting the size of the length field for arrays** *[*The serializing SOME/IP network binding shall write the size (in bytes) of the serialized array (without the size of the length field) into the length field.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10222] 设置数组的长度字段的大小** *[*序列化SOME/IP网络绑定应将序列化数组的大小（不包括长度字段的大小）写入长度字段。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


The layout of arrays with dynamic length is shown in [7.16](#_bookmark144) and Figure [7.17](#_bookmark145) where L_1 and L_2 denote the length in bytes. The serialization of oneand multi-dimensional dynamic length arrays is described in the next two subchapters.

> 带有动态长度的数组的布局在[7.16](#_bookmark144)和图[7.17](#_bookmark145)中展示，其中L_1和L_2表示字节长度。下两个子章节描述了一维和多维动态长度数组的序列化。

### One-dimensional

A one-dimensional array carries a number of elements of the same type.

**Figure 7.16:** **One-dimensional arrays (Example)**


**[SWS_CM_10070] Serializing one-dimentional array** *[*A one-dimensional array shall be serialized by concatenating the arrays elements in order.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10070] 序列化一维数组** *[*一维数组应通过按顺序连接数组元素来序列化。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

### Multi-dimensional


**[SWS_CM_10072] Serializing multi-dimentional array** *[*The serialization of multidimensional arrays shall happen in depth-first order.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10072] 序列化多维数组** *[*多维数组的序列化应按深度优先顺序进行。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

**Figure 7.17:** **Multi-dimensional arrays (Example)**


In case of multi-dimensional dynamic length arrays, each array (serialized as SOME/IP array) needs to have its own length field. See L_1 and L_2 in Figure [7.17](#_bookmark145).

> 在多维动态长度数组的情况下，每个数组（序列化为SOME / IP数组）都需要有自己的长度字段。参见图7.17中的L_1和L_2。

### Associative Maps


Associative map is modeled as StdCppImplementationDataType with category ASSOCIATIVE_MAP in the Manifest. As stated in the AUTOSAR Manifest Specification [6] the "natural" language binding in C++ for an associative map is ara::core::Map\<key_type,value_type\> where key_type is the data type used for the key of a map element and value_type is the data type for the value of a map element. Hereby key_type and value_type are derived from defined CppTemplateArguments aggregated by the Associative Map Cpp Implementation Data Type. Please see [SWS_LBAP_00023] for more details.

> 映射被建模为Manifest中的StdCppImplementationDataType类别ASSOCIATIVE_MAP。根据AUTOSAR Manifest规范[6]，映射的“自然”语言绑定是C ++中的ara :: core :: Map \ <key_type，value_type \>，其中key_type是用于映射元素键的数据类型，value_type是映射元素值的数据类型。因此，key_type和value_type是由映射Cpp实现数据类型聚合的定义的CppTemplateArguments派生的。有关更多详细信息，请参见[SWS_LBAP_00023]。


**[SWS_CM_10261] Serialization of an associative map** *[*As far as serialization is concerned the serialized representation of an associative map shall consist of the following parts without any intermediate padding:

> 就序列化而言，关联映射的序列化表示形式应包含以下部分，而不需要任何中间填充：


- **Length field:** A length field describing the size of the associative map excluding the length field itself in units of bytes.

> **长度字段：**一个描述关联映射大小（不包括长度字段本身）的长度字段，单位为字节。
- **Elements:** The individual map elements themselves

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10262] Insertion of an associative map length field** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is set to a value greater 0, a length field shall be inserted in front of the serialized associative map for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps. -Note that omitting the length field by setting someipTransformationProps.sizeOfArrayLengthField to 0 is only allowed for arrays with static length (i.e., fixed length arrays) though (see also [constr_3447]).*♩ (RS_CM_00204, RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField设置为大于0的值，则应在序列化关联映射之前插入长度字段，该关联映射通过SomeipDataPrototypeTransformationProps.someipTransformationProps进行定义。注意，只有当数组具有静态长度（即固定长度数组）时，才允许通过将someipTransformationProps.sizeOfArrayLengthField设置为0来省略长度字段（另请参见[constr_3447]）。


**[SWS_CM_10282] Setting the byte order for size of the length field for associative maps** *[*If attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is set this attribute shall define the byte order for the length field that shall be inserted in front of the serialized associative map for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10282] 设置关联映射的长度字段的字节顺序** *[*如果设置了SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder属性，则此属性必须定义在序列化关联映射之前插入的长度字段的字节顺序，其关联映射的ApSomeipTransformationProps由SomeipDataPrototypeTransformationProps.someipTransformationProps定义。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00264] Setting the size of the length field for associative maps** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField is set to a value greater 0 and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is not set, a length field shall be inserted in front of the serialized associative map for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps. someipTransformationProps. -Note that omitting the length field by setting someipTransformationProps.sizeOfArrayLengthField to 0 is only allowed for arrays with static length (i.e., fixed length arrays) though (see also [constr_3447]).*♩ (RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> [SWS_CM_00264] 设置关联映射的长度字段的大小
*如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField被设置为一个大于0的值，而属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField没有被设置，则序列化的关联映射前面应该插入一个长度字段，这个关联映射是通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义的。注意，只有在数组长度是固定的（即固定长度数组）时，才允许通过设置someipTransformationProps.sizeOfArrayLengthField为0来省略长度字段（参见[constr_3447]）。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10283] Setting the byte order for size of the length field for associative maps** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, the attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder shall define the byte order for the length field that shall be inserted in front of the serialized associative map for which the ApSomeipTransformationProps is defined via SomeipDataPrototypeTransformationProps.someipTransformationProps.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10283] 设置大小字节顺序的长度字段的关联映射** *[*如果设置了属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder，而没有设置属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder，则TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder应定义序列化关联映射前插入的长度字段的字节顺序，该关联映射通过SomeipDataPrototypeTransformationProps.someipTransformationProps定义。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10267] Insertion of an associative map length field** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField is not set, a length field of 4 bytes with the data type *uint32* shall be inserted in front of the serialized associative map.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField未设置，且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField也未设置，则应在序列化的关联映射前插入4字节长度字段，数据类型为uint32。♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）


**[SWS_CM_10284] Default byte order for size of the length field for associative maps** *[*If attribute TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder is not set and attribute SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder is not set, a byte order of mostSignificantByteFirst (i.e., big endian) shall be used for the length field that shall be inserted in front of the serialized associative map.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 如果属性TransformationPropsToServiceInterfaceElementMapping.transformationProps.byteOrder未设置，且属性SomeipDataPrototypeTransformationProps.someipTransformationProps.byteOrder未设置，则序列化的关联映射前面的长度字段应使用最高字节优先（即大端）字节顺序。


**[SWS_CM_10264] Size of the associative map length field** *[*If SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField defines the the data type for the length field of an associative map, the data shall be:

> 如果SomeipDataPrototypeTransformationProps.someipTransformationProps.sizeOfArrayLengthField定义了关联映射的长度字段的数据类型，数据应该是：

- *uint8* if sizeOfArrayLengthField equals 1
- *uint16* if sizeOfArrayLengthField equals 2
- *uint32* if sizeOfArrayLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_00265] Datatype for the length field of associative maps** *[*If TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField defines the the data type for the length field of an associative map, the data shall be:

> 如果TransformationPropsToServiceInterfaceElementMapping.transformationProps.sizeOfArrayLengthField定义了关联映射的长度字段的数据类型，则数据应为：

- *uint8* if sizeOfArrayLengthField equals 1
- *uint16* if sizeOfArrayLengthField equals 2
- *uint32* if sizeOfArrayLengthField equals 4

*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10265] Serialization of associative map elements** *[*The individual elements of the associative map shall be serialized as a sequence of key-value pairs without any *additional* intermediate padding. Hereby the key attribute of an element shall be serialized first followed by the value attribute of this element.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10265] 关联映射元素的序列化** *[*关联映射的各个元素应以键值对的序列形式进行序列化，不能有任何其他的填充。其中，元素的键属性应先进行序列化，然后是该元素的值属性。*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


Table [7.2](#_bookmark147) illustrates the serialized form of an example map consisting of 3 elements where each element consists of a key-value pair of type uint16 each. The sizeOfArrayLengthField is set to 4 bytes.

> 表7.2（#_bookmark147）描述了一个由3个元素组成的示例映射的序列化形式，每个元素都包含一个uint16类型的键值对。sizeOfArrayLengthField设置为4个字节。


**Table 7.2: Example of a serialized associative map**


**[SWS_CM_10266] Applicability of mandatory padding after variable length data elements** *[*Any mandatory padding (see [TPS_MANI_03107] and [TPS_MANI_03073]) after variable length data elements (see [[TPS_MANI_03103], [TPS_MANI_03104], [TPS_MANI_03117] and [TPS_MANI_03105]) shall be applied after the serialized key attribute as well as after the value attribute in case the respective attributes is typed by a variable length data type. This requirement does not apply for the serialization of extensible structs and methods.*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)* (see chapter [7.5.1.9.4](#structured-data-types-structs))

> **[SWS_CM_10266] 可变长度数据元素后的强制填充的适用性** *[*根据[TPS_MANI_03107]和[TPS_MANI_03073]中的要求，可变长度数据元素（参见[TPS_MANI_03103]、[TPS_MANI_03104]、[TPS_MANI_03117]和[TPS_MANI_03105]）后的任何强制填充（padding）都应该在序列化的键属性之后以及值属性之后应用，如果相应的属性是由可变长度数据类型类型化的。此要求不适用于可扩展结构体和方法的序列化。*♩（RS_CM_00204，RS_CM_00201，RS_CM_00202，RS_CM_00211）*（参见第7.5.1.9.4节）


Note: Adhering to [[SWS_CM_10266](#_bookmark148)] is essential to ensure interoperability with the AUTOSAR classic platform where maps may be modelled as ApplicationArrayDataType with a dynamicArraySizeProfile of VSA_LINEAR where each array element is an ApplicationRecordDataType of variable length and thus [TPS_SYST_02126] applies to the individual ApplicationRecordElements.

> 注意：遵守[[SWS_CM_10266](#_bookmark148)]至关重要，以确保与AUTOSAR经典平台的互操作性，其中地图可以模拟为具有动态ArraySizeProfile的ApplicationArrayDataType，其中每个数组元素是可变长度的ApplicationRecordDataType，因此[TPS_SYST_02126]适用于单个ApplicationRecordElements。

### Variants


A Variant (type-safe union) can contain different types of elements. For example, if one defines a Variant of type uint8 and type uint16, the Variant shall carry an element of uint8 or uint16. When using different types of elements the alignment of subsequent parameters may be distorted. To resolve this, padding might be needed.

> 一个变体（类型安全的联合）可以包含不同类型的元素。例如，如果定义了一个类型为uint8和uint16的变体，那么变体将携带一个uint8或uint16的元素。当使用不同类型的元素时，随后的参数的对齐可能会被扭曲。为了解决这个问题，可能需要填充。


**[SWS_CM_10088] Serialization layout of Variants** *[*The default serialization layout of Variants are specified by the union data type in SOME/IP which is shown in Table [7.3](#_bookmark151).*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10088] 变量的序列化布局** *[*变量的默认序列化布局由SOME/IP中的联合数据类型指定，可在表[7.3]中查看。*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

**Table 7.3: Default serialization layout of unions (Variants)**


SOME/IP allows to add a length field of 8, 16 or 32 bit in front of unions (Variants). The length field of a union (Variant) describes the number of bytes in the union (Variant).

> SOME/IP允许在联合（变体）前添加8、16或32位的长度字段。联合（变体）的长度字段描述了联合（变体）中字节的数量。


This allows the deserializing network binding to quickly calculate the position where the data after the union (Variant) begin in the serialized data stream. This gets necessary if the union (Variant) contains data which are larger than expected, for example if a struct was extended with appended new members and only the first \"old\" members are deserialized by the SOME/IP network binding.

> 这允许反序列化网络绑定快速计算联合（变体）后的数据在序列化数据流中的位置。如果联合（变体）包含的数据比预期的大，例如如果一个结构被追加新成员扩展，而只有第一个“旧”成员被SOME/IP网络绑定反序列化，则需要这一步。


**[SWS_CM_10254] Variant length field** *[*If attribute sizeOfUnionLengthField of ApSomeipTransformationProps is set to a value greater 0, a length field shall be inserted in front of the serialized Variant for which the ApSomeipTransformationProps is defined.*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10254]变长字段** *[*如果ApSomeipTransformationProps的sizeOfUnionLengthField属性设置为大于0的值，则应在定义ApSomeipTransformationProps的序列化变体之前插入长度字段。*♩（RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10255] Variant length field data type** *[*If ApSomeipTransformationProps.sizeOfUnionLengthField is present for a Variant specified the data type of the length field for the Variant shall be determined by the value of ApSomeipTransformationProps.sizeOfUnionLengthField:

> **[SWS_CM_10255] 变体长度字段数据类型** *[*如果ApSomeipTransformationProps.sizeOfUnionLengthField存在于指定的变体中，则变体的长度字段的数据类型由ApSomeipTransformationProps.sizeOfUnionLengthField的值确定。

- *uint8* if sizeOfUnionLengthField equals 1
- *uint16* if sizeOfUnionLengthField equals 2
- *uint32* if sizeOfUnionLengthField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10226] Serialized Variant size** *[*The serializing SOME/IP network binding shall write the size (in bytes) of the serialized Variant (including padding bytes but without the size of the length field and type field) into the length field of the Variant. This requirement does not apply for the serialization of extensible structs and methods.*♩ (RS_CM_00201, RS_CM_00202, RS_CM_00211)* (see chapter [7.5.1.9.4](#structured-data-types-structs))

> [SWS_CM_10226] 序列化变量大小*[*SOME/IP网络绑定的序列化应将变量的大小（以字节为单位，包括填充字节但不包括长度字段和类型字段的大小）写入变量的长度字段。此要求不适用于可扩展结构和方法的序列化。*♩（RS_CM_00201，RS_CM_00202，RS_CM_00211）*（请参见[7.5.1.9.4]章节（结构数据类型——结构））


**[SWS_CM_10227] Length greater than expected Variant length** *[*If the length is greater than the expected length of a Variant a deserializing SOME/IP network binding shall only interpret the expected data and skip the unexpected.*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10227] 超出预期变体长度** *[*如果长度超出变体的预期长度，反序列化SOME/IP网络绑定只应解释预期数据并跳过意外数据。*♩(RS_CM_00201，RS_CM_00202，RS_CM_00211)*


To determine the start of the next expected data following the skipped unexpected part, the SOME/IP network binding can use the supplied length information.

> 为了确定下一个预期数据的开始位置，在跳过了意外部分后，SOME/IP网络绑定可以使用提供的长度信息。


The type field describes the type of the element. The length of the type field can be 32, 16, 8 or 0 bits.

> 类型字段描述元素的类型。类型字段的长度可以是32、16、8或0位。


**[SWS_CM_10250] Data type for the length field of variants** *[*The data type of the type field of a Variant shall be determined using the ara::core::Variant::index () member function. The Variant template class is specified in [16].*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10250] 变体长度字段的数据类型** *[*变体类型字段的数据类型应使用ara::core::Variant::index（）成员函数确定。 Variant模板类在[16]中指定。*♩（RS_CM_00201，RS_CM_00202，RS_CM_00211）*


**[SWS_CM_10251] Value of the variant type field** *[*The value of the type field shall be set to the value which is returned by the ara::core::Variant::index() member function and incremented by 1.

> [SWS_CM_10251]变量类型字段的值应该设置为ara::core::Variant::index()成员函数返回的值，并加1。


Note: The ara::core::Variant::index() member function returns a zero-based index of the element hold in the Variant. A negative index represents a valueless Variant.*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> 注意：ara::core::Variant::index（）成员函数返回Variant中保存的元素的基于零的索引。负索引表示无价值的Variant。


**[SWS_CM_10098] Possible values of the variant type field** *[*Possible values of the type field are defined by the elements of the Variant. The types are encoded in ascending order starting with 1 reusing the index encoding format of the Variant incremented by 1. The encoded value 0 is reserved for the NULL type i.e. a valueless (empty) Variant.*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10098]变体类型字段的可能值** *[*变体的元素定义了类型字段的可能值。类型以从1开始的升序编码，重用Variant的索引编码格式，每次加1。编码值0保留用于NULL类型，即无值（空）Variant。*♩(RS_CM_00201，RS_CM_00202，RS_CM_00211)*


**[SWS_CM_10099] Serialization of variant types** *[*The element is serialized depending on the type in the type field. This also defines the length of the data. All bytes behind the data that are covered by the length, are padding. The deserializer shall skip the padding bytes by calculating the required number according to the formula given in [[SWS_CM_10088](#_bookmark150)].*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*

> **[SWS_CM_10099] 变量类型的序列化** *[*根据类型字段中的类型对元素进行序列化。这也定义了数据的长度。被长度所覆盖的所有字节均为填充字节。反序列化器应该根据[[SWS_CM_10088](#_bookmark150)] 中给出的公式计算所需的填充字节，并跳过它们。*♩(RS_CM_00201, RS_CM_00202, RS_CM_00211)*


**[SWS_CM_10230]**{DRAFT} **Data type for size of union field** *[*If ApSomeipTransformationProps.sizeOfUnionTypeSelectorField is present for a specified Variant, the data type of the type selector field for the Variant shall be determined by the value of ApSomeipTransformationProps.sizeOfUnionTypeSelectorField:

> **[SWS_CM_10230]**{草案} **联合字段的大小的数据类型** *[*如果ApSomeipTransformationProps.sizeOfUnionTypeSelectorField对于指定的变体存在，则变体的类型选择器字段的数据类型由ApSomeipTransformationProps.sizeOfUnionTypeSelectorField的值确定。

- uint8 if sizeOfUnionTypeSelectorField equals 1
- uint16 if sizeOfUnionTypeSelectorField equals 2
- uint32 if sizeOfUnionTypeSelectorField equals 4

*♩(RS_CM_00204, RS_CM_00201, RS_CM_00202, RS_CM_00211)*

### Example: Variant of uint8/uint16 both padded to 32 bit


In this example a length of the length field is specified as 32 bits. The Variant shall support a uint8 and a uint16 as elements. Both are padded to the 32 bit boundary (length=4 Bytes).

> 在这个例子中，长度字段的长度被指定为32位。变量将支持uint8和uint16作为元素。两者都填充到32位边界（长度=4字节）。

A uint8 will be serialized like this:

### Segmentation of SOME/IP messages


**[SWS_CM_10454] Event message segmentation** *[*If the attribute SomeipEventDeployment.maximumSegmentLength is set to a value, and the data length is larger than maximumSegmentLength, the SOME/IP event message shall be transmitted/received using segmentation as described in [PRS_SOMEIP_00720] and following.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_10454] 事件消息分段** *如果属性SomeipEventDeployment.maximumSegmentLength被设置为一个值，并且数据长度大于maximumSegmentLength，SOME/IP事件消息应按照[PRS_SOMEIP_00720]及其后续描述使用分段传输/接收*♩（RS_SOMEIP_00051）*。


**[SWS_CM_99036] Event message separation time** *[*If attribute SomeipEventDeployment. separationTime is set, and segmentation is activated for the corresponding SOME/IP event message according to [[SWS_CM_10454](#_bookmark154)], the segments shall be separated in time by this value.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_99036] 事件消息分离时间** *如果设置了SomeipEventDeployment. separationTime属性，并根据[[SWS_CM_10454](#_bookmark154)]对相应的SOME/IP事件消息进行了分段，则根据此值将段分开。*♩(RS_SOMEIP_00051)*


**[SWS_CM_10455] Method request message segmentation** *[*If the attribute SomeipMethodDeployment.maximumSegmentLengthRequest is set to a value, and the data length is larger than maximumSegmentLengthRequest, the SOME/IP request message shall be transmitted/received using segmentation as described in [PRS_SOMEIP_00720] and following.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_10455] 请求消息分段方法** *如果SomeipMethodDeployment.maximumSegmentLengthRequest属性设置了一个值，而数据长度大于maximumSegmentLengthRequest，SOME/IP请求消息应按照[PRS_SOMEIP_00720]及其后续内容使用分段传输/接收。*♩(RS_SOMEIP_00051)*


**[SWS_CM_99037] Method request message separation time** *[*If attribute SomeipMethodDeployment. separationTimeRequest is set, and segmentation is activated for the corresponding SOME/IP method request message according to [[SWS_CM_10455](#_bookmark155)], the segments shall be separated in time by this value.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_99037] 方法请求消息分离时间** *[*如果设置了SomeipMethodDeployment.separationTimeRequest属性，并根据[[SWS_CM_10455](#_bookmark155)]对相应的SOME/IP方法请求消息进行了分段，则段之间应按照此值进行时间分离。*♩(RS_SOMEIP_00051)*


**[SWS_CM_99038] Method response message segmentation** *[*If the attribute SomeipMethodDeployment.maximumSegmentLengthResponse is set to a value, and the data length is larger than maximumSegmentLengthResponse, the SOME/IP response message shall be transmitted/received using segmentation as described in [PRS_SOMEIP_00720] and following.*♩(RS_SOMEIP_00051)*

> 如果SomeipMethodDeployment.maximumSegmentLengthResponse属性设置了一个值，而数据长度大于maximumSegmentLengthResponse，则SOME/IP响应消息应按照[PRS_SOMEIP_00720]及其后续内容使用分段传输/接收。♩（RS_SOMEIP_00051）


**[SWS_CM_99039] Method response message separation time** *[*If attribute SomeipMethodDeployment. separationTimeResponse is set, and segmentation is activated for the corresponding SOME/IP method response message according to [[SWS_CM_99038](#_bookmark156)], the segments shall be separated in time by this value.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_99039] 方法响应消息分离时间** *如果设置了SomeipMethodDeployment.separationTimeResponse属性，并根据[[SWS_CM_99038](#_bookmark156)]对相应的SOME/IP方法响应消息进行分段，则各段必须按此值分离时间。*♩(RS_SOMEIP_00051)


**[SWS_CM_10456] Message segmentation for the get and set methods of fields** *[*For the get and set methods aggregated by a SomeipFieldDeployment [[SWS_CM_10455](#_bookmark155)] shall apply. For the notifier aggregated by a SomeipFieldDeployment [[SWS_CM_10454](#_bookmark154)] shall apply.*♩(RS_SOMEIP_00051)*

> 对于由SomeipFieldDeployment聚合的get和set方法，应该应用[[SWS_CM_10455](#_bookmark155)]。对于由SomeipFieldDeployment聚合的通知者，应该应用[[SWS_CM_10454](#_bookmark154)]。（RS_SOMEIP_00051）


**[SWS_CM_10457] Small messages segmentation** *[*For messages that would fit into one segment no segmentation (i.e. no TP-Header) shall be applied.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_10457] 小型消息分段** *[*如果消息可以放入一个段中，则不应应用分段（即不应应用TP-Header）。*♩（RS_SOMEIP_00051）*


**[SWS_CM_10445]**{DRAFT} **SomeIpBurstTransmission** *[*If parameter SomeipEventDeployment.burstSize, SomeipMethodDeployment.burstSizeRequest or SomeipMethodDeployment.burstSizeResponse is set to a value \> 1 and the corresponding message is segmented no separationTime shall be applied for this number of segments. If not configured, SeparationTime will be applied between all frames.*♩(RS_SOMEIP_00051)*

> **[SWS_CM_10445]**{草稿} **SomeIpBurstTransmission** *[*如果SomeipEventDeployment.burstSize、SomeipMethodDeployment.burstSizeRequest或SomeipMethodDeployment.burstSizeResponse的参数设置为一个值>1，且相应的消息被分割，则不会为这些分割的段应用SeparationTime。如果没有配置，SeparationTime将应用于所有帧之间。♩(RS_SOMEIP_00051)*


Note: If burstSize is set on receiver side it can be used to optimize buffer handling for reception of bursts.

> 注意：如果在接收端设置burstSize，可以用来优化接收突发数据时的缓冲处理。

### Marker Interface


On the AUTOSAR adaptive platform there are use-cases for the utilization of a ServiceInterface that does not have any method, event, or field defined. In other words, the existence of a ServiceInterface by itself represents a valid semantics that has a value on its own.

> 在AUTOSAR自适应平台上，有一些使用案例，可以利用没有定义任何方法、事件或字段的服务接口。换句话说，仅有服务接口本身就代表了有自身价值的有效语义。


A service instance that corresponds to such a ServiceInterface may be offered with the mere intention to signal that the ECU that provides the service instance is becoming ready for something. So the SOME/IP Service Discovery mechanism is used to indicate the readiness. But for the communication not SOME/IP but a different protocol will be used.

> 一个对应这样一个ServiceInterface的服务实例可能仅仅以表明提供服务实例的ECU正准备好做某事的意图提供。因此，SOME/IP服务发现机制被用于表明准备就绪。但是，通信不是SOME/IP，而是使用不同的协议。


For example an ECU may indicate with a service offer that it is ready to being diagnosed. A tester could then take the existence of the offer as an indication to initiate a connection to the respective ECU.

> 例如，ECU可以通过提供服务来指示它已准备好进行诊断。检测员可以把这种提供作为建立与相应ECU的连接的指示。

