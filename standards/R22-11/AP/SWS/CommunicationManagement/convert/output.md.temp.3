---
tip: translate by openai@2023-06-24 15:30:24
...

**[SWS_CM_90202]**{DRAFT} **Using TLS and DTLS secure channels in the DDS Network Binding** *[*Secure channels shall be used as specified in [[SWS_CM_90102](#_bookmark300)]._♩ (RS_CM_00801, RS_CM_00803)_

> **[SWS_CM_90202]**{草稿} **在DDS网络绑定中使用TLS和DTLS安全通道** *[*必须按照[[SWS_CM_90102](#_bookmark300)]中的指定使用安全通道。_♩ (RS_CM_00801, RS_CM_00803)_*

### Raw data streaming


**[SWS_CM_90211] Secure UDP and TCP channel creation for TLS and DTLS** *[*The Communication Management software shall create secure UDP and TCP channels according to the input for all TlsSecureComProps as part of the EthernetRawDataStreamMapping._♩(RS_CM_00801)_

> 通信管理软件根据EthernetRawDataStreamMapping中的输入，为所有TlsSecureComProps创建安全的UDP和TCP通道。


**[SWS_CM_90212] Using secure TLS, DTLS channels** *[*All communication triggered by a RawDataStream shall be sent via the respective secure channel according to the input. The appropriate secure channel is defined in the TlsSecureComProps as part of the EthernetRawDataStreamMapping that is mapped to an EthernetCommunicationConnector._♩(RS_CM_00801, RS_CM_00803)_

> **[SWS_CM_90212] 使用安全的TLS，DTLS通道** *[*由RawDataStream触发的所有通信都应根据输入通过相应的安全通道发送。适当的安全通道在TlsSecureComProps中定义，作为映射到EthernetCommunicationConnector的EthernetRawDataStreamMapping的一部分。_♩(RS_CM_00801, RS_CM_00803)_

### (D)TLS


A (D)TLS secure channel may provide authenticity, integrity and confidentiality which may be used on combination with SOME/IP and DDS network binding as well as with raw data streaming.

> 一个（D）TLS安全通道可以提供真实性、完整性和保密性，可以与SOME/IP和DDS网络绑定以及原始数据流一起使用。


The TLS and DTLS implementation should support the following cipher suites:

> TLS 和 DTLS 实现应支持以下密码套件：

- TLS_PSK_WITH_NULL_SHA256 for authentic communication (see [RFC5487])
- TLS_PSK_WITH_AES_128_GCM_SHA256 for confidential communication (see [RFC5487])

  1. ### SOME/IP Network binding


**[SWS_CM_90103]**{DRAFT} **TLS secure channel for ServiceInterface content using reliable transport** *[*A TLS secure channel shall be created and used if a TlsSecureComProps instance is referenced in the role secureComPropsForTcp by a ServiceInstanceToMachineMapping. All content of the ServiceInterface that is referenced by the AdaptivePlatformServiceInstance that in turn is referenced by the ServiceInstanceToMachineMapping that is configured for transmission over "tcp" in the ServiceInterfaceDeployment is selected for transmission over the TLS secured channel._♩(RS_CM_00801)_

> **[SWS_CM_90103]**{草稿} **使用可靠传输的服务接口内容的TLS安全通道** *[*如果TlsSecureComProps实例被角色secureComPropsForTcp引用，则应创建并使用TLS安全通道。 通过ServiceInstanceToMachineMapping配置为“tcp”传输的ServiceInterfaceDeployment中引用的AdaptivePlatformServiceInstance所引用的服务接口的所有内容均选择传输至TLS安全通道。_♩（RS_CM_00801）_


**[SWS_CM_90104]**{DRAFT} **DTLS secure channel for ServiceInterface content using unreliable transport** *[*A DTLS secure channel shall be created and used if a TlsSecureComProps instance is referenced in the role secureComPropsForUdp by a ServiceInstanceToMachineMapping. All content of the ServiceInterface that is referenced by the AdaptivePlatformServiceInstance that in turn is referenced by the ServiceInstanceToMachineMapping that is configured for transmission over "udp" in the ServiceInterfaceDeployment is selected for transmission over the TLS secured channel._♩(RS_CM_00801)_

> **[SWS_CM_90104]**{草稿} **使用不可靠传输的服务接口内容的DTLS安全通道** *[*如果在角色secureComPropsForUdp中引用了TlsSecureComProps实例，则应创建并使用DTLS安全通道。 选择由ServiceInstanceToMachineMapping配置为在ServiceInterfaceDeployment中使用“udp”传输的AdaptivePlatformServiceInstance引用的所有服务接口内容以进行TLS安全通道传输。_♩（RS_CM_00801）_


**[SWS_CM_90121]**{DRAFT} **TLS server role of a Skeleton** *[*The TLS secure channel shall be associated with the respective [Skeleton](#_bookmark5) and the implementation shall act as a TLS server, if the AdaptivePlatformServiceInstance referenced in

> **[SWS_CM_90121]**{草案} **骨架的TLS服务器角色** *[*TLS安全通道应与相应的[骨架](#_bookmark5)相关联，实现应充当TLS服务器，如果在AdaptivePlatformServiceInstance中引用

- [[SWS_CM_90103](#_bookmark305)]
- [[SWS_CM_90104](#_bookmark306)]

is a ProvidedApServiceInstance._♩(RS_CM_00801)_


According to the constraints [constr_3485] and [constr_3486] a [Proxy](#_bookmark6) and [Skeleton](#_bookmark5) cannot be bound to the identical local endpoint (IP address and port). Hence, a local endpoint can either act as a TLS client or as a TLS server exclusively. However, if multiple [Proxys](#_bookmark6) are bound to the same endpoint, their common channel shall be shared in the middleware. Likewise, if multiple [Skeletons](#_bookmark5) are bound to the same endpoint, their common channel shall be shared in the middleware.

> 根据约束[constr_3485]和[constr_3486]，代理（#_bookmark6）和骨架（#_bookmark5）不能绑定到相同的本地端口（IP地址和端口）。因此，本地端口只能作为TLS客户端或TLS服务器专门使用。但是，如果多个代理（#_bookmark6）绑定到相同的端口，它们的公共信道将在中间件中共享。同样，如果多个骨架（#_bookmark5）绑定到相同的端口，它们的公共信道将在中间件中共享。


**[SWS_CM_90119]**{DRAFT} **Behavior of a creating ServiceProxy over TLS or DTLS** *[*The instantiation according to [[SWS_CM_00131](#_bookmark557)] shall trigger the asynchronous handshake._♩(RS_CM_00804)_

> **[SWS_CM_90119]**{草案} **建立TLS或DTLS服务代理的行为** *[*根据[[SWS_CM_00131](#_bookmark557)]的实例化应触发异步握手。_♩(RS_CM_00804)_


**[SWS_CM_90111]**{DRAFT} **Behavior of a ServiceProxy over TLS before successful completion of the handshake** *[*The communication channel is ready as soon as the TLS handshake is completed.

> **[SWS_CM_90111]**{草案} **TLS握手完成前服务代理的行为** *[*TLS握手完成后，通信信道就准备就绪了。


Therefore, the future returned by the following methods shall only be satisfied after the handshake has finished and once the communication was successful:

> 因此，以下方法返回的未来只有在握手完成并且通信成功后才能得到满足：


- the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)])

> 调用相应方法类的函数调用运算符（operator()）（参见[[SWS_CM_00196](#_bookmark586)）
- the Set() method of the respective Field class (see [[SWS_CM_00113](#_bookmark591)])
- the Get() method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)])


If the handshake fails, the error code ComErrc::kPeerIsUnreachable shall be returned in the Future of the respective methods (operator(), Set(), Get()). The error shall be logged._♩(RS_CM_00804)_

> 如果握手失败，则会在相应方法（operator()，Set()，Get()）的Future中返回错误代码ComErrc::kPeerIsUnreachable。此错误将会被记录。♩(RS_CM_00804)


**[SWS_CM_90112]**{DRAFT} **Behavior of a ServiceProxy over DTLS before successful completion of the handshake** *[*The communication channel is ready as soon as the DTLS handshake is completed. Before completion the middleware shall drop all requests as if the remote peer is unreachable._♩(RS_CM_00804)_

> **[SWS_CM_90112]**{草案} **DTLS 握手成功前服务代理的行为** *[*一旦 DTLS 握手完成，通信通道就会准备就绪。在完成之前，中间件会像远程对等体不可达一样丢弃所有请求。_♩（RS_CM_00804）_


The rationale for choosing different behavior in [[SWS_CM_90111](#_bookmark307)] and [[SWS_CM_90112](#_bookmark308)] is to reflect the nature of the underlying transport. E.g. plain UDP would also silently discard packets that cannot be sent, where TCP would report an error.

> 选择[[SWS_CM_90111](#_bookmark307)]和[[SWS_CM_90112](#_bookmark308)]中不同行为的理由是反映底层传输的本质。例如，普通UDP也会静默丢弃无法发送的数据包，而TCP会报告错误。


**[SWS_CM_90113]**{DRAFT} **Behavior of a ServiceSkeleton over TLS before successful completion of the handshake** *[*The communication channel is ready as soon as the TLS handshake is completed. Therefore, [[SWS_CM_10287](#_bookmark56)] and [[SWS_CM_10319](#_bookmark97)] shall be extended to checking whether the TLS handshake did successfully finish.

> **[SWS_CM_90113]**{草案} **TLS握手成功前服务骨架的行为** *[*TLS握手成功后，通信信道就准备就绪了。因此，[[SWS_CM_10287](#_bookmark56)]和[[SWS_CM_10319](#_bookmark97)]应该延伸到检查TLS握手是否成功完成。


Therefore, as if the proxy was not connected, the invocation of the following methods shall not result in sending any data:

> 因此，如果代理未连接，调用以下方法将不会发送任何数据。


- the Send() method of the respective Event class (see [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)])

> 请使用相应事件类的Send()方法（参见[[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)])
- the Send() method of the respective Trigger class (see [[SWS_CM_00721](#_bookmark535)])
- the Update() method of the respective Field class (see [[SWS_CM_00119](#_bookmark548)])

_♩(RS_CM_00804)_


**[SWS_CM_90114]**{DRAFT} **Behavior of a ServiceSkeleton over DTLS before successful completion of the handshake** *[*The communication channel is ready as soon as the TLS handshake is completed. Therefore, [[SWS_CM_10287](#_bookmark56)] and [[SWS_CM_10319](#_bookmark97)] shall be extended to checking whether the TLS handshake did successfully finish.

> **[SWS_CM_90114]**{草案} **DTLS握手前服务骨架的行为** *[*TLS握手完成后，通信信道就准备就绪。因此，[[SWS_CM_10287](#_bookmark56)]和[[SWS_CM_10319](#_bookmark97)]应延伸到检查TLS握手是否成功完成。


Therefore, as if the proxy was not connected, the invocation of the following methods shall not result in sending any data:

> 因此，就像代理没有连接一样，调用以下方法不会导致发送任何数据。


- the Send() method of the respective Event class (see [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)])

> - 相应事件类的Send（）方法（参见[[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)])
- the Send() method of the respective Trigger class (see [[SWS_CM_00721](#_bookmark535)])
- the Update() method of the respective Field class (see [[SWS_CM_00119](#_bookmark548)])

_♩(RS_CM_00804)_

### DDS Network Binding (secure transports)


DDS is built upon the Real-Time Publish-Subscribe (RTPS) wire protocol, which allows different implementations of the standard to interoperate at the wire level. The DDSRTPS specification [19] defines the wire protocol using a Model Driven Architecture; i.e., in terms of a Platform-Independent Model (PIM), which can be mapped to Platform Specific Models (PSM) targeting different transport protocols. In particular, [19] defines a UDP PSM, and different DDS vendors have implemented TCP PSMs[15](#_bookmark313), and Shared Memory PSMs for Inter-Process Communication (IPC).

> DDS建立在实时发布订阅（RTPS）线路协议之上，该协议允许标准的不同实现在线路层面互操作。DDSRTPS规范[19]使用模型驱动架构定义线路协议，即以平台无关模型（PIM）的形式，可以映射到针对不同传输协议的平台特定模型（PSM）。特别是[19]定义了一个UDP PSM，不同的DDS供应商实现了TCP PSM[15](#_bookmark313)和用于进程间通信（IPC）的共享内存PSM。


For consistency with the secure channel modeling and secure communication mechanisms specified in [7.6.2.2.1](#someip-network-binding-1), this section defines support for communication over the following security protocols:

> 根据[7.6.2.2.1](#someip-network-binding-1)中指定的安全通道建模和安全通信机制，本节定义支持以下安全协议进行通信：

- DTLS, for secure communication over UDP.
- TLS, for secure communication over TCP.
- IPSec, for secure communication over IP.


**[SWS_CM_90203]**{DRAFT} **TLS secure channel for methods using reliable transport** *[*A TLS secure channel shall be created and used if:

> **[SWS_CM_90203]**{草案} **使用可靠传输的方法创建TLS安全通道** *[*如果：应该创建并使用TLS安全通道：


- a TlsSecureComProps instance is referenced in the role secureComPropsForTcp by a ServiceInstanceToMachineMapping and a method of the AdaptivePlatformServiceInstance is selected for transmission over the secure channel by the ServiceInterfaceElementSecureComConfig and this method is configured for transmission over "tcp" by transportProtocol in the associated DdsServiceInterfaceDeployment.

> 一个TlsSecureComProps实例被引用在role secureComPropsForTcp中，通过ServiceInstanceToMachineMapping选择AdaptivePlatformServiceInstance的一个方法通过ServiceInterfaceElementSecureComConfig进行安全通道传输，该方法被配置为通过与之关联的DdsServiceInterfaceDeployment的transportProtocol进行“tcp”传输。


The DataReaders and DataWriters associated with the method shall be configured to operate over TLS._♩(RS_CM_00801)_

> 数据读取器和数据写入器与该方法相关联的应配置为使用TLS进行操作。（RS_CM_00801）


**[SWS_CM_90204]**{DRAFT} **DTLS secure channel for methods using unreliable transport** *[*A DTLS secure channel shall be created and used if:

> **[SWS_CM_90204]**{草案} **使用不可靠运输的方法的DTLS安全通道** *[*如果：应该创建和使用DTLS安全通道。


- a TlsSecureComProps instance is referenced in the role secureComPropsForUdp by a ServiceInstanceToMachineMapping and a method of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this method is configured for transmission over "udp" by transportProtocol in the associated DdsServiceInterfaceDeployment.

> 一个TlsSecureComProps实例被引用在角色secureComPropsForUdp中，由ServiceInstanceToMachineMapping和AdaptivePlatformServiceInstance的一个方法被ServiceInterfaceElementSecureComConfig选择用于通过安全通道传输，这个方法被配置用于通过相关联的DdsServiceInterfaceDeployment的传输协议“udp”传输。


The DataReaders and DataWriters associated with the method shall be configured to operate over DTLS._♩(RS_CM_00801)_

> 数据读取器和数据写入器与该方法相关联的应配置为通过DTLS运行。（RS_CM_00801）


**[SWS_CM_90205]**{DRAFT} **TLS secure channel for events using reliable transport** *[*A TLS secure channel shall be created and used if:

> **[SWS_CM_90205]**{草案} **使用可靠传输的事件的TLS安全通道** *[*如果：应该创建并使用TLS安全通道


15A standard TCP PSM for DDS-RTPS is under development, the RFP document is publicly available at the Object Management Group website: [https://www.omg.org/cgi-bin/doc.cgi?mars/](https://www.omg.org/cgi-bin/doc.cgi?mars/2017-9-24) [2017-9-24](https://www.omg.org/cgi-bin/doc.cgi?mars/2017-9-24).

> 正在开发DDS-RTPS的15A标准TCP PSM，RFP文档可在Object Management Group网站上公开获取：[https://www.omg.org/cgi-bin/doc.cgi?mars/](https://www.omg.org/cgi-bin/doc.cgi?mars/) [2017-9-24](https://www.omg.org/cgi-bin/doc.cgi?mars/2017-9-24)。


- A TlsSecureComProps instance is referenced in the role secureComPropsForTcp by a ServiceInstanceToMachineMapping and an event of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this event is configured for transmission over "tcp" by transportProtocol in the associated DdsEventDeployment.

> 一个TlsSecureComProps实例被引用在角色secureComPropsForTcp中，由ServiceInstanceToMachineMapping选择一个AdaptivePlatformServiceInstance的事件由ServiceInterfaceElementSecureComConfig传输到安全通道，这个事件被配置用"tcp"协议在关联的DdsEventDeployment中传输。


The DataReaders and DataWriters associated with the event shall be configured to operate over TLS._♩(RS_CM_00801)_

> 数据读取器和数据写入器与事件相关联的应该配置为通过TLS进行操作。


**[SWS_CM_90206]**{DRAFT} **DTLS secure channel for events using unreliable transport** *[*A DTLS secure channel shall be created and used if:

> **[SWS_CM_90206]**{草案} **使用不可靠传输的事件的DTLS安全通道** *[*如果：将创建并使用DTLS安全通道：


- a TlsSecureComProps instance is referenced in the role secureComPropsForUdp by a ServiceInstanceToMachineMapping and an event of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this event is configured for transmission over "udp" by transportProtocol in the associated DdsEventDeployment.

> 一个TlsSecureComProps实例被引用在角色secureComPropsForUdp中，由ServiceInstanceToMachineMapping选择AdaptivePlatformServiceInstance的事件，由ServiceInterfaceElementSecureComConfig配置这个事件通过安全通道进行传输，并且这个事件被配置为通过关联的DdsEventDeployment中的transportProtocol进行"udp"传输。


The DataReaders and DataWriters associated with the event shall be configured to operate over DTLS._♩(RS_CM_00801)_

> 数据读取器和数据写入器与事件相关联的应配置为通过DTLS运行。（RS_CM_00801）


**[SWS_CM_90207]**{DRAFT} **TLS secure channel for fields** *[*The requirements [[SWS_CM_90203](#_bookmark310)], [[SWS_CM_90204](#_bookmark311)], [[SWS_CM_90205](#_bookmark312)] and [[SWS_CM_90206](#_bookmark314)] ap-

> **[SWS_CM_90207]**{草稿} **字段的TLS安全通道** *[*要求[[SWS_CM_90203](#_bookmark310)], [[SWS_CM_90204](#_bookmark311)], [[SWS_CM_90205](#_bookmark312)]和[[SWS_CM_90206](#_bookmark314)]应用程序。


ply to fields in the same manner, since fields are a composition of methods and

> 對欄位以同樣的方式進行操作，因為欄位是方法的組合。

events._♩(RS_CM_00801)_


**[SWS_CM_90209]**{DRAFT} **IPsec secure channel between communication nodes and Transport of Service communication over an IPsec security association** *[*An IPsec secure channel shall be created and used according to the requirements and constraints specified in [[SWS_CM_90117](#_bookmark333)] and [[SWS_CM_90118](#_bookmark334)]._♩(RS_CM_00801)_

> **[SWS_CM_90209]**{草案} **在IPsec安全关联之间的通信节点和服务通信的传输之间建立IPsec安全通道** *[*根据[[SWS_CM_90117](#_bookmark333)]和[[SWS_CM_90118](#_bookmark334)]中指定的要求和约束，应建立并使用IPsec安全通道。_♩(RS_CM_00801)_*

简体中文：**[SWS_CM_90209]**{草案} **在IPsec安全关联之间建立IPsec安全通道，用于通信节点和服务通信的传输** *[*根据[[SWS_CM_90117](#_bookmark333)]和[[SWS_CM_90118](#_bookmark334)]中指定的要求和约束，应建立并使用IPsec安全通道。_♩(RS_CM_00801)_*

### Raw Data Streaming


Raw Data Stream communication can be transported via TCP and UDP. Therefore different security mechanism have to be available to secure the stream communication. The following security protocols are currently supported:

> 原始数据流通信可以通过TCP和UDP传输。因此，需要提供不同的安全机制来保护流通信。目前支持的安全协议有：

- TLS
- DTLS
- IPSec


**[SWS_CM_90213] TLS secure channel for raw data streams using reliable transport** *[*A TLS secure channel shall be created and used if

> **[SWS_CM_90213] 使用可靠传输的原始数据流创建TLS安全通道** *[*如果需要，应该创建并使用TLS安全通道。


- a TlsSecureComProps instance is part of a EthernetRawDataStreamMapping and is configured for transmission over "tcp" by assigning a localTcpPort in the EthernetRawDataStreamMapping

> 一个TlsSecureComProps实例是EthernetRawDataStreamMapping的一部分，并通过在EthernetRawDataStreamMapping中分配本地TcpPort来配置通过“tcp”传输。

_♩(RS_CM_00801)_

### [SWS_CM_90214] DTLS secure channel for methods using unreliable transport

*[*A DTLS secure channel shall be created and used if:


- a TlsSecureComProps instance is part of a EthernetRawDataStreamMapping and is configured for transmission over "udp" by assigning a localUdpPort in the EthernetRawDataStreamMapping

> 一个TlsSecureComProps实例是EthernetRawDataStreamMapping的一部分，通过在EthernetRawDataStreamMapping中分配本地UdpPort来配置通过“udp”传输。

_♩(RS_CM_00801)_


**[SWS_CM_90215] IPsec secure channel between communication nodes and Transport of Raw Data Stream communication over an IPsec security association** *[*An IPsec secure channel shall be created and used according to the requirements and constraints specified in [[SWS_CM_90117](#_bookmark333)] and [[SWS_CM_90118](#_bookmark334)], but applying the EthernetRawDataStreamMapping to map to the EthernetCommunicationConnector._♩(RS_CM_00801)_

> 在[[SWS_CM_90117](#_bookmark333)]和[[SWS_CM_90118](#_bookmark334)]中指定的要求和限制的基础上，应建立和使用IPsec安全通道，并应用EthernetRawDataStreamMapping将其映射到EthernetCommunicationConnector。♩（RS_CM_00801）

### SecOC


The Secure Onboard Communication (SecOC) feature is embedded into the Adaptive Communication Management. The behavioral aspects of the SecOC protocol are specified in the _PRS_SecOcProtocolSpecification_.

> 安全机载通信（SecOC）功能已嵌入至自适应通信管理中。SecOC协议的行为方面的规范被指定在_PRS_SecOcProtocolSpecification_文件中。


One major goal is to achieve interoperability with the AUTOSAR Classic Platform _SecOC_ functionality. This is especially applicable to the usage of _UDP multicast_ messages (where SecOC is currently the only protocol supported) and secured signalbased communication with AUTOSAR Classic Platform through the signal-based network binding.

> 一个主要目标是实现与AUTOSAR Classic Platform _SecOC_功能的互操作性。这特别适用于使用_UDP多播_消息（其中SecOC目前是唯一支持的协议）以及通过信号网络绑定与AUTOSAR Classic Platform之间的安全信号通信。

The SecOC secure channel may provide authenticity and integrity.

**Figure 7.20: SecOC embedded in the Adaptive Communication Management**


In order to achieve interoperability with the AUTOSAR Classic Platform the SecOC should be applied identically also in Adaptive Communication Management. The authentication information comprises of an Authenticator (e.g. Message Authentication Code) and optionally a Freshness Value.

> 为了实现与AUTOSAR Classic平台的互操作性，SecOC也应在Adaptive Communication Management中相同地应用。身份验证信息包括认证器（例如消息认证码）和可选的新鲜值。


The SOME/IP Message Header as shown in figure [7.21](#_bookmark317) divided into two parts: Part I containing the Message ID and the Length and Part II containing Request ID, Protocol Version, Interface Version, Message Type and Return Code(SOME/IP Protocol Specification [5]).

> 图7.21中所示的SOME/IP消息头可分为两部分：第一部分包含消息ID和长度，第二部分包含请求ID、协议版本、接口版本、消息类型和返回码（SOME/IP协议规范[5]）。

bit offset

**Figure 7.21:** **SOME/IP header structure**


In figure [7.23](#_bookmark319) the handling of the SOME/IP payload, the SecOC part, and the SOME/IP Message Header are illustrated. This setup is defined by the AUTOSAR Classic platform. In order to achieve interoperability the Communication Management shall implement an identical behavior. It is essential that the Part I of the SOME/IP Message header is NOT covered by the SecOC calculation.

> 在图7.23中，SOME / IP有效载荷、SecOC部分和SOME / IP消息头的处理方式被说明。此设置由AUTOSAR Classic平台定义。为了实现互操作性，通信管理应实施相同的行为。重要的是，SOME / IP消息头的第一部分不受SecOC计算的影响。


To keep the interoperability with the AUTOSAR Classic Platform and provide the optional Freshness Value Management functionality the Adaptive Communication Management will rely on a pluggable Freshness Value Management Library.

> 为了保持与AUTOSAR经典平台的互操作性，并提供可选的新鲜值管理功能，自适应通信管理将依赖于可插拔的新鲜值管理库。

![](./media/image35.jpeg){width="4.22128937007874in" height="3.011874453193351in"}

**Figure 7.22: Freshness Value Management Pluggable Library**


This library will provide the Freshness Value Management API comprising the replica of the AUTOSAR Classic Platform _FreshnessManagement_ Client Server Interface and corresponding functions of the _Callout Definitions_.

> 这个库将提供新鲜度值管理API，包括AUTOSAR Classic Platform _FreshnessManagement_ 客户端服务器接口的复制和相应的_Callout Definitions_ 功能。

### SOME/IP network binding

**Figure 7.23:** **Payload covered by SecOC and SOME/IP transport**


**[SWS_CM_90108]**{DRAFT} **SecOC secure channel for methods using reliable transport** *[*A SecOC secure channel shall be created and used if:

> **[SWS_CM_90108]**{草案} **SecOC安全通道用于使用可靠传输的方法** *[*如果满足以下条件，将创建并使用SecOC安全通道：


- A SecOcSecureComProps instance is referenced in the role secureComPropsForTcp by a ServiceInstanceToMachineMapping and a method of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this method of the AdaptivePlatformServiceInstance is configured for transmission over "tcp" by transportProtocol in the associated SomeipMethodDeployment.

> 一个SecOcSecureComProps实例被role secureComPropsForTcp引用，一个AdaptivePlatformServiceInstance的方法被ServiceInterfaceElementSecureComConfig选择用于通过安全通道传输，这个AdaptivePlatformServiceInstance的方法被配置用于通过transportProtocol在关联的SomeipMethodDeployment中通过“TCP”传输。

_♩(RS_CM_00801)_


**[SWS_CM_90115]**{DRAFT} **SecOC secure channel for methods using unreliable transport** *[*A SecOC secure channel shall be created and used if:

> **[SWS_CM_90115]**{草案} **SecOC安全通道用于使用不可靠传输的方法** *[*如果：应该创建并使用SecOC安全通道


- A SecOcSecureComProps instance is referenced in the role secureComPropsForUdp by a ServiceInstanceToMachineMapping and a method of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this method of the AdaptivePlatformServiceInstance is configured for transmission over "udp" by transportProtocol in the associated SomeipMethodDeployment.

> 一个SecOcSecureComProps实例被role secureComPropsForUdp中的ServiceInstanceToMachineMapping引用，AdaptivePlatformServiceInstance的一个方法被ServiceInterfaceElementSecureComConfig选择用于通过安全通道传输，该AdaptivePlatformServiceInstance的方法被配置用于通过关联的SomeipMethodDeployment的transportProtocol传输“udp”。

_♩(RS_CM_00801)_


**[SWS_CM_90109]**{DRAFT} **SecOC secure channel for events and triggers using reliable transport** *[*A SecOC secure channel shall be created and used if:

> **[SWS_CM_90109]**{草案} **使用可靠传输的事件和触发器的SecOC安全通道** *[*如果：应该创建并使用SecOC安全通道：


- A SecOcSecureComProps instance is referenced in the role secureComPropsForTcp by a ServiceInstanceToMachineMapping and an event or trigger of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this event or trigger of the AdaptivePlatformServiceInstance is configured for transmission over "tcp" by transportProtocol in the associated SomeipEventDeployment.

> 一个SecOcSecureComProps实例被role secureComPropsForTcp通过ServiceInstanceToMachineMapping引用，AdaptivePlatformServiceInstance的事件或触发器被ServiceInterfaceElementSecureComConfig选择用安全通道传输，并且这个AdaptivePlatformServiceInstance的事件或触发器被配置用transportProtocol在相关的SomeipEventDeployment中通过“tcp”传输。

_♩(RS_CM_00801)_


**[SWS_CM_90116]**{DRAFT} **SecOC secure channel for events and triggers using unreliable transport** *[*A SecOC secure channel shall be created and used if:

> **[SWS_CM_90116]**{草稿} **使用不可靠传输的事件和触发器的SecOC安全通道** *[*如果：应该创建并使用SecOC安全通道：


- A SecOcSecureComProps instance is referenced in the role secureComPropsForUdp by a ServiceInstanceToMachineMapping and an event or trigger of the AdaptivePlatformServiceInstance is selected for transmission over the secured channel by the ServiceInterfaceElementSecureComConfig and this event or trigger of the AdaptivePlatformServiceInstance is configured for transmission over "udp" by transportProtocol in the associated SomeipEventDeployment.

> 一个SecOcSecureComProps实例被ServiceInstanceToMachineMapping引用，在role secureComPropsForUdp中，AdaptivePlatformServiceInstance的事件或触发器被ServiceInterfaceElementSecureComConfig选择用于通过安全通道传输，这个AdaptivePlatformServiceInstance的事件或触发器被配置用于通过相关的SomeipEventDeployment中的传输协议"udp"进行传输。

_♩(RS_CM_00801)_


**[SWS_CM_90110]**{DRAFT} **SecOC secure channel for fields** *[*The requirements [[SWS_CM_90108](#_bookmark320)], [[SWS_CM_90109](#_bookmark322)], [[SWS_CM_90115](#_bookmark321)], [[SWS_CM_90116](#_bookmark323)] apply

> **[SWS_CM_90110]**{草案} **有效保护字段的SecOC安全通道** *[*该要求[[SWS_CM_90108](#_bookmark320)], [[SWS_CM_90109](#_bookmark322)], [[SWS_CM_90115](#_bookmark321)], [[SWS_CM_90116](#_bookmark323)] 应用


to fields in the same manner, since fields are a composition of methods and events._♩_

> 以同样的方式对字段进行操作，因为字段是方法和事件的组合。

_(RS_CM_00801)_


**[SWS_CM_11271]**{DRAFT} **SecOC secure channel behavior** *[*Whenever a SecOC secure channel interaction is detected (based on the configuration options of [[SWS_CM_90108](#_bookmark320)], [[SWS_CM_90115](#_bookmark321)], [[SWS_CM_90109](#_bookmark322)], [[SWS_CM_90116](#_bookmark323)], and

> **[SWS_CM_11271]**{草案} **SecOC 安全通道行为** *[*每当检测到SecOC安全通道交互（基于[[SWS_CM_90108]（#_bookmark320）、[[SWS_CM_90115]（#_bookmark321）、[[SWS_CM_90109]（#_bookmark322）、[[SWS_CM_90116]（#_bookmark323）的配置选项），


[[SWS_CM_90110](#_bookmark324)]) the SecOC functionality shall be applied according to:

> SecOC功能应按照[[SWS_CM_90110](#_bookmark324)]]进行应用

- sending according to [[SWS_CM_11274](#_bookmark325)], [[SWS_CM_11275](#_bookmark326)]
- reception according to [[SWS_CM_11276](#_bookmark327)], [[SWS_CM_11277](#_bookmark328)]

_♩(RS_CM_00801)_


**[SWS_CM_11272]**{DRAFT} **Lifecycle management of FVM** *[*The lifecycle of an SecOC FreshnessValueManager implementation shall be managed by ara::com._♩ (RS_CM_00801)_

> [SWS_CM_11272]{草案} FVM的生命周期管理 *[*SecOC FreshnessValueManager实施的生命周期应由ara::com管理。(RS_CM_00801)_

### [SWS_CM_11273] {DRAFT} Initialization of the FVM _[_


- Initializing of the SecOC FreshnessValueManager implementation by calling Freshness Value Mananement Library API ara::com::secoc::FVM::Initialize.

> 初始化SecOC FreshnessValueManager实现，通过调用Freshness Value Mananement Library API ara::com::secoc::FVM::Initialize。

_♩(RS_CM_00801)_


**[SWS_CM_11274]**{DRAFT} **SecOC secure channel sending** *[*If a message is configured to be SecOC sent, the message shall be secured according to [27] and following steps shall be performed:

> **[SWS_CM_11274]**{草案} **SecOC安全通道发送** *[*如果一条消息被配置为SecOC发送，则该消息应根据[27]进行加密，并执行以下步骤：

- the message shall be handled as Authentic message by the Communication Management

- the message Authentication shall be performed in the order of operations after the E2E protection calculations

> 认证应在端到端保护计算之后进行操作顺序。

- if the ServiceInterfaceElementSecureComConfig has an attribute freshnessValueId defined, the Communication Management shall call the Freshness Value Mananement Library API ara::com::secoc::FVM::GetTxFreshness with the freshnessValueId

> 如果ServiceInterfaceElementSecureComConfig定义了freshnessValueId属性，通信管理应调用Freshness Value Mananement Library API ara::com::secoc::FVM::GetTxFreshness，并使用freshnessValueId参数。

- calculate the MAC using the Authentic message ([PRS_SecOc_00200] see [27]), (optionally the Freshness Value), and the dataId

> 計算MAC（可選擇性地使用新鮮度值），使用訊息([PRS_SecOc_00200]參見[27])和資料ID。

- if the attribute authInfoTxLength is defined, the Authenticator ([PRS_SecOc_00210] see [27]) shall be truncated

> 如果定义了authInfoTxLength属性，那么认证器（[PRS_SecOc_00210]参见[27]）将被截断。

- if the attribute freshnessValueTxLength is defined, the Freshness Value shall be truncated ([PRS_SecOc_00201] see [27])

> 如果定义了freshnessValueTxLength属性，则新鲜度值应该被截断（[PRS_SecOc_00201]参见[27]）。

- combine the Authentic message, (truncated) Freshness Value, and (truncated) Authenticator ([PRS_SecOc_00211] see [27])

> 结合真实消息，新鲜度值和认证器([PRS_SecOc_00211]参见[27])
- continue in the Communication Management with the send processing


The details for the construction of secure message are described in: [PRS_SecOc_00103], [PRS_SecOc_00105], [PRS_SecOc_00200], [PRS_SecOc_00207], [PRS_SecOc_00208], [PRS_SecOc_00209], [PRS_SecOc_00210], [PRS_SecOc_00211], [PRS_SecOc_00212] (see [27])_♩(RS_CM_00801)_

> 详细的安全消息构建细节见：[PRS_SecOc_00103]，[PRS_SecOc_00105]，[PRS_SecOc_00200]，[PRS_SecOc_00207]，[PRS_SecOc_00208]，[PRS_SecOc_00209]，[PRS_SecOc_00210]，[PRS_SecOc_00211]，[PRS_SecOc_00212]（见[27]）_♩（RS_CM_00801）_


**[SWS_CM_11275]**{DRAFT} **SecOC secure message build attempts** *[*For every message to be send and secured with SecOC [27] an Authentication Build Counter([PRS_SecOc_00202] see [27]) shall be maintained:

> **[SWS_CM_11275]**{草案} **SecOC安全信息构建尝试** *[*每一条要使用SecOC [27]发送并加密的消息，都应当维护一个认证构建计数器（参见[PRS_SecOc_00202] [27]）：

- the Authentication Build Counter shall be set to 0 if the operation was successful.

- if the query of the freshness value ara::com::secoc::FVM::GetTxFreshness return a recoverable error kFVNotAvailable, or an error occurs during calculation of the Authenticator, the Authentication Build Counter is incremented and the process of securing the message will be retried in an implementation specific manner.

> 如果ara::com::secoc::FVM::GetTxFreshness查询的新鲜度值返回可恢复的错误kFVNotAvailable，或在计算鉴定者时发生错误，则将认证构建计数器增加，并按照实施特定的方式重试保护消息的过程。

- if the Authentication Build Counter has reached the SecOC implementation specific threshold SecOCAuthenticationBuildAttempts([PRS_SecOc_00206] see [27]), the message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).

> 如果认证构建计数器已达到SecOC实施特定阈值SecOCAuthenticationBuildAttempts（[PRS_SecOc_00206]参见[27]），则消息将被丢弃，并且将记录事件（如果ara :: com实施已启用日志记录）。


The process is described in: [PRS_SecOc_00201], [PRS_SecOc_00202], [PRS_SecOc_00203], [PRS_SecOc_00204], [PRS_SecOc_00205], [PRS_SecOc_00206] (see [27])_♩(RS_CM_00801)_

> 这个过程在[PRS_SecOc_00201]、[PRS_SecOc_00202]、[PRS_SecOc_00203]、[PRS_SecOc_00204]、[PRS_SecOc_00205]、[PRS_SecOc_00206]（参见[27]）_♩(RS_CM_00801)_中有所描述。


**[SWS_CM_11276]**{DRAFT} **SecOC secure channel reception** *[*If a message is configured to be SecOC received and the attribute securedRxVerification is set to true or is not defined, then the message shall be verified according to [27] and following steps shall be performed:

> **[SWS_CM_11276]**{草案} **SecOC安全通道接收** *[*如果配置消息以SecOC接收，并且securedRxVerification属性设置为true或未定义，则消息应根据[27]进行验证，并执行以下步骤：

- the message shall be handled as Secured message by the Communication Management

- if the attribute freshnessValueTxLength is defined, the Freshness Value will be calculated by calling the Freshness Value Mananement Library API ara::com::secoc::FVM::GetRxFreshness with SecOCFreshnessValueID equals to defined freshnessValueId and with the SecOCTruncatedFreshnessValue equals to the extracted Truncated Freshness Value([PRS_SecOc_00317] see [27]) from the Secured message, otherwise the Freshness Value([PRS_SecOc_00316] see [27]) shall be extracted from the Secured message itself

> 如果定义了freshnessValueTxLength属性，则通过调用ara::com::secoc::FVM::GetRxFreshness API来计算Freshness Value，其中SecOCFreshnessValueID等于定义的freshnessValueId，SecOCTruncatedFreshnessValue等于从安全消息中提取的截断的Freshness Value（[PRS_SecOc_00317]参见[27]），否则Freshness Value（[PRS_SecOc_00316]参见[27]）应从安全消息本身提取。

- if the attribute authInfoTxLength is defined, the Truncated Authenticator([PRS_SecOc_00315] see [27]) shall be extracted from the Secured message, otherwise the Authenticator([PRS_SecOc_00317] see [27]) shall be extracted from the Secured message

> 如果定义了authInfoTxLength属性，则应从安全消息中提取截断的认证器([PRS_SecOc_00315]参见[27])，否则应从安全消息中提取认证器([PRS_SecOc_00317]参见[27])。

- verify the message by calculating the MAC using the Secured message, optionally the Freshness Value([PRS_SecOc_00300], and comparing the result with received Truncated Authenticator([PRS_SecOc_00315] and continue in the Communication Management with the receive processing

> 验证消息，使用安全消息计算MAC（可选择新鲜度值[PRS_SecOc_00300]），并将结果与接收到的截断认证器[PRS_SecOc_00315]进行比较，然后继续进行通信管理并进行接收处理。

- the message authentication procedure is done before E2E checks


The details for the verification of secure message are described in: [PRS_SecOc_00103], [PRS_SecOc_00300], [PRS_SecOc_00313], [PRS_SecOc_00314], [PRS_SecOc_00315], [PRS_SecOc_00316], [PRS_SecOc_00317], [PRS_SecOc_00318], [PRS_SecOc_00330] (see [27])_♩(RS_CM_00801)_

> 详细的安全消息验证信息参见：[PRS_SecOc_00103]，[PRS_SecOc_00300]，[PRS_SecOc_00313]，[PRS_SecOc_00314]，[PRS_SecOc_00315]，[PRS_SecOc_00316]，[PRS_SecOc_00317]，[PRS_SecOc_00318]，[PRS_SecOc_00330] (参见[27])_♩(RS_CM_00801)_


**[SWS_CM_11372]**{DRAFT} **SecOC secure channel reception bypass** *[*If a message is configured to be SecOC received and the attribute securedRxVerification is set to false, then

> **[SWS_CM_11372]**{草案} **SecOC安全通道接收绕过** *[*如果一条消息被配置为SecOC接收，且securedRxVerification属性设置为false，那么


- the message shall be handled as Secured message without verification by the Communication Management

> 消息将被作为安全消息处理，无需通信管理确认。
- the Authentic message part shall be extracted and processed
- the VerificationStatus shall be set to VerificationStatusResult. kSecOcNoVerification

_♩(RS_CM_00801)_


**[SWS_CM_11277]**{DRAFT} **SecOC secure message verification attempts** *[*For every message received and secured with SecOc, an Authentication Build Counter([PRS_SecOc_00301] shall be maintained:

> **[SWS_CM_11277]**{草案} **SecOC安全消息验证尝试** *[*对于使用SecOc安全传输的每一条消息，都应维护一个认证构建计数器（[PRS_SecOc_00301]）：

- the Authentication Build Counter shall be set to 0 if the operation was successful.

- if the query of the freshness value Freshness Value Mananement Library API ara::com::secoc::FVM::GetRxFreshness returns a recoverable error kFVNotAvailable, or an error occurs during calculation of the Authenticator, the Authentication Build Counter shall be incremented and the process of message verification will be retried in an implementation specific manner.

> 如果新鲜度值Freshness Value Mananement Library API ara::com::secoc::FVM::GetRxFreshness的查询返回可恢复的错误kFVNotAvailable，或在计算Authenticator时发生错误，则应增加认证构建计数器，并按实现特定的方式重试消息验证过程。

- if the counter has reached the parameter authenticationRetries([PRS_SecOc_00307] see [27]), the message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).

> 如果计数器达到参数authenticationRetries([PRS_SecOc_00307]参见[27])，则消息将被丢弃，并且事件将被记录（如果ara::com实现启用了日志记录）。

- if the calculation of the Authenticator([PRS_SecOc_00315] was successful but the verification failed for the parameter authenticationRetries([PRS_SecOc_00306] see [27]), the message shall be discarded and the incident shall be logged (if logging is enabled for the ara::com implementation).

> 如果认证器([PRS_SecOc_00315])的计算成功，但参数认证重试([PRS_SecOc_00306])的验证失败（参见[27]），则消息将被丢弃，且如果ara :: com实现已启用日志记录，该事件将被记录。


The process is described in: [PRS_SecOc_00301], [PRS_SecOc_00302], [PRS_SecOc_00303], [PRS_SecOc_00304], [PRS_SecOc_00305], [PRS_SecOc_00306],

> 这个过程在[PRS_SecOc_00301]、[PRS_SecOc_00302]、[PRS_SecOc_00303]、[PRS_SecOc_00304]、[PRS_SecOc_00305]和[PRS_SecOc_00306]中有描述。


[PRS_SecOc_00307], [PRS_SecOc_00308], [PRS_SecOc_00309], [PRS_SecOc_00310], [PRS_SecOc_00311], [PRS_SecOc_00312] (see [27])_♩(RS_CM_00801)_

> [PRS_SecOc_00307]、[PRS_SecOc_00308]、[PRS_SecOc_00309]、[PRS_SecOc_00310]、[PRS_SecOc_00311]、[PRS_SecOc_00312]（见[27]）_♩(RS_CM_00801)_


The SecOC VerificationStatus service is used to propagate the status of each verification attempt from the SecOC to an application. It can be used to continuously monitor the number of failed verification attempts and would allow setting up a security management system/intrusion detection system that is able to detect an attack flood and react with adequate dynamic countermeasures.

> SecOC验证状态服务用于将每次验证尝试的状态从SecOC传播到应用程序。它可以用于持续监测失败验证尝试的次数，并允许建立能够检测攻击洪水并以适当的动态对策做出反应的安全管理系统/入侵检测系统。


**[SWS_CM_11278]**{DRAFT} **SecOC verification results** *[*Communication Management shall make each verification result (VerificationStatusResult) accessible via the VerificationStatus service._♩(RS_CM_00801)_

> **[SWS_CM_11278]**{草案} **SecOC验证结果** *[*通信管理应通过验证状态服务使每个验证结果（VerificationStatusResult）可访问。_♩（RS_CM_00801）_


**[SWS_CM_11279]**{DRAFT} **SecOc override the verification result** *[*Communication Management shall allow the configuration of SecOC behavior via the VerifyStatusOverride or VerifyStatusOverride methods. The overwrite options are defined by OverrideStatus. The configuration is available per dataID in the case of VerificationStatusConfigurationByDataId service or per freshnessID in the case of VerificationStatusConfigurationByFreshnessId service._♩ (RS_CM_00801)_

> **[SWS_CM_11279]**{草案} **SecOC覆盖验证结果** *[*通信管理应允许通过VerifyStatusOverride或VerifyStatusOverride方法配置SecOC行为。覆盖选项由OverrideStatus定义。在VerificationStatusConfigurationByDataId服务的情况下，每个dataID可用，而在VerificationStatusConfigurationByFreshnessId服务的情况下，每个freshnessID可用。_♩ (RS_CM_00801)_*

简体中文：**[SWS_CM_11279]**{草案} **SecOC覆盖验证结果** *[*通信管理应允许通过VerifyStatusOverride或VerifyStatusOverride方法配置SecOC行为。覆盖选项由OverrideStatus定义。在VerificationStatusConfigurationByDataId服务的情况下，每个dataID可用，而在VerificationStatusConfigurationByFreshnessId服务的情况下，每个freshnessID可用。_♩ (RS_CM_00801)_*

### Signal based network binding


The SOME/IP Message Header as shown in figure [7.21](#_bookmark317) is divided into two parts: Part I containing the Message ID and the Length and Part II containing Request ID, Protocol Version, Interface Version, Message Type and Return Code (SOME/IP Protocol Specification [5]).

> 图7.21所示的SOME/IP消息头可分为两部分：第一部分包含消息ID和长度，第二部分包含请求ID、协议版本、接口版本、消息类型和返回码（SOME/IP协议规范[5]）。


In case of signal-service-translation only a partial header is used, namely the Part I. In figure [7.24](#_bookmark330) the handling of the Header Part I, the signal based payload, and the SecOC part is illustrated.

> 在信号服务翻译中，只使用部分标头，即第一部分。在图7.24中，描述了标头第一部分、基于信号的有效负载以及SecOC部分的处理方式。

![](./media/image36.png)Payload covered by SecOC
![](./media/image37.png){width="3.7238648293963252in" height="0.12031167979002624in"}Payload covered by SOME/IP Length
**Figure 7.24:** **Payload covered by SecOC and Signal2Service transport**


**[SWS_CM_11346]**{DRAFT} *[*If the ISignalTriggering is used in a signal-servicetranslation (the attribute SomeipEventDeployment.serializer equals signalBased), CM shall check if the PduTriggering of this ISignalIPdu is referenced by a SecuredIPdu and use the SecureCommunicationAuthenticationProps, SecureCommunicationFreshnessProps and SecureCommunicationProps of the SecuredIPdu as configuration of SecOc._♩(RS_CM_00801)_

> 如果ISignalTriggering在信号服务转换中使用（属性SomeipEventDeployment.serializer等于signalBased），CM应检查此ISignalIPdu是否被SecuredIPdu引用，并将SecuredIPdu的SecureCommunicationAuthenticationProps、SecureCommunicationFreshnessProps和SecureCommunicationProps作为SecOc的配置。_♩（RS_CM_00801）_


As described in Security chapter of [6], in the context of signal-based communication, SecOC is highly embedded into the Classic platform architecture the signalservice translation approach on security is to use the same architecture for its specification.

> 根据[6]中安全章节的描述，在信号通信的背景下，SecOC高度嵌入到Classic平台架构中，信号服务的安全转换方法是使用相同的架构来进行规范。


The input for signal based SecOC configuration is shown in figure [7.25](#_bookmark331):

> 图7.25中显示的是基于信号的SecOC配置的输入。

![](./media/image38.png)

**Figure 7.25:** **Input for for signal based SecOC configuration**

### IPsec


IPsec provides cryptographic protection for IP datagrams in IPv4 and IPv6 network packets.

> IPsec提供了IPv4和IPv6网络数据报的加密保护。


**[SWS_CM_90117]**{DRAFT} **IPsec secure channel between communication nodes** *[*An IPsec secure channel shall be created and used if an AdaptivePlatformServiceInstance is mapped by ServiceInstanceToMachineMapping to an EthernetCommunicationConnector that points with the unicastNetworkEndpoint to a NetworkEndpoint that aggregates an IPSecConfig.

> 在通信节点之间建立IPsec安全通道{草案}
如果AdaptivePlatformServiceInstance通过ServiceInstanceToMachineMapping映射到指向具有单播网络端点的EthernetCommunicationConnector的网络端点并聚合IPSecConfig，则应创建并使用IPsec安全通道。


The IPSecRules in the IPSecConfig define security associations between the NetworkEndpoint that aggregates this IPSecConfig and remote nodes that are defined by the referenced remoteIpAddress._♩(RS_CM_00801)_

> IPSecConfig中的IPSecRules定义了这个IPSecConfig聚合的NetworkEndpoint和由引用的remoteIpAddress定义的远程节点之间的安全关联。


**[SWS_CM_90118]**{DRAFT} **Transport of Service communication over an IPsec security association** *[*If a communication connection is established between a Service Provider and Service Requester and the configured transport layer connection matches the defined security association then the IP packets exchanged between the Service Provider and Service Requester will be protected by IPsec.

> 如果在服务提供者和服务请求者之间建立了通信连接，并且配置的传输层连接与定义的安全关联匹配，那么服务提供者和服务请求者之间交换的IP数据包将受到IPsec的保护。

In other words it means that if the IPsec security association defined by


- the local Address (IP Address defined by the networkEndpointAddress, Port and Protocol defined by localPortRangeStart and localPortRangeEnd

> 本地地址（由networkEndpointAddress定义的IP地址，由localPortRangeStart和localPortRangeEnd定义的端口和协议）

- the remote Address (IP Address defined by the remoteIpAddress, Port and Protocol defined by remotePortRangeStart or remotePortRangeEnd)

> 远程地址（由remoteIpAddress定义的IP地址，由remotePortRangeStart或remotePortRangeEnd定义的端口和协议）

equals the settings defined by

- the ServiceInstanceToMachineMapping for the ProvidedApServiceInstance and
- the ServiceInstanceToMachineMapping for the RequiredApServiceInstance and
- this network connection is established


then the IP packets between the two nodes will be protected according to the configuration that is also defined in the IPSecRule._♩(RS_CM_00801)_

> 然后，两个节点之间的IP数据包将根据IPSecRule中定义的配置进行保护。（RS_CM_00801）

### DDS Security


DDS Security, as defined in [25], is a complementary standard to DDS, providing transport-independent security measures (authentication, secrecy, non-repudiation, integrity, access control and logging) without requiring changes to application logic.

> DDS安全，如[25]中所定义，是DDS的补充标准，提供与传输无关的安全措施（认证、保密、不可否认、完整性、访问控制和日志记录），而无需更改应用程序逻辑。


Mapping DDS Service Interface and Instance Deployment models, as well as IAM Communications Grant models, to DDS QoS policies, and DDS Security certificate, governance and permission files is defined by [28].

> 将DDS服务接口和实例部署模型以及IAM通信授权模型映射到DDS QoS策略和DDS安全证书、治理和权限文件的定义由[28]提供。

### [SWS_CM_90218] {DRAFT} Enforcement of IAM grants through DDS Security


*[*Adaptive Applications providing or requiring Service Interface Instances through the DDS Network Binding shall enforce, when provided, deployed DDS Security policies._♩_

> 通过DDS网络绑定提供或需要服务接口实例的自适应应用程序应当执行部署的DDS安全策略（如果有提供的话）。

_(RS_IAM_00001, RS_IAM_00002)_

### MACsec

MACsec provides cryptographic protection for MAC frames.


**[SWS_CM_99040]**{DRAFT} **MACsec secure channel between communication nodes and MACsec security association** *[*A MACsec secure channel and secure association shall be created and used according to the requirements and constraints specified in [[SWS_CM_90117](#_bookmark333)] and [[SWS_CM_90118](#_bookmark334)]._♩(FO_RS_MACsec_00001, FO_RS_MACsec_00006)_

> **[SWS_CM_99040]**{草稿}**MACsec安全通道在通信节点之间建立和使用MACsec安全关联** *[*根据[[SWS_CM_90117](#_bookmark333)]和[[SWS_CM_90118](#_bookmark334)]的要求和约束，应建立和使用MACsec安全通道和安全关联。_♩(FO_RS_MACsec_00001, FO_RS_MACsec_00006)_*

## Safety


In the following chapter the behavior according to the meta-model of safety communication shall be described.

> 在接下来的章节中，将描述根据安全沟通元模型的行为。

### End-to-end communication protection for Events


This section specifies the integration of E2E communication protection in ara::com for the processing of Events.

> 此部分指定了 ara::com 中的端到端通信保护如何用于处理事件。


**[SWS_CM_90402]**{DRAFT} *[*An E2E-protected Event shall have its options configured in End2EndEventProtectionProps and E2EProfileConfiguration._♩ (RS_E2E_08540)_

> **[SWS_CM_90402]**{草案} *[*一个E2E受保护的事件应该在End2EndEventProtectionProps和E2EProfileConfiguration中配置其选项。_♩ (RS_E2E_08540)_


**[SWS_CM_90433]**{DRAFT} *[*The E2E functions mentioned in this section using the names E2E_protect and E2E_check shall meet the requirements on E2E protection as defined in [7] and comply with the E2E protection protocol specification of [4] (especially [PRS_E2E_00323])._♩(RS_E2E_08540, RS_CM_00223)_

> **[SWS_CM_90433]**{草稿} *[*本节中提到的E2E功能，使用名称E2E_protect和E2E_check，应符合[7]中定义的E2E保护要求，并符合[4]（特别是[PRS_E2E_00323]）的E2E保护协议规范。_♩(RS_E2E_08540，RS_CM_00223)_


For each specific Event class belonging to a specific ServiceProxy/ServiceSkeleton class the E2E dataID based on, e.g., a combination of Service ID, Service Instance ID and Event ID is available.

> 对于属于特定ServiceProxy/ServiceSkeleton类的每个特定事件类，基于E2E数据ID（例如，服务ID、服务实例ID和事件ID的组合）都是可用的。

### Limitations

The specified E2E communication protection for events is limited.

- EndToEndTransformationComSpecProps are not supported.


General limitations regarding E2E protection and the detectable failure modes are described in [4].

> 一般关于端到端保护的限制及可检测的故障模式在[4]中有描述。


The values of the following E2E parameters are defined as fixed by the standard and shall not be changed. See [PRS_E2E_00324] of [4]:

> 以下E2E参数的值由标准确定为固定值，不得更改。请参见[4]中的[PRS_E2E_00324]。

- counterOffset
- crcOffset
- dataIdNibbleOffset


The value of following E2E parameters shall be set to the default values specified by [PRS_E2E_00324] of [4]:

> 以下E2E参数的值应设置为[PRS_E2E_00324]中指定的[4]的默认值。

- offset


The value of dataIdMode for Events and the notifier of Fields shall be set according to the dataIdMode of the E2EProfileConfiguration which is referenced (in role e2eProfileConfiguration) by the AdaptivePlatformServiceInstance.e2eEventProtectionProps which reference (in role event) the ServiceEventDeployment of the particular Event or the Field notifier.

> 数据ID模式的值应根据被AdaptivePlatformServiceInstance.e2eEventProtectionProps引用（在角色e2eProfileConfiguration中）的E2EProfileConfiguration的数据ID模式设置，该E2EProfileConfiguration又引用（在角色event中）特定事件或字段通知器的ServiceEventDeployment。

### Publisher


**[SWS_CM_90453]**{DRAFT} *[*For E2E-protected Events, E2E protection shall be performed within the context of Send._♩(RS_CM_00223, RS_E2E_08540)_

> **[SWS_CM_90453]**{草案} *[*对于E2E受保护的事件，应在发送的上下文中执行E2E保护。♩（RS_CM_00223，RS_E2E_08540）_


Figure [7.26](#_bookmark343) shows an overview of the interaction of components involved during the E2E protection at the publisher side.

> 图7.26显示了发布者端E2E保护过程中参与组件之间的交互概览。

![](./media/image41.png)Publisher application

**Figure 7.26:** **E2E Publisher**


**[SWS_CM_90430]**{DRAFT} *[*For E2E-protected Events, Send shall serialize the sample and potentially add a protocol header according to the rules of the respective network binding (e.g., according to [[SWS_CM_10291](#_bookmark60)] in case of SOME/IP network binding), resulting in serialized data._♩(RS_CM_00223, RS_E2E_08540)_

> **[SWS_CM_90430]**{DRAFT} *[*对于E2E保护的事件，发送方应按照各自网络绑定的规则（例如，在SOME/IP网络绑定的情况下，按照[[SWS_CM_10291](#_bookmark60)]）对样本进行序列化，并可能添加协议头，从而产生序列化的数据。_♩（RS_CM_00223，RS_E2E_08540）_


From E2E protection perspective this serialized data include both a non-protected part as well as the part to be protected (see [PRS_E2E_UC_00239] and [PRS_E2E_USE_00741]).

> 从端到端保护角度来看，这些序列化数据既包括一部分未受保护的部分，也包括需要受保护的部分（参见[PRS_E2E_UC_00239]和[PRS_E2E_USE_00741]）。


**[SWS_CM_90401]**{DRAFT} *[*For E2E-protected Events, E2E_protect shall be invoked on the to be protected serialized data (passed as argument serializedData to E2E_protect) according to [PRS_E2E_00323]._♩(RS_E2E_08540)_

> **[SWS_CM_90401]**{草案} *[*对于受到端到端保护的事件，应该根据[PRS_E2E_00323]，在要被保护的序列化数据（作为参数serializedData传递给E2E_protect）上调用E2E_protect。_♩(RS_E2E_08540)_


**[SWS_CM_90403]**{DRAFT} *[*For E2E-protected Events, the End2EndEventProtectionProps.dataId shall be passed as argument dataID to E2E_protect._♩(RS_E2E_08540)_

> **[SWS_CM_90403]**{草稿} *[*对于E2E受保护的事件，End2EndEventProtectionProps.dataId应作为参数dataID传递给E2E_protect._♩(RS_E2E_08540)_


**[SWS_CM_90404]**{DRAFT} *[*For E2E-protected Events, in case of SOME/IP serialization the E2E protection header shall be added to the message. If the protocol specification of the respective network binding imposes restrictions on the placement of the E2E protection header (e.g., [PRS_SOMEIP_00941] in case of SOME/IP network binding), then these restrictions shall be honored._♩(RS_E2E_08540)_

> **[SWS_CM_90404]**{草案} *[*对于采用SOME/IP序列化的E2E受保护事件，应将E2E保护头添加到消息中。如果相应网络绑定的协议规范对E2E保护头的位置（例如，[PRS_SOMEIP_00941]在SOME/IP网络绑定中）有限制，则应遵守这些限制。_♩(RS_E2E_08540)_

### Subscriber GetNewSamples


**[SWS_CM_90406]**{DRAFT} *[*For E2E-protected Events, E2E checking shall be performed within the context of GetNewSamples._♩(RS_CM_00223, RS_E2E_08540)_

> **[SWS_CM_90406]**{草案} *[*对于E2E受保护的事件，E2E检查应在GetNewSamples的上下文中进行。_♩(RS_CM_00223, RS_E2E_08540)_


Figure [7.27](#_bookmark345) shows an overview of the interaction of components involved during the E2E checking at the subscriber side.

> 图7.27显示了在用户端进行E2E检查时涉及的组件之间的交互概览。

![](./media/image51.png)

**Figure 7.27:** **E2E Subscriber**


**[SWS_CM_90407]**{DRAFT} *[*For E2E-protected Events, GetNewSamples shall first get the collection of all serialized data that have not been fetched during the last call of this GetNewSamples function._♩(RS_CM_00224, RS_E2E_08540)_

> **[SWS_CM_90407]**{草案} *[*对于E2E受保护的事件，GetNewSamples应首先获取在上次调用此GetNewSamples函数时尚未获取的所有序列化数据的集合。_♩(RS_CM_00224, RS_E2E_08540)_

简体中文：**[SWS_CM_90407]**{草案} *[*对于E2E受保护的事件，GetNewSamples应首先获取上次调用此GetNewSamples函数时未被抓取的所有序列化数据的集合。_♩(RS_CM_00224, RS_E2E_08540)_


From E2E protection perspective this serialized data include both a non-protected part as well as the part to be protected (see [PRS_E2E_UC_00239] and [PRS_E2E_USE_00741]).

> 从端到端保护的角度来看，这些序列化的数据既包含未受保护的部分，也包含要受保护的部分（参见[PRS_E2E_UC_00239]和[PRS_E2E_USE_00741]）。

### Case 1 there are one or more serialized samples


For E2E-protected Events, in case serialized data for one or more samples are received, then for each sample, the following steps are to be done:

> 对于E2E受保护的事件，如果收到一个或多个样本的序列化数据，则对于每个样本，需要执行以下步骤：


**[SWS_CM_90408]**{DRAFT} *[*For the given E2E-protected sample, GetNewSamples shall process the non-E2E protected header (if any) of the sample's serialized data._♩ (RS_CM_00224, RS_E2E_08540)_

> 对于给定的E2E保护样本，GetNewSamples应处理样本序列化数据的非E2E保护头（如果有）。（RS_CM_00224，RS_E2E_08540）


**[SWS_CM_90410]**{DRAFT} *[*For the given E2E-protected sample, E2E_check shall be invoked on the protected serialized data (passed as argument serializedData to E2E_check) according to [RS_E2E_08540] and [PRS_E2E_00323]._♩(RS_E2E_08540)_

> 对于给定的E2E保护样本，应按照[RS_E2E_08540]和[PRS_E2E_00323]在保护的序列化数据（作为参数serializedData传递给E2E_check）上调用E2E_check。


**[SWS_CM_90454]**{DRAFT} *[*For the given E2E-protected sample, the End2EndEventProtectionProps.dataId shall be passed as argument dataID to E2E_check._♩(RS_E2E_08540)_

> **[SWS_CM_90454]**{草案} *[*对于给定的E2E受保护的样本，End2EndEventProtectionProps.dataId 应作为参数dataID传递给E2E_check._♩(RS_E2E_08540)_


**[SWS_CM_90411]**{DRAFT} *[*In return, for the given E2E-protected sample, E2E_check shall provide a Result (e2eResult according to [PRS_E2E_00322] of [4]) containing the elements SMState (e2eState according to [PRS_E2E_00322] of [4]) and ProfileCheckStatus (e2eStatus according to [PRS_E2E_00322] of [4])._♩ (RS_E2E_08540, RS_E2E_08534)_

> 在返回中，对于给定的E2E受保护样本，E2E_check应提供一个包含元素SMState（根据[4]的[PRS_E2E_00322]）和ProfileCheckStatus（根据[4]的[PRS_E2E_00322]）的结果（e2eResult）。(RS_E2E_08540，RS_E2E_08534)


**[SWS_CM_90455]**{DRAFT} *[*For the given E2E-protected sample, the E2E protection header shall be removed from the serialized data._♩(RS_E2E_08540)_

> 对于给定的E2E受保护的样本，应从序列化数据中移除E2E保护头（RS_E2E_08540）。


**[SWS_CM_90412]**{DRAFT} *[*For the given E2E-protected sample, GetNewSamples shall deserialize the resulting serialized data according to the rules of the respective network binding (e.g., according to [[SWS_CM_10294](#_bookmark65)] in case of SOME/IP network binding), resulting in the deserialized sample._♩(RS_CM_00224, RS_E2E_08540)_

> 对于给定的E2E受保护的样本，GetNewSamples应根据各自网络绑定的规则反序列化生成的序列化数据（例如，在SOME/IP网络绑定中，按照[[SWS_CM_10294](#_bookmark65)），从而得到反序列化的样本。♩(RS_CM_00224, RS_E2E_08540)


**[SWS_CM_90413]**{DRAFT} *[*For the given E2E-protected sample, GetNewSamples shall store the ProfileCheckStatus in the SamplePtr and shall update/overwrite the global SMState within its specific Event class of the specific E2E-protected Event._♩(RS_CM_00224, RS_E2E_08540, RS_E2E_08534)_

> 对于给定的E2E保护样本，GetNewSamples应该将ProfileCheckStatus存储在SamplePtr中，并且应该在其特定的E2E保护事件的特定事件类中更新/覆盖全局SMState。 （RS_CM_00224，RS_E2E_08540，RS_E2E_08534）

### Case 2 there are no serialized samples


For E2E-protected Events, in case no serialized data are received, the steps are simpler and E2E protection works as timeout detection.

> 对于E2E保护事件，如果没有收到序列化数据，步骤会更简单，E2E保护将作为超时检测来工作。


**[SWS_CM_90415]**{DRAFT} *[*E2E_check shall be invoked on a null sample (i.e., a null pointer shall be passed as argument serializedData to E2E_check) according to [RS_E2E_08540] and [PRS_E2E_00323]._♩(RS_E2E_08540)_

> **[SWS_CM_90415]**{草案} *[*根据[RS_E2E_08540]和[PRS_E2E_00323]，应该对空样本（即将空指针作为序列化数据参数传递给E2E_check）调用E2E_check。_♩(RS_E2E_08540)_


**[SWS_CM_90456]**{DRAFT} *[*The End2EndEventProtectionProps.dataId shall be passed as argument dataID to E2E_check._♩(RS_E2E_08540)_

> **[SWS_CM_90456]**{草案} *[*End2EndEventProtectionProps.dataId 应该作为参数dataID传递给E2E_check._♩(RS_E2E_08540)_


**[SWS_CM_90416]**{DRAFT} *[*In return, for the given null sample, E2E_check shall provide a Result (e2eResult according to [PRS_E2E_00322] of [4]) containing the elements SMState (e2eState according to [PRS_E2E_00322] of [4]) and ProfileCheckStatus (e2eStatus according to [PRS_E2E_00322] of [4])._♩(RS_E2E_08540, RS_E2E_08534)_

> 在这种情况下，对于给定的空样本，E2E_check应提供一个结果（根据[4]的[PRS_E2E_00322]），其中包含元素SMState（根据[4]的[PRS_E2E_00322]）和ProfileCheckStatus（根据[4]的[PRS_E2E_00322]）。_♩（RS_E2E_08540，RS_E2E_08534）_


**[SWS_CM_90417]**{DRAFT} *[*GetNewSamples shall update/overwrite the global SMState within its specific Event class of the specific E2E-protected Event._♩(RS_CM_00224, RS_E2E_08540, RS_E2E_08534)_

> **[SWS_CM_90417]**{草案} *[*GetNewSamples 应该在特定的 E2E 保护事件的特定事件类中更新/覆盖全局 SMState。_♩(RS_CM_00224, RS_E2E_08540, RS_E2E_08534)_

简体中文：**[SWS_CM_90417]**{草案} *[*GetNewSamples 应该在特定的 E2E 保护事件的特定事件类中更新/覆盖全局 SMState。_♩(RS_CM_00224, RS_E2E_08540, RS_E2E_08534)_

### Subscriber Callable f


The user provided Callable f is invoked for each received sample. The Callable f is called with the SamplePtr of the corresponding sample as parameter. The SamplePtr contains the deserialized sample including the ProfileCheckStatus.

> 用户提供的可调用f对每个接收到的样本调用。可调用f使用相应样本的SamplePtr作为参数调用。SamplePtr包含反序列化的样本，包括ProfileCheckStatus。

### Subscriber Access to E2E information


**[SWS_CM_90457]**{DRAFT} *[*Each SamplePtr shall provide a GetProfileCheckStatus method to access the ProfileCheckStatus of each sample (see [[SWS_CM_90420](#_bookmark479)])._♩(RS_CM_00224, RS_E2E_08540)_

> **[SWS_CM_90457]**{草稿} *[*每个SamplePtr都应提供一个GetProfileCheckStatus方法来访问每个样本的ProfileCheckStatus（参见[[SWS_CM_90420](#_bookmark479)]）。_♩(RS_CM_00224, RS_E2E_08540)_


**[SWS_CM_10475]**{DRAFT} *[*A GetE2EStateMachineState method shall be provided for each Event class of a specific ServiceProxy class._♩(RS_CM_00224, RS_E2E_08534)_

> **[SWS_CM_10475]**{草案} *[*一个特定ServiceProxy类的每个事件类都应提供一个GetE2EStateMachineState方法。_♩(RS_CM_00224, RS_E2E_08534)_


**[SWS_CM_90431]**{DRAFT} *[*The GetE2EStateMachineState method shall provide access to the global SMState of the specific Event class, which was determined by the last run of E2E_check function invoked during the last call of GetNewSamples (see [[SWS_CM_90417](#_bookmark349)])._♩(RS_CM_00224, RS_E2E_08534)_

> **[SWS_CM_90431]**{草案} *[*GetE2EStateMachineState方法应提供对特定事件类的全局SMState的访问，这是由上次调用GetNewSamples期间调用的E2E_check函数确定的（参见[[SWS_CM_90417](#_bookmark349)]）。_♩(RS_CM_00224, RS_E2E_08534)_

1 ara::com::e2e::SMState GetE2EStateMachineState() const noexcept;

### End-to-end communication protection for Methods


This section specifies the integration of E2E communication protection in ara::com for the processing of Methodss. This includes E2E communication protection for a Method's request as well as E2E communication protection for any kind of Method's response (i.e., normal or error response).

> 这一节指定了ara::com中E2E通信保护的集成，用于处理Methods。这包括Method请求的E2E通信保护以及任何类型Method响应（即正常或错误响应）的E2E通信保护。


**[SWS_CM_10460]**{DRAFT} *[*An E2E-protected Method shall have its options configured in End2EndMethodProtectionProps and E2EProfileConfiguration._♩ (RS_CM_00400, RS_E2E_08540)_

> **[SWS_CM_10460]**{草案} *[*E2E受保护的方法应将其选项配置在End2EndMethodProtectionProps和E2EProfileConfiguration中。♩ (RS_CM_00400, RS_E2E_08540)_


**[SWS_CM_90485]**{DRAFT} *[*The E2E functions mentioned in this section using the name E2E_protect and E2E_check shall meet the requirements on E2E protection as defined in [7] and comply with the E2E protection protocol specification of [4] (especially [PRS_E2E_00828])._♩(RS_CM_00400, RS_E2E_08541, RS_CM_00223)_

> **[SWS_CM_90485]**{草案}*[*本节中提到的E2E功能使用名称E2E_protect和E2E_check必须符合[7]中定义的E2E保护要求，并遵守[4]（特别是[PRS_E2E_00828]）的E2E保护协议规范。_♩(RS_CM_00400, RS_E2E_08541, RS_CM_00223)_


For each specific Method class ([[SWS_CM_00196](#_bookmark586)]) belonging to a specific ServiceProxy class and for each provided method (see [[SWS_CM_00191](#_bookmark537)]) belonging to a specific ServiceSkeleton class the E2E dataID based on, e.g., a combination of Service ID, Service Instance ID and Method ID is available.

> 对于属于特定ServiceProxy类的特定Method类（[[SWS_CM_00196](#_bookmark586)）以及属于特定ServiceSkeleton类的特定方法（参见[[SWS_CM_00191](#_bookmark537)），基于服务ID、服务实例ID和方法ID等的E2E数据ID是可用的。


Within the scope of this section a failed E2E check is an invocation of E2E_check returning an e2eStatus of either REPEATED, WRONGSEQUENCE, NOTAVAILABLE, or NONEWDATA. A successful E2E check is an invocation of E2E_check returning an e2eStatus different from REPEATED, WRONGSEQUENCE, NOTAVAILABLE, and NONEWDATA.

> 在本节范围内，失败的E2E检查是指调用E2E_check返回e2eStatus为REPEATED、WRONGSEQUENCE、NOTAVAILABLE或NONEWDATA。成功的E2E检查是指调用E2E_check返回的e2eStatus与REPEATED、WRONGSEQUENCE、NOTAVAILABLE和NONEWDATA不同。

### Limitations

The specified E2E communication protection for methods is limited.

- The processing mode kEvent (concurrent threads) is not supported for E2E protected methods.
- EndToEndTransformationComSpecProps are not supported.


General limitations regarding E2E protection and the detectable failure modes are described in [4].

> 一般有关E2E保护和可检测的故障模式的限制在[4]中有描述。


The values of the following E2E parameters are defined as fixed by the standard and shall not be changed. See [PRS_E2E_00324] of [4]:

> 以下E2E参数的值按标准规定为固定值，不得更改。参见[4]中的[PRS_E2E_00324]。

- counterOffset
- crcOffset
- dataIdNibbleOffset


The value of following E2E parameters shall be set to the default values specified by [PRS_E2E_00324] of [4]:

> 以下E2E参数的值应设置为[PRS_E2E_00324] of [4]中指定的默认值。

- offset


The value of dataIdMode for Methods and the getters and setters of Fields shall be set according to the dataIdMode of the E2EProfileConfiguration which is referenced (in role e2eProfileConfiguration) by the AdaptivePlatformServiceInstance.e2eMethodProtectionProps which reference (in role method) the ServiceMethodDeployment of the particular Method or the Field getter/setter.

> 数据ID模式的值应根据AdaptivePlatformServiceInstance.e2eMethodProtectionProps引用的（在角色e2eProfileConfiguration中）E2EProfileConfiguration的数据ID模式设置，该引用（在角色method中）特定方法或字段的getter/setter的ServiceMethodDeployment。

### E2E protection of the service method request (Client)


**[SWS_CM_10462]**{DRAFT} *[*For E2E-protected Methods, E2E protection of the request message shall be performed within the context of the operator() of the Method class (see [[SWS_CM_00196](#_bookmark586)]) of the respective service method._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10462]**{草案} *[*对于E2E保护的方法，应在Method类的operator（）的上下文中执行E2E保护请求消息（参见[[SWS_CM_00196](#_bookmark586)])各自的服务方法。_♩（RS_CM_00400，RS_E2E_08541）_


Figure [7.28](#_bookmark357) shows an overview of the interaction of components involved during the E2E protection of the Method request at the client side.

> 图7.28显示了在客户端E2E保护Method请求时参与组件之间的交互概述。

![](./media/image59.png)Client application ara::com Transmission

**Figure 7.28:** **Interaction of components during E2E protection of the Method request at the client side**

### Serializing the payload


**[SWS_CM_90458]**{DRAFT} *[*For E2E-protected Method requests, operator() shall serialize the Method's in and inout arguments and potentially add a protocol header according to the rules of the respective network binding (e.g., according to

> **[SWS_CM_90458]**{草案} *[*对于E2E受保护的方法请求，operator()应将方法的in和inout参数序列化，并根据相应网络绑定的规则可能添加协议头（例如，根据


[[SWS_CM_10301](#_bookmark74)] in case of SOME/IP network binding), resulting in the serialized data._♩(RS_CM_00400, RS_E2E_08541)_

> [[SWS_CM_10301](#_bookmark74)] 在SOME/IP网络绑定的情况下，导致序列化数据。♩(RS_CM_00400, RS_E2E_08541)


From E2E protection perspective this serialized data include both a non-protected part as well as the part to be protected (see [PRS_E2E_UC_00239] and [PRS_E2E_USE_00741]).

> 从端到端保护的角度来看，这个序列化的数据既包括一个未受保护的部分，也包括要受保护的部分（参见[PRS_E2E_UC_00239]和[PRS_E2E_USE_00741]）。

### E2E protection of the payload


**[SWS_CM_90479]**{DRAFT} *[*For E2E-protected Method requests, E2E_protect shall be invoked on the to be protected serialized data (passed as argument serializedData to E2E_protect) according to [RS_E2E_08541], [PRS_E2E_00323], and [PRS_E2E_00828]._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90479]**{草案} *[*对于E2E受保护的方法请求，应根据[RS_E2E_08541]，[PRS_E2E_00323]和[PRS_E2E_00828]对要受保护的序列化数据（作为参数serializedData传递给E2E_protect）调用E2E_protect。_♩(RS_CM_00400, RS_E2E_08541)_

简体中文：**[SWS_CM_90479]**{草案} *[*对于E2E受保护的方法请求，应按照[RS_E2E_08541]、[PRS_E2E_00323]和[PRS_E2E_00828]对要受保护的序列化数据（作为参数serializedData传递给E2E_protect）调用E2E_protect。_♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_10463]**{DRAFT} *[*For E2E-protected Method requests, the End2EndMethodProtectionProps.dataId shall be passed as argument dataID to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10463]**{草案} *[*对于E2E受保护的方法请求，End2EndMethodProtectionProps.dataId应作为参数dataID传递给E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_90486]**{DRAFT} *[*For E2E-protected Method requests using profiles P04m, P07m, P08m, or P44m, the End2EndMethodProtectionProps.sourceId shall be passed as argument sourceID to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90486]**{草案} *[*对使用配置文件P04m，P07m，P08m或P44m的E2E受保护的方法请求，End2EndMethodProtectionProps.sourceId应作为参数sourceID传递给E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_90487]**{DRAFT} *[*For E2E-protected Method requests using profiles P04m, P07m, P08m, or P44m, STD_MESSAGETYPE_REQUEST (0) shall be passed as argument messageType to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90487]**{草案} *[* 对于使用配置文件P04m、P07m、P08m或P44m的E2E保护方法请求，应将STD_MESSAGETYPE_REQUEST（0）作为参数messageType传递给E2E_protect。♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90488]**{DRAFT} *[*For E2E-protected Method requests using profiles P04m, P07m, P08m, or P44m, STD_MESSAGERESULT_OK (0) shall be passed as argument messageResult to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90488]**{草案} *[* 对于使用配置文件P04m、P07m、P08m或P44m的E2E保护方法请求，应将STD_MESSAGERESULT_OK（0）作为参数messageResult传递给E2E_protect。_♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_10464]**{DRAFT} *[*For E2E-protected Method requests, the E2E protection header shall be added to the message. If the protocol specification of the respective network binding imposes restrictions on the placement of the E2E protection header (e.g., [PRS_SOMEIP_00941] in case of SOME/IP network binding), then these restrictions shall be honored._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10464]**{草稿} *[*对于E2E受保护的方法请求，必须将E2E保护头添加到消息中。如果相应网络绑定的协议规范对E2E保护头的位置施加限制（例如，[PRS_SOMEIP_00941]在SOME/IP网络绑定中），则应遵守这些限制。_♩（RS_CM_00400，RS_E2E_08541）_

### E2E checking the service method request (Server)


**[SWS_CM_10466]**{DRAFT} *[*For E2E-protected Method requests, E2E checking shall be performed within the context of the message reception within the ServiceSkeleton if the MethodCallProcessingMode is set to kEventSingleThread._♩(RS_CM_00400, RS_E2E_08541)_

> 对于E2E受保护的方法请求，如果MethodCallProcessingMode设置为kEventSingleThread，则必须在ServiceSkeleton的消息接收上下文中执行E2E检查（RS_CM_00400，RS_E2E_08541）。


**[SWS_CM_10468]**{DRAFT} *[*For E2E-protected Method requests, E2E checking shall be performed within the context of ProcessNextMethodCall within the ServiceSkeleton if the MethodCallProcessingMode is set to kPoll._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10468]**{草案} *[*如果MethodCallProcessingMode设置为kPoll，则在ServiceSkeleton的ProcessNextMethodCall上下文中应执行E2E检查，以处理E2E受保护的Method请求。_♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_10467]**{DRAFT} *[*In case a MethodCallProcessingMode of kEvent has been passed to the named constructor of the ServiceSkeleton for a service using E2E-protected methods (see [[SWS_CM_10436](#_bookmark528)] or [[SWS_CM_10435](#_bookmark526)]), an error code ComErrc:kWrongMethodCallProcessingMode shall be returned in the Result of the named constructor Create(). If logging is enabled, the error shall be logged._♩ (RS_CM_00402, RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10467]**{草案}*[*如果在使用E2E受保护方法的服务的命名构造函数中传递了kEvent的MethodCallProcessingMode（参见[[SWS_CM_10436](#_bookmark528)]或[[SWS_CM_10435](#_bookmark526)])，则在Create（）的Result中返回ComErrc：kWrongMethodCallProcessingMode的错误代码。如果启用了日志记录，则应记录该错误。_♩(RS_CM_00402, RS_CM_00400, RS_E2E_08541)_

简体中文：**[SWS_CM_10467]**{草案}*[*如果在使用E2E受保护方法的服务的命名构造函数中传递了kEvent的MethodCallProcessingMode（参见[[SWS_CM_10436](#_bookmark528)]或[[SWS_CM_10435](#_bookmark526)])，则在Create（）的结果中返回ComErrc：kWrongMethodCallProcessingMode的错误代码。如果启用了日志记录，则应记录该错误。_♩(RS_CM_00402, RS_CM_00400, RS_E2E_08541)_


**Note:** A MethodCallProcessingMode set to kEvent is not supported for E2Eprotected Methods.

> **注意：** 不支持将MethodCallProcessingMode设置为kEvent以用于E2E受保护的方法。


Figures [7.29](#_bookmark364) and [7.30](#_bookmark365) show an overview of the interaction of components involved during the E2E checking of the Method request at the server side.

> 图7.29和7.30展示了服务器端E2E检查方法请求时参与的组件之间的交互概览。

**Figure 7.29:** **Interaction of components during E2E checking of the Method request at the server side polling**

![](./media/image80.jpeg)

**Figure 7.30:** **Interaction of components during E2E checking of the Method request at the server side event driven**

### E2E checking of the payload


For E2E-protected Method requests, in case serialized data are available the following steps are to be done:

> 对于E2E受保护的方法请求，如果有序列化数据可用，则需要执行以下步骤：


**[SWS_CM_90459]**{DRAFT} *[*For the given E2E-protected Method request, the nonE2E-protected header (if any) of the Method request's serialized data shall be processed._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的E2E受保护的方法请求，应处理方法请求序列化数据的非E2E受保护的头（如果有）。♩（RS_CM_00400，RS_E2E_08541）


**[SWS_CM_90480]**{DRAFT} *[*For the given E2E-protected Method request, E2E_check() shall be invoked on the protected serialized data (passed as argument serializedData to E2E_check()) according to [RS_E2E_08541], [PRS_E2E_00323], and [PRS_E2E_00828]._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的E2E受保护的方法请求，应根据[RS_E2E_08541]、[PRS_E2E_00323]和[PRS_E2E_00828]在受保护的序列化数据（作为参数serializedData传递给E2E_check（））上调用E2E_check（）。_♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90460]**{DRAFT} *[*For the given E2E-protected Method request, the End2EndMethodProtectionProps.dataId shall be passed as argument dataID to E2E_check())._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90460]**{草案} *[*对于给定的E2E受保护的方法请求，End2EndMethodProtectionProps.dataId应作为参数dataID传递给E2E_check（）)_♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90489]**{DRAFT} *[*For E2E-protected Method requests using profiles P04m, P07m, P08m, or P44m, a reference to a variable to store the sourceID to shall be passed as argument sourceID to E2E_check. E2E_check shall extract the E2E Source ID contained in the E2E protection header into this variable. This extracted sourceID shall be stored for later use during E2E protection of response payload (see [[SWS_CM_90492](#_bookmark378)])._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90489]**{草案} 对于使用配置文件P04m、P07m、P08m或P44m的E2E保护方法请求，必须将一个引用变量作为参数sourceID传递给E2E_check，以存储源ID。 E2E_check应将E2E保护标头中包含的E2E源ID提取到该变量中。 提取的源ID应存储以供稍后在响应有效负载的E2E保护期间使用（请参见[[SWS_CM_90492](#_bookmark378)]）。_♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_90490]**{DRAFT} *[*For E2E-protected Method requests using profiles P04m, P07m, P08m, or P44m, STD_MESSAGETYPE_REQUEST (0) shall be passed as argument messageType to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90490]**{草稿} *[* 对于使用配置文件P04m，P07m，P08m或P44m的E2E保护方法请求，应将STD_MESSAGETYPE_REQUEST（0）作为参数messageType传递给E2E_protect。_♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90491]**{DRAFT} *[*For E2E-protected Method requests using profiles P04m, P07m, P08m, or P44m, STD_MESSAGERESULT_OK (0) shall be passed as argument messageResult to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90491]**{草案} *[*对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法请求，应将STD_MESSAGERESULT_OK（0）作为参数messageResult传递给E2E_protect._♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90461]**{DRAFT} *[*In return, for the given E2E-protected Method request, E2E_check shall provide a Result (e2eResult according to [PRS_E2E_00322] of [4]) containing the elements SMState (e2eState according to [PRS_E2E_00322] of [4]) and ProfileCheckStatus (e2eStatus according to [PRS_E2E_00322] of [4])._♩ (RS_E2E_08541, RS_E2E_08534)_

> 回应给定的E2E受保护的方法请求，E2E_check应提供一个结果（根据[4]的[PRS_E2E_00322]，称为e2eResult），包含元素SMState（根据[4]的[PRS_E2E_00322]，称为e2eState）和ProfileCheckStatus（根据[4]的[PRS_E2E_00322]，称为e2eStatus）。（RS_E2E_08541，RS_E2E_08534）


**[SWS_CM_90462]**{DRAFT} *[*For the given E2E-protected Method request, the E2E protection header shall be removed from the serialized data._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的E2E受保护的方法请求，应从序列化数据中移除E2E保护头（RS_CM_00400，RS_E2E_08541）

### Deserializing the payload


In case the call to E2E_check (according to [[SWS_CM_90459](#_bookmark367)]) indicated a successful E2E check of the request message further processing of the request message shall take place.

> 在调用E2E_check（根据[[SWS_CM_90459](#_bookmark367)））指示请求消息的E2E检查成功的情况下，应进一步处理请求消息。


**[SWS_CM_90463]**{DRAFT} *[*For the given E2E-protected Method request, the resulting serialized data shall be deserialized according to the rules of the respective network binding (e.g., according to [[SWS_CM_10304](#_bookmark76)] in case of SOME/IP network binding), resulting in the deserialized in and inout arguments to the Method call._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的E2E受保护的方法请求，所产生的序列化数据应按照相应网络绑定的规则进行反序列化（例如，在SOME/IP网络绑定中，根据[[SWS_CM_10304](#_bookmark76)），导致反序列化in和inout参数到方法调用。_♩（RS_CM_00400，RS_E2E_08541）_

### E2E error notification


In case the call to E2E_check (according to [[SWS_CM_90459](#_bookmark367)]) indicated a failed E2E check of the request message, the server application can get notified via an E2E error handler.

> 如果调用E2E_check（根据[[SWS_CM_90459](#_bookmark367)））指示请求消息的端到端检查失败，服务器应用程序可以通过端到端错误处理程序获得通知。


The registration of an application's E2E error handler is static (before runtime). A dynamic registration/de-registration of an application's E2E error handler (like a publisher/subscriber pattern) is neither necessary nor possible.

> 注册应用程序的端到端错误处理程序是静态的（在运行时之前）。应用程序的端到端错误处理程序（类似发布者/订阅者模式）的动态注册/注销既不必要也不可能。


**[SWS_CM_10470]**{DRAFT} **E2E Error Handler Existence** *[*The ServiceSkeleton shall provide a virtual E2EErrorHandler method with arguments for errorCode, dataID, and messageCounter. This E2EErrorHandler function shall have an empty implementation which may be overridden by the actual ServiceSkeleton implementation. The E2EErrorHandler implementation is not required to be reentrant.

> 服务骨架应提供一个具有errorCode、dataID和messageCounter参数的虚拟E2EErrorHandler方法。该E2EErrorHandler函数应具有一个可由实际服务骨架实现覆盖的空实现。不需要对E2EErrorHandler实现进行重入处理。

```

```

_♩(RS_CM_00401, RS_CM_00402)_


**Note Faulty DataID:** If the E2E error is a CRC error then some parts of the received message are faulty. If this part is the DataID then the E2E error handler is called with a faulty DataID. Consequently, in case of CRC error the server application can not rely on the DataID received by its error handler.

> 如果E2E错误是CRC错误，那么收到的消息的某些部分是有问题的。如果这部分是DataID，那么E2E错误处理程序会以错误的DataID调用。因此，在CRC错误的情况下，服务器应用程序无法依赖其错误处理程序接收到的DataID。


**[SWS_CM_90464]**{DRAFT} **E2E Error Handler Invocation** *[*E2EErrorHandler shall be invoked from within a separate thread by the Communication Management software in case E2E_check reports an E2E error._♩(RS_CM_00401, RS_CM_00402)_

> **[SWS_CM_90464]**{草稿} **端到端错误处理器调用** *[*端到端错误处理器应该在一个单独的线程中由通信管理软件调用，如果端到端检查报告端到端错误。_♩(RS_CM_00401, RS_CM_00402)_*


**[SWS_CM_10471]**{DRAFT} **E2E Error Handler Invocation Arguments** *[*In case a new request message is available, E2EErrorHandler shall be called with the following arguments: errorCode shall be set to the ProfileCheckStatus obtained in [[SWS_CM_90411](#_bookmark347)], dataID shall be set to End2EndMethodProtectionProps. dataId, and messageCounter shall be set to the E2E counter of the received request message._♩(RS_CM_00223, RS_CM_00401, RS_CM_00402)_

> **[SWS_CM_10471]**{草案} **E2E错误处理程序调用参数** *[*如果有新的请求消息可用，则E2EErrorHandler应使用以下参数调用：errorCode应设置为在[[SWS_CM_90411](#_bookmark347)]中获得的ProfileCheckStatus，dataID应设置为End2EndMethodProtectionProps。 dataId，以及messageCounter应设置为收到的请求消息的E2E计数器。_♩（RS_CM_00223，RS_CM_00401，RS_CM_00402）_


**[SWS_CM_90465]**{DRAFT} **E2E Error Handler Invocation Arguments** *[*In case no new request message is available, E2EErrorHandler shall be called with the following arguments: errorCode shall be set to the kNotAvailable, dataID shall be set to 0, and messageCounter shall be set 0._♩(RS_CM_00401, RS_CM_00402)_

> **[SWS_CM_90465]**{草案} **E2E错误处理程序调用参数** *[*如果没有新的请求消息可用，则应使用以下参数调用E2EErrorHandler：errorCode应设置为kNotAvailable，dataID应设置为0，messageCounter应设置为0。_♩(RS_CM_00401，RS_CM_00402)_

### E2E protection of the service method response (Server))


**[SWS_CM_90481]**{DRAFT} *[*For E2E-protected Methods, E2E protection of the response message shall be performed after the execution of the service method (in case of a successful E2E_check according to [[SWS_CM_90480](#_bookmark368)]) or after the execution of the E2E error handler (in case of a failed E2E check according to [[SWS_CM_90480](#_bookmark368)])._♩ (RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90481]**{草案} *[* 对于E2E受保护的方法，如果按照[[SWS_CM_90480](#_bookmark368)]的E2E检查成功，则应在服务方法执行后对响应消息执行E2E保护；如果按照[[SWS_CM_90480](#_bookmark368)]的E2E检查失败，则应在E2E错误处理程序执行后对响应消息执行E2E保护。_♩ (RS_CM_00400, RS_E2E_08541)_


Figure [7.31](#_bookmark373) shows an overview of the interaction of components involved during the E2E protection of the Method response at the server side.

> 图7.31展示了服务器端E2E保护方法响应时各组件之间的交互概览。

![](./media/image83.jpeg)

**Figure 7.31:** **Interaction of components during E2E protection of the Method response at the server side**

### Serializing the E2E error response payload


**[SWS_CM_10472]**{DRAFT} **E2E Error Response** *[*In case E2E_check (according to [[SWS_CM_90480](#_bookmark368)]) reported an E2E error, an error response message according to the used network binding (e.g., [[SWS_CM_10312](#_bookmark82)] in case of SOME/IP) shall be sent to the client._♩(RS_CM_00223, RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10472]**{草案} **E2E错误响应** *[*如果E2E检查（根据[[SWS_CM_90480](#_bookmark368)）报告E2E错误，则根据使用的网络绑定（例如，SOME / IP中的[[SWS_CM_10312](#_bookmark82)]）发送错误响应消息到客户端。_♩（RS_CM_00223，RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90466]**{DRAFT} **Payload of the E2E Error Response** *[*The payload of this error response message shall contain an ara::core::ErrorCode of error domain ara::com::e2e::E2EErrorDomain. The value of this ara::core::ErrorCode shall be set to the corresponding error value of E2E_check according to [[SWS_CM_90421](#_bookmark508)]. The serialization of this error code and the potential adding of a protocol header shall take place according to the used network binding (e.g., according to [[SWS_CM_10312](#_bookmark82)] and [[SWS_CM_10428](#_bookmark83)] in case of SOME/IP)._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90466]**{草案}**E2E错误响应的载荷** *[*此错误响应消息的载荷应包含ara::core::ErrorCode的错误域ara::com::e2e::E2EErrorDomain。该ara::core::ErrorCode的值应根据[[SWS_CM_90421](#_bookmark508)]设置为E2E_check的相应错误值。此错误代码的序列化以及潜在的协议头添加应根据所使用的网络绑定（例如，根据[[SWS_CM_10312](#_bookmark82)]和[[SWS_CM_10428](#_bookmark83)]在SOME / IP中）进行。_♩(RS_CM_00400, RS_E2E_08541)_

### Serializing the response payload


**[SWS_CM_90467]**{DRAFT} **Payload of the Normal or Application Error Response** *[*For E2E-protected Methods the Method inout and out arguments or the application error shall be serialized and a protocol header shall be potentially added according to the rules of the respective network binding (e.g., according to [[SWS_CM_10312](#_bookmark82)] in case of SOME/IP network binding), resulting in the serialized data._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90467]**{草案} **正常或应用程序错误响应的有效载荷** *[*对于E2E保护的方法，方法输入和输出参数或应用程序错误应根据各自网络绑定的规则序列化（例如，根据[[SWS_CM_10312] (#_bookmark82)]在SOME/IP网络绑定的情况下），从而产生序列化数据。_♩（RS_CM_00400，RS_E2E_08541）_


From E2E communication protection perspective this serialized data include both a non-protected part as well as the part to be protected (see [PRS_E2E_UC_00239] and [PRS_E2E_USE_00741]).

> 从端到端通信保护的角度来看，这些序列化的数据既包括未受保护的部分，也包括要受保护的部分（参见[PRS_E2E_UC_00239]和[PRS_E2E_USE_00741]）。

### E2E protection of the response payload


**[SWS_CM_90468]**{DRAFT} *[*For E2E-protected Method responses, E2E_protect shall be invoked on the to be protected serialized data (passed as argument serializedData to E2E_protect) according to [RS_E2E_08541], [PRS_E2E_00323], and [PRS_E2E_00828]._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90468]**{草案} *[*对于E2E受保护的方法响应，应根据[RS_E2E_08541]，[PRS_E2E_00323]和[PRS_E2E_00828]，在要受保护的序列化数据（作为参数serializedData传递给E2E_protect）上调用E2E_protect。_♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_10469]**{DRAFT} *[*For E2E-protected Method responses, the End2EndMethodProtectionProps.dataId shall be passed as argument dataID to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10469]**{草案} *[*对于E2E受保护的方法响应，应将End2EndMethodProtectionProps.dataId作为参数dataID传递给E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_


**Note:** This is the same dataID that has been contained in the corresponding Method request.

> **注意：** 这是与相应的方法请求中包含的相同的数据ID。


**[SWS_CM_90492]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, the stored sourceID (which has been extracted according to [[SWS_CM_90489](#_bookmark369)]) shall shall be passed as argument sourceID to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90492]**{草案} *[*对于使用配置文件P04m、P07m、P08m或P44m的E2E保护方法响应，根据[[SWS_CM_90489](#_bookmark369)]提取的存储的源ID应作为参数sourceID传递给E2E_protect。_♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_90493]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, STD_MESSAGETYPE_RESPONSE (1) shall be passed as argument messageType to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90493]**{草稿} 对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，应将STD_MESSAGETYPE_RESPONSE（1）作为参数messageType传递给E2E_protect。♩（RS_CM_00400，RS_E2E_08541）


**[SWS_CM_90494]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, in case of a normal response (i.e., neither an application error response message nor an E2E error response message), STD_MESSAGERESULT_OK (0) shall be passed as argument messageResult to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90494]**{草案}*[*对于使用配置文件P04m、P07m、P08m或P44m的E2E保护方法响应，如果是正常响应（即，既不是应用程序错误响应消息也不是E2E错误响应消息），则应将STD_MESSAGERESULT_OK（0）作为参数messageResult传递给E2E_protect。♩（RS_CM_00400，RS_E2E_08541）_

简体中文：**[SWS_CM_90494]**{草案}*[*对于使用配置文件P04m、P07m、P08m或P44m的E2E保护方法响应，如果是正常响应（即，既不是应用程序错误响应消息也不是E2E错误响应消息），则应将STD_MESSAGERESULT_OK（0）作为参数messageResult传递给E2E_protect。♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90495]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, in case of an error response (i.e., either an application error response message or an E2E error response message), STD_MESSAGERESULT_ERROR (1) shall be passed as argument messageResult to E2E_protect._♩(RS_CM_00401, RS_E2E_08541)_

> **[SWS_CM_90495]**{草案} *[* 对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，如果出现错误响应（即应用程序错误响应消息或E2E错误响应消息），则应将STD_MESSAGERESULT_ERROR（1）作为参数messageResult传递给E2E_protect._♩（RS_CM_00401，RS_E2E_08541）_


**[SWS_CM_90469]**{DRAFT} *[*For E2E-protected Method responses, the E2E counter contained in the corresponding Method request shall be used as E2E counter in the call to E2E_protect._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90469]**{草案} *[*对于E2E受保护的方法响应，应使用相应方法请求中包含的E2E计数器作为E2E_protect调用中的E2E计数器。_♩(RS_CM_00400, RS_E2E_08541)_


**Note:** The Method response carries the same dataID and E2E counter as the corresponding Method request to simplify the multiple client scenarios and allow the client to monitor the E2E counter.

> **注意：**方法响应携带与相应方法请求相同的数据ID和E2E计数器，以简化多客户端场景，并允许客户端监视E2E计数器。


**[SWS_CM_90470]**{DRAFT} *[*For E2E-protected Method responses, the E2E protection header shall be added to the message. If the protocol specification of the respective network binding imposes restrictions on the placement of the E2E protection header (e.g., [PRS_SOMEIP_00941] in case of SOME/IP network binding), then these restrictions shall be honored._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90470]**{草案} *[*对于E2E受保护的方法响应，应将E2E保护标头添加到消息中。如果相应网络绑定的协议规范对E2E保护标头的位置施加限制（例如，[PRS_SOMEIP_00941]在SOME/IP网络绑定中），则应遵守这些限制。_♩（RS_CM_00400，RS_E2E_08541）_

### E2E checking the service method response (Client)


**[SWS_CM_90471]**{DRAFT} *[*For E2E-protected Method responses, E2E checking shall be performed within the context of the message reception within the ServiceProxy._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90471]**{草稿} *[*对于E2E保护的方法响应，应在ServiceProxy内消息接收上下文中执行E2E检查。_♩(RS_CM_00400, RS_E2E_08541)_


Figure [7.32](#_bookmark380) shows an overview of the interaction of components involved during the E2E checking of the Method response at the client side.

> 图7.32显示了客户端在端到端检查方法响应时参与组件之间的交互概览。

![](./media/image84.jpeg){width="4.627294400699912in" height="7.4870833333333335in"}

**Figure 7.32:** **Interaction of components during E2E checking of the Method response at the client side**

### E2E checking of the payload


For E2E-protected Method responses, in case serialized data are available the following steps are to be done:

> 对于E2E受保护的方法响应，如果序列化数据可用，则需要执行以下步骤：


**[SWS_CM_90472]**{DRAFT} *[*For the given E2E-protected Method responses, the non-E2E-protected header (if any) of the Method response's serialized data shall be processed._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的E2E受保护的方法响应，应处理Method响应序列化数据的非E2E受保护标头（如果有）。♩（RS_CM_00400，RS_E2E_08541）


**[SWS_CM_90473]**{DRAFT} *[*For the given E2E-protected Method response, E2E_check() shall be invoked on the protected serialized data (passed as argument serializedData to E2E_check()) according to [RS_E2E_08541], [PRS_E2E_00323], and [PRS_E2E_00828]._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的端到端保护的方法响应，根据[RS_E2E_08541]，[PRS_E2E_00323]和[PRS_E2E_00828]，应在受保护的序列化数据（作为参数serializedData传递给E2E_check（））上调用E2E_check（）。_♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90474]**{DRAFT} *[*For the given E2E-protected Method response, the End2EndMethodProtectionProps.dataId shall be passed as argument dataID to E2E_check())._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90474]**{草案} *[*对于给定的E2E受保护的方法响应，End2EndMethodProtectionProps.dataId应作为参数dataID传递给E2E_check())._♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_10465]**{DRAFT} *[*For E2E-protected Method response, the response message shall carry the same E2E counter value as the request message. In case the E2E counter is different, the response message shall be discarded (without any further processing)._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_10465]**{草案} *[*对于E2E受保护的方法响应，响应消息应携带与请求消息相同的E2E计数值。如果E2E计数值不同，则应丢弃响应消息（无需进行任何进一步处理）。_♩（RS_CM_00400，RS_E2E_08541）_


**Implementation Hint:** The E2E counter can be extracted from the resulting state of the E2E_Protect()/E2E_Check() function.

> **实施提示：** E2E 计数器可以从 E2E_Protect()/E2E_Check() 函数的最终状态中提取出来。


**[SWS_CM_90496]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, the End2EndMethodProtectionProps.sourceId shall be passed as argument sourceID to E2E_check._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90496]**{草案} *[* 对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，End2EndMethodProtectionProps.sourceId应作为参数sourceID传递给E2E_check._♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_90497]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, STD_MESSAGETYPE_RESPONSE (1) shall be passed as argument messageType to E2E_check._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90497]**{草案} *[*使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，应将STD_MESSAGETYPE_RESPONSE（1）作为参数messageType传递给E2E_check。♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90498]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, in case of a normal response (i.e., neither an application error response message nor an E2E error response message), STD_MESSAGERESULT_OK (0) shall be passed as argument messageResult to E2E_check._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90498]**{草案} *[* 对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，在正常响应（即非应用程序错误响应消息或E2E错误响应消息）的情况下，应将STD_MESSAGERESULT_OK（0）作为参数messageResult传递给E2E_check。♩（RS_CM_00400，RS_E2E_08541）_

简体中文：**[SWS_CM_90498]**{草案} *[* 对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，在正常响应（即非应用程序错误响应消息或E2E错误响应消息）的情况下，应将STD_MESSAGERESULT_OK（0）作为参数messageResult传递给E2E_check。♩（RS_CM_00400，RS_E2E_08541）_


**[SWS_CM_90499]**{DRAFT} *[*For E2E-protected Method responses using profiles P04m, P07m, P08m, or P44m, in case of an error response (i.e., either an application error response message or an E2E error response message), STD_MESSAGERESULT_ERROR (1) shall be passed as argument messageResult to E2E_check._♩(RS_CM_00401, RS_E2E_08541)_

> **[SWS_CM_90499]**{草案}*[*对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，如果出现错误响应（即应用程序错误响应消息或E2E错误响应消息），则应将STD_MESSAGERESULT_ERROR（1）作为参数messageResult传递给E2E_check.♩（RS_CM_00401、RS_E2E_08541）_

简体中文：**[SWS_CM_90499]**{草案}*[*对于使用配置文件P04m、P07m、P08m或P44m的E2E受保护的方法响应，如果出现错误响应（即应用程序错误响应消息或E2E错误响应消息），则应将STD_MESSAGERESULT_ERROR（1）作为参数messageResult传递给E2E_check.♩（RS_CM_00401、RS_E2E_08541）_


**[SWS_CM_90478]**{DRAFT} *[*In return, for the given E2E-protected Method response, E2E_check shall provide a Result (e2eResult according to [PRS_E2E_00322] of [4]) containing the elements SMState (e2eState according to [PRS_E2E_00322] of [4]) and ProfileCheckStatus (e2eStatus according to [PRS_E2E_00322] of [4])._♩_

> 在返回给定的E2E受保护的方法响应时，E2E_check应提供一个结果（根据[PRS_E2E_00322]的[4]，称为e2eResult），该结果包含SMState（根据[PRS_E2E_00322]的[4]，称为e2eState）和ProfileCheckStatus（根据[PRS_E2E_00322]的[4]，称为e2eStatus）两个元素。

_(RS_E2E_08541, RS_E2E_08534)_


**[SWS_CM_90482]**{DRAFT} *[*The global SMState within its specific Method class of a specific ServiceProxy class shall be updated/overwriten with the element SMState of the Result provided by E2E_check according to [[SWS_CM_90478](#_bookmark383)]._♩(RS_CM_00400, RS_E2E_08541, RS_E2E_08534)_

> **[SWS_CM_90482]**{草案} *[*特定服务代理类的特定方法类的全局SMState应根据[[SWS_CM_90478](#_bookmark383)]更新/覆盖E2E_check提供的结果元素SMState。_♩(RS_CM_00400, RS_E2E_08541, RS_E2E_08534)_


**[SWS_CM_90475]**{DRAFT} *[*For the given E2E-protected Method response, the E2E protection header shall be removed from the serialized data._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90475]**{草稿} *[*對於給定的E2E受保護的方法響應，E2E保護標頭應從序列化數據中移除。♩（RS_CM_00400，RS_E2E_08541）*

### Deserializing the payload


In case the call to E2E_check (according to [[SWS_CM_90473](#_bookmark382)]) indicated a successful E2E check of the response message, further processing of the response message shall take place.

> 如果调用E2E_check（根据[[SWS_CM_90473]（#_bookmark382）]）表明响应消息的E2E检查成功，则应进一步处理响应消息。


**[SWS_CM_90476]**{DRAFT} *[*For the given E2E-protected Method response, the resulting serialized data shall be deserialized according to the rules of the respective network binding (e.g., according to [[SWS_CM_10316](#_bookmark89)] and [[SWS_CM_10429](#_bookmark92)] in case of SOME/IP network binding), resulting in the deserialized inout and out arguments to the Method call or in the deserialized application error._♩(RS_CM_00400, RS_E2E_08541)_

> 对于给定的E2E受保护的方法响应，序列化后的数据必须根据相应网络绑定的规则进行反序列化（例如，在SOME/IP网络绑定的情况下，请参阅[[SWS_CM_10316](#_bookmark89)]和[[SWS_CM_10429](#_bookmark92)])，从而得到反序列化的输入和输出参数以及应用程序错误。_♩(RS_CM_00400, RS_E2E_08541)_


**[SWS_CM_10473]**{DRAFT} **Handling the E2E Error Response** *[*Handling of an E2E error response message (sent due to a detected E2E error in request according to [[SWS_CM_10472](#_bookmark375)]) shall be done in the same way as the reception and the handling of any other error response message according to the used network binding (e.g., according to [[SWS_CM_10429](#_bookmark92)] in case of SOME/IP network binding)._♩(RS_CM_00223, RS_CM_00400, RS_E2E_08541)_

> 处理端到端错误响应：根据[[SWS_CM_10472](#_bookmark375)]检测到的端到端请求错误，处理端到端错误响应消息的方式与使用的网络绑定（例如，使用SOME/IP网络绑定时，参见[[SWS_CM_10429](#_bookmark92)）接收和处理任何其他错误响应消息的方式相同。_♩(RS_CM_00223, RS_CM_00400, RS_E2E_08541)_

### E2E error notification


In case the call to E2E_check (according to [[SWS_CM_90473](#_bookmark382)]) indicated a failed E2E check of the response message, the client application shall get notified in the following way:

> 如果按照[[SWS_CM_90473](#_bookmark382)]的E2E_check调用表明响应消息的E2E检查失败，客户端应用程序将以下列方式获得通知：


**[SWS_CM_90477]**{DRAFT} **E2E Error Return Code** *[*For the given E2E-protected Method response in case of failed E2E check an ara::core::ErrorCode of error domain ara::com::e2e::E2EErrorDomain with value set to ProfileCheckStatus obtained in [[SWS_CM_90478](#_bookmark383)] shall be constructed according to [[SWS_CM_90421](#_bookmark508)]. This ara::core::ErrorCode shall be passed as argument in a call to SetError() on the ara::core::Promise._♩(RS_CM_00400, RS_E2E_08541)_

> **[SWS_CM_90477]**{草稿} **E2E错误返回码** *[*在[[SWS_CM_90478](#_bookmark383)]中获得的ProfileCheckStatus值失败时，对于给定的E2E保护方法响应，应构建一个ara :: core :: ErrorCode，其错误域为ara :: com :: e2e :: E2EErrorDomain。根据[[SWS_CM_90421](#_bookmark508)]，该ara :: core :: ErrorCode应作为参数传递到ara :: core :: Promise上的SetError()调用中。_♩(RS_CM_00400, RS_E2E_08541)_


The handling of normal and application error responses (according to [[SWS_CM_90476](#_bookmark386)]) combined with the handlling of E2E error responses (according to [[SWS_CM_10473](#_bookmark387)]) and the explicit notification of E2E errors detected in the response message (according to [[SWS_CM_90477](#_bookmark389)]) will yield an ara::core::Result containing either

> 处理根据[[SWS_CM_90476](#_bookmark386)的正常和应用程序错误响应，结合根据[[SWS_CM_10473](#_bookmark387)的端到端错误响应，以及根据[[SWS_CM_90477](#_bookmark389)的响应消息中显式检测到的端到端错误的通知，将产生一个ara::core::Result，其中包含正确的响应或错误响应。

- the correct output of the server operation in case of absence of any error

- an ara::core::ErrorCode of the error domain ApApplicationError.errorDomain with the value set to ApApplicationError.errorCode of the raised ApApplicationError in case the ClientServerOperation raised one of its configured possible ClientServerOperation.possibleApErrors and no E2E error was detected in the request message and the response message

> 一个ara::core::ErrorCode的错误域ApApplicationError.errorDomain，其值被设置为在ClientServerOperation提出其配置的可能的ClientServerOperation.possibleApErrors之一，而请求消息和响应消息中未检测到E2E错误时引发的ApApplicationError的值。

- an ara::core::ErrorCode of error domain ara::com::e2e::E2EErrorDomain and the value set to the ProfileCheckStatus of the Result of the E2E_check call at the server side in case an E2E error was detected in the request message at the server side and no E2E error was detected in the response message at the client side

> 在服务器端调用E2E_check的结果中，如果在服务器端检测到E2E错误，而客户端响应消息中未检测到E2E错误，则将ara :: core :: ErrorCode设置为ara :: com :: e2e :: E2EErrorDomain的错误域中的ProfileCheckStatus值。

- an ara::core::ErrorCode of error domain ara::com::e2e::E2EErrorDomain and the value set to the ProfileCheckStatus of the Result of the E2E_check call at the client side in case an E2E error was detected in the response message at the client side

> 在客户端检测到响应消息中出现E2E错误时，将ara::core::ErrorCode设置为ara::com::e2e::E2EErrorDomain的错误域，并将ProfileCheckStatus设置为E2E_check调用的结果。


**[SWS_CM_90483]**{DRAFT} *[*A GetE2EStateMachineState method shall be provided for each Method class of a specific ServiceProxy class._♩(RS_E2E_08534)_

> **[SWS_CM_90483]**{草稿} *[*特定的ServiceProxy类的每个Method类都应提供一个GetE2EStateMachineState方法。_♩(RS_E2E_08534)_


**[SWS_CM_90484]**{DRAFT} *[*The GetE2EStateMachineState method shall provide access to the global SMState of the specific Method class, which was determined by the last run of E2E_check function invoked during the last reception of the Method response (see [[SWS_CM_90482](#_bookmark384)])._♩(RS_E2E_08534)_

> **[SWS_CM_90484]**{草案} *[*GetE2EStateMachineState方法应提供对特定方法类的全局SMState的访问，该SMState是由上一次接收到方法响应时调用的E2E_check函数的最后一次运行所确定的（参见[[SWS_CM_90482](#_bookmark384)]）。_♩(RS_E2E_08534)_

1 ara::com::e2e::SMState GetE2EStateMachineState() const noexcept;

### Timeout supervision


ara::com does not support any timeout supervision for method calls. A lost response message could block some ara::core::Future methods like wait() forever. In case of E2E such a timeout supervision is desired, wherefore the adaptive application is strongly recommended to implement timeout supervision, e.g., by using the ReportCheckpoint() method of the ara::phm::SupervisedEntity or the wait_for(), wait_until(), or the is_ready() methods of the ara::core::Future.

> ara::com不支持任何方法调用的超时监督。丢失的响应消息可能会永远阻塞一些ara::core::Future方法，如wait（）。对于端到端（E2E），强烈建议自适应应用程序实现超时监督，例如使用ara::phm::SupervisedEntity的ReportCheckpoint（）方法或ara::core::Future的wait_for（），wait_until（）或is_ready（）方法。

### End-to-end communication protection for Fields


This section specifies E2E protection for fields. For details of fields see [5]. A field is a data object that can be accessed by a getter and/or setter method. In addition update notifications may be provided to subscribers, whenever the value of the field gets updated. The principle of fields is already specified. This section specifies the E2E protection for fields. The E2E protection for methods Get and Set follows the E2E protection for Methods (chapter [7.7.2](#end-to-end-communication-protection-for-methods)). The specifications [[SWS_CM_10460](#_bookmark353)] and [[SWS_CM_90485](#_bookmark354)] define the parameters for E2E protection of the methods Get() and Set(). The limitations of chapter [7.7.2.1](#limitations-3) are applicable.

> 这一节指定了字段的端到端保护。有关字段的详细信息，请参见[5]。字段是一个可以通过getter和/或setter方法访问的数据对象。此外，当字段的值更新时，还可以向订阅者提供更新通知。字段的原理已经指定。本节指定了字段的端到端保护。方法Get和Set的端到端保护遵循方法的端到端保护（第7.7.2节）。规范[[SWS_CM_10460]]和[[SWS_CM_90485]]定义了方法Get()和Set()的端到端保护的参数。第7.7.2.1节的限制适用。


The E2E protection for Update follows the E2E protection for events (chapter [7.7.1](#end-to-end-communication-protection-for-events)). The specifications [[SWS_CM_90402](#_bookmark339)] and [[SWS_CM_90433](#_bookmark340)] define the parameters for E2E protection of the update event. The limitations of chapter [7.7.1.1](#limitations-2) are applicable.

> 更新的端到端保护遵循事件的端到端保护（第7.7.1章）。规范[[SWS_CM_90402](#_bookmark339)]和[[SWS_CM_90433](#_bookmark340)]定义了更新事件的端到端保护的参数。第7.7.1.1章的限制适用。


E2E results OK and OK_SOME_LOST are successful results. E2E results ERROR, REPEATED, WRONGSEQUENCE, NOTAVAILABLE and NONEWDATA are considered error results.

> E2E 结果OK和OK_SOME_LOST是成功的结果。E2E 结果ERROR、REPEATED、WRONGSEQUENCE、NOTAVAILABLE和NONEWDATA被视为错误结果。


There are E2E profiles 4m, 7m, 8m or 44m for the protection of methods (Get, Set). Also the other E2E profiles can be used for the protection of methods. But in this case some parameters of SOME/IP are not protected.

> 在保护方法（Get、Set）时可以使用E2E配置4m、7m、8m或44m。也可以使用其他E2E配置，但在这种情况下，SOME/IP的一些参数不受保护。

### Send a GET message


The client application calls the Get() function at ara::com without arguments. A future for this method call is created by ara::com. Data of method Get() are serialized.

> 客户端应用程序在ara::com上调用Get（）函数，不带任何参数。 ara::com创建了这个方法调用的未来。 Get（）方法的数据被序列化。


The E2E serialization follows the specification of [[SWS_CM_90458](#_bookmark359)] with the following exception: The result is a list without parameters because a Get() method has no IN or INOUT parameters.

> E2E序列化遵循[[SWS_CM_90458](#_bookmark359)]的规范，但有一个例外：结果是一个没有参数的列表，因为Get()方法没有IN或INOUT参数。


The parameters dataID, sourceID, messageType and messageResult for E2E_XXmProtect method are passed as described in chapter [7.7.2.2.2](#e2e-protection-of-the-payload).

> 参数dataID、sourceID、messageType和messageResult用于E2E_XXmProtect方法的传递方式参见第7.7.2.2.2章节（#e2e-protection-of-the-payload）。


After E2E protection the non E2E protected part is added to the message as described in [[SWS_CM_10464](#_bookmark361)].

> 在E2E保护之后，按照[[SWS_CM_10464](#_bookmark361)]中所述，将未受E2E保护的部分添加到消息中。


Figure [7.33](#_bookmark393) shows the message flow of sending a Get() method. The figure does not list all details of E2E protection, e.g. functions of CRC library are omitted in this figure.

> 图7.33显示了发送Get()方法的消息流。该图中没有列出E2E保护的所有细节，例如CRC库的功能被省略了。

![](./media/image85.png)![](./media/image86.png)

**Figure 7.33:** **Send a GET Message**

### Receive a GET message


The message is received by the Publisher application. The Publisher application is a server application.

> 消息被发布者应用程序接收。发布者应用程序是一个服务器应用程序。


The E2E check of the received message follows the specification of chapter [7.7.2.3](#e2e-checking-the-service-method-request-server).

> 接收到的消息的端到端检查遵循第7.7.2.3章节的规范。


The type of the message to be sent back to the client is RESPONSE or ERROR. That depends on the result of the E2E check. If the E2E check fails, then the Return Code of the ERROR message is initialized with an E2E error code (See [PRS_SOMEIP_00191]).

> 根据端到端检查的结果，发送回客户端的消息类型可以是RESPONSE或ERROR。如果端到端检查失败，则将ERROR消息的返回码初始化为端到端错误码（参见[PRS_SOMEIP_00191]）。


Figure [7.34](#_bookmark395) shows the reception of a GET message. The E2E protected part of the serialized header is checked for E2E errors. If the incoming message was received with an E2E error, then the Publisher is informed through the E2E error handler (see chapter [7.7.2.3.3](#e2e-error-notification)). In this case no value is retrieved from Publisher.

> 图7.34显示了接收GET消息的情况。检查序列化头部的E2E受保护部分是否有E2E错误。如果收到的消息有E2E错误，那么发布者将通过E2E错误处理程序（参见第7.7.2.3.3节）得到通知。在这种情况下，不会从发布者处获取任何值。


If the incoming message is received without E2E error, the GetHandler of the Publisher application is called.

> 如果收到的消息没有终端到终端（E2E）错误，将会调用发布者应用程序的GetHandler。


Independent of the result of the E2E check a response message is sent to the client (caller of the Get() function). The message sent back to the client has message type type RESPONSE and return code either (OK) or (ERROR).

> 无论E2E检查的结果如何，都会向客户端（调用Get()函数的客户端）发送响应消息。发回客户端的消息类型为RESPONSE，返回码可以是（OK）或（ERROR）。


This response message is E2E protected the same way as the Get() message as described in chapters [7.7.2.4.1](#serializing-the-e2e-error-response-payload), [7.7.2.4.2](#serializing-the-response-payload) and [7.7.2.4.3](#e2e-protection-of-the-response-payload).

> 这个响应消息的E2E保护方式与在[7.7.2.4.1]（＃序列化e2e错误响应有效载荷），[7.7.2.4.2]（＃序列化响应有效载荷）和[7.7.2.4.3]（＃e2e保护响应有效载荷）中描述的Get（）消息相同。

![](./media/image91.png)

**Figure 7.34:** **Receive a GET Message**

### Receive a response to a GET message


The reception of an E2E protected response message is described in chapter [7.7.2.5](#e2e-checking-the-service-method-response-client).

> 接收E2E受保护的响应消息的方法在第7.7.2.5章节中有描述。


If the message is received with an E2E error, then the E2E Errorhandler of the client is called. The future of the Get() function is set to ready state with an error code. That is described in chapter [7.7.2.5](#e2e-checking-the-service-method-response-client).

> 如果消息收到E2E错误，则会调用客户端的E2E错误处理程序。将Get（）函数的未来设置为具有错误代码的就绪状态。这在[7.7.2.5]（#e2e-checking-the-service-method-response-client）章节中有所描述。


The received message is of type RESPONSE or ERROR (see [PRS_SOMEIP_00055]). Type ERROR indicates that an E2E error occurred at the server site. If a message of type ERROR is received with Return Code of E2E error (indicating that the Publisher received the Get request with an E2E error) then the E2E Errorhandler of the Client Application is called. The future of the Get() function is set to ready state with an error code.

> 接收到的消息类型为RESPONSE或ERROR（参见[PRS_SOMEIP_00055]）。类型ERROR表示在服务器端发生了端到端（E2E）错误。如果收到类型为ERROR的消息，其返回码为E2E错误（表示发布者收到的Get请求发生了E2E错误），则会调用客户端应用程序的E2E错误处理程序。将Get（）函数的未来状态设置为带有错误码的错误状态。


It is up to the Client application how to react to a call of its Errorhandler.

> 客户端应用程序如何对其错误处理程序的调用做出反应，由客户端应用程序决定。


If the RESPONSE message is received without E2E errors then the future is updated with the received value of the Publishers field. The future becomes ready and the Client application can use this value.

> 如果接收到响应消息没有端到端错误，则将接收到的发布者字段的值更新到未来。未来就可以准备好，客户端应用程序可以使用此值。


If a RESPONSE message to an outgoing Get message does not arrive at all, then the client application is not informed if the value was retrieved from the remote application. The future of Field.Get() is not updated to state ready. In this case the client application can send the Get message again to the remote application to retrieve the value, or initiate its own error handling. A timeout supervision (chapter [7.7.2.6](#timeout-supervision)) may unlock the future. Figure [7.35](#_bookmark397) shows reception of a message from the server.

> 如果一条回复消息没有回复到发出的Get消息，那么客户端应用程序将不会被通知值是否从远程应用程序中获取到。Field.Get()的未来状态不会被更新。在这种情况下，客户端应用程序可以重新发送Get消息给远程应用程序以获取值，或者启动自己的错误处理。超时监视（第7.7.2.6节）可能会解锁未来。图7.35显示了从服务器接收消息。

![](./media/image96.png)Client Application

**Figure 7.35:** **Receive response to a GET Message**

### Send a SET message


The E2E serialization follows the specification of [[SWS_CM_90458](#_bookmark359)]. Only one parameter is serialized: The parameter to be set at the publisher application.

> E2E序列化遵循[[SWS_CM_90458](#_bookmark359)]的规范。只有一个参数被序列化：要在发布应用程序中设置的参数。

The parameters dataID, sourceID, messageType and messageResult for


E2E_XXmProtect method are passed as described in chapter [7.7.2.2.2](#e2e-protection-of-the-payload).

> E2E_XXmProtect 方法按照第7.7.2.2.2章节中所述通过。


After E2E protection the non E2E protected part is added to message as described in specification [[SWS_CM_10464](#_bookmark361)].

> 在E2E保护之后，根据规范[[SWS_CM_10464](#_bookmark361)]，非E2E保护部分将被添加到消息中。


Figure [7.36](#_bookmark399) shows the message flow of sending a Set() method. The figure does not list all details of E2E protection, e.g. functions of libraries E2ELib and CrcLib are omitted in this figure.

> 图7.36显示了发送Set（）方法的消息流。该图不列出E2E保护的所有细节，例如库E2ELib和CrcLib的功能在此图中被省略。

![](./media/image102.png)The client application calls the Set() function at ara::com with one argument (the value that shall overwrite the field's value).

![](./media/image103.png)

**Figure 7.36:** **Send a SET Message**

### Receive a SET message


The message is received by the Publisher application. The Publisher application is a server application.

> 消息被发布者应用程序接收。发布者应用程序是一个服务器应用程序。


The E2E check of the received message follows the specification of chapter [7.7.2.3](#e2e-checking-the-service-method-request-server).

> 接收到的消息的端到端检查遵循第7.7.2.3章节的规范。


If the incoming message is received without E2E error the SetHandler of the Publisher application is called. The SetHandler returns the value to be written to the Publisher's field. The returned value may be identical to the parameter of the SET message (successful update). But there is also the possibility that an update could not be performed completely. If the parameter of the SET message is out of range then the field may be left unchanged or the field is updated by a value inside the field's range. The type of the response message is RESPONSE.

> 如果收到的消息没有端到端错误，则会调用发布者应用程序的SetHandler。SetHandler返回要写入发布者字段的值。返回的值可能与SET消息的参数相同（更新成功）。但也有可能更新不能完全执行。如果SET消息的参数超出范围，则可以保持字段不变，或者将字段更新为字段范围内的值。响应消息的类型是RESPONSE。


If the incoming message is received with an E2E error, then the Publisher is informed through the E2E error handler (see chapter [7.7.2.3.3](#e2e-error-notification)). In this case The SetHandler of the Publisher is not called. The type of the response message is ERROR. If the E2E_Check fails the Return Code of the ERROR message is initialized with an E2E error code (See [PRS_SOMEIP_00191]).

> 如果收到的消息带有端到端错误，则会通过端到端错误处理程序（参见第7.7.2.3.3节）通知发布者。在这种情况下，不会调用发布者的SetHandler。响应消息的类型是ERROR。如果E2E_Check失败，ERROR消息的返回码将被初始化为端到端错误码（参见PRS_SOMEIP_00191）。


The type of the message to be sent back to the client is RESPONSE or ERROR. That depends on the result of the E2E check.

> 回发给客户端的消息类型是RESPONSE或ERROR，这取决于端到端检查的结果。


The message to be returned (type ERROR or RESPONSE) is serialized, E2E protected and sent back to the client.

> 返回的消息（类型为ERROR或RESPONSE）经过序列化、端到端保护，然后发回客户端。


This response message is E2E protected the same way as the Get() message as described in chapters [7.7.2.4.1](#serializing-the-e2e-error-response-payload), [7.7.2.4.2](#serializing-the-response-payload) and [7.7.2.4.3](#e2e-protection-of-the-response-payload).

> 这个响应消息的端到端保护方式与在[7.7.2.4.1](#serializing-the-e2e-error-response-payload)、[7.7.2.4.2](#serializing-the-response-payload)和[7.7.2.4.3](#e2e-protection-of-the-response-payload)章节中描述的Get（）消息相同。


Figure [7.37](#_bookmark401) shows the reception of a SET message. The E2E protected part of the serialized header is checked for E2E errors. If the incoming message was received with an E2E error, then the Publisher is informed through the E2E error handler. The Publisher's field is not updated and no value is retrieved from Publisher's field.

> 图7.37显示了接收SET消息的情况。检查序列化头的端到端受保护部分是否有端到端错误。如果接收到的消息有端到端错误，那么发布者将通过端到端错误处理程序被通知。发布者的字段不会被更新，也不会从发布者的字段中检索任何值。

![](./media/image85.png)

**Figure 7.37:** **Receive a SET Message**

### Receive a response to a SET message


The reception of an E2E protected response message is described in chapter [7.7.2.5](#e2e-checking-the-service-method-response-client).

> 接收E2E受保护的响应消息在第7.7.2.5章节中有描述。


If the message is received with an E2E error, then the Errorhandler of the client is called. The future of the Set() function is set to ready state with an error code ().That is described in chapter [7.7.2.5.3](#e2e-error-notification-1).

> 如果收到E2E错误的消息，则会调用客户端的错误处理程序。Set（）函数的未来被设置为带有错误代码（）的就绪状态。这在[7.7.2.5.3]（＃e2e-error-notification-1）章节中描述。


The received message is of type RESPONSE or ERROR (see [PRS_SOMEIP_00055]). Type ERROR indicates that an E2E error occurred at the server site. If a message of type ERROR is received with Return Code of E2E error (indicating that the Publisher received the Set request with an E2E error) then the Errorhandler of the Client Application is called. The future of the Set() function is set to ready state with an error code.

> 收到的消息类型为RESPONSE或ERROR（参见[PRS_SOMEIP_00055]）。类型ERROR表示服务器端发生E2E错误。如果收到类型为ERROR的消息，且返回代码为E2E错误（表示发布者收到带有E2E错误的Set请求），则会调用客户端应用程序的错误处理程序。Set（）函数的未来将以错误代码设置为就绪状态。


It is up to the Client application how to react to a call of its Errorhandler.

> 客户端应用如何对错误处理程序的调用做出反应，由客户端应用决定。


If the RESPONSE message is received without E2E errors then the future is updated with the received value of Publisher's field. The future becomes ready and the Client application can use this value.

> 如果收到响应消息没有端到端错误，那么将使用发布者字段的接收值更新未来。未来变得准备就绪，客户端应用程序可以使用这个值。


If a RESPONSE message to an outgoing Set message does not arrive at all then the client application is not informed about the value which is set at the remote application. The future of Field.Set() is not updated to state ready. In this case the client application can send the Set message again to the remote application in order to set the intended value and receive the set value or initiate its own error handling. A timeout supervision (chapter [7.7.2.6](#timeout-supervision)) can unlock the future.

> 如果一个响应消息没有回应一个发出的设置消息，那么客户端应用程序就不会被告知远程应用程序设置的值。Field.Set()的未来状态不会被更新为就绪状态。在这种情况下，客户端应用程序可以再次向远程应用程序发送设置消息，以便设置所需的值并接收设置的值，或者启动自己的错误处理。超时监督（第[7.7.2.6](#timeout-supervision)节）可以解锁未来。


Figure [7.38](#_bookmark403) shows reception of a response. This message is of type RESPONSE or ERROR (see [PRS_SOMEIP_00055]) and similar to the reception of a response to a GET message.

> 图7.38显示了响应的接收。 此消息类型为RESPONSE或ERROR（参见PRS_SOMEIP_00055），类似于接收GET消息的响应。

![](./media/image96.png)Client Application

**Figure 7.38:** **Receive response to a SET Message**

### Send an UPDATE message


The application triggers the sending of update messages to subscribers. The update of a field's value by a SetHandler() is a reason to trigger update messages.

> 应用程序触发发送更新消息给订阅者。通过SetHandler()更新字段值是触发更新消息的原因。


An update of a subscriber is an event. The E2E protection of an update is described in chapter [7.7.1.2](#publisher). The update message is sent to every subscriber to the publisher's field.

> 一个订阅者的更新是一个事件。章节[7.7.1.2](#publisher)描述了更新的端到端保护。更新消息被发送给发布者字段的每个订阅者。

Figure [7.39](#_bookmark405) shows sending of field update messages.

![](./media/image98.png)

**Figure 7.39:** **Send an UPDATE Message**

### Receive an UPDATE message


The loop over samples indicates that more than one update messages are collected and evaluated by E2E state machine. In the case of E2E fields this is rather a theoretical option. Usually the number of received update messages is zero or one.

> 循环遍历样本表明，E2E状态机收集并评估了多个更新消息。在E2E字段的情况下，这是一种理论上的选择。通常收到的更新消息数量为零或一个。


The reception of E2E protected fields is described in chapter [7.7.1.3](#subscriber---getnewsamples).

> 接收E2E受保护字段的描述位于第7.7.1.3章节（订阅者-获取新样本）。


The reception of E2E protected fields follows the principle of E2E protected events (see figure [7.27](#_bookmark345) in chapter [7.7.1](#end-to-end-communication-protection-for-events)). This reception of E2E protected fields demands periodic communication.

> 接收E2E受保护字段遵循E2E受保护事件的原则（见第7.7.1章节中的图7.27）。这种E2E受保护字段的接收需要定期通信。


If one or more update messages are received the E2E state machine provides one of the following results: OK, ERROR, REPEATED, NONEWDATA, WRONGSEQUENCE (See [PRS_E2E_00597]). Only result OK indicates that the received value is valid.

> 如果收到一个或多个更新消息，E2E状态机会提供以下结果之一：OK、ERROR、REPEATED、NONEWDATA、WRONGSEQUENCE（参见[PRS_E2E_00597]）。只有结果OK表示收到的值有效。

Figure [7.40](#_bookmark407) shows reception of a field update message.

![](./media/image90.png)

**Figure 7.40:** **Receive an UPDATE Message**

## Functional cluster lifecycle


The Communication Management functional cluster provides the primary communication infrastructure for Adaptive AUTOSAR, which is used by State Management. Because the interaction between State Management and Execution Management has a key impact on the lifecycle of the entire Adaptive AUTOSAR platform, the availability of communication infrastructure is essential for system state changes. AUTOSAR assumes the availability of this communication in the states Startup and Shutdown to the extent necessary to perform these states.

> 管理通信功能群提供了Adaptive AUTOSAR的主要通信基础设施，由状态管理使用。由于状态管理和执行管理之间的交互对Adaptive AUTOSAR平台的整个生命周期有关键影响，因此通信基础设施的可用性对于系统状态的更改至关重要。AUTOSAR假设在启动和关闭状态下提供必要的通信可用性以执行这些状态。

### Startup


No special startup handling is needed for the Communication Management functional cluster. However, Communication Management provides the communication infrastructure used by State Management. Therefore, it is recommended to start Communication Management in parallel with Execution Management or after starting Execution Management but before starting State Management. Once State Management and Execution Management are operational, they should take control of the Communication Management lifecycle.

> 没有针对通信管理功能集群需要特殊的启动处理。但是，通信管理提供了状态管理使用的通信基础设施。因此，建议与执行管理并行启动通信管理，或在启动执行管理后但在启动状态管理之前启动通信管理。一旦状态管理和执行管理可操作，它们应该控制通信管理的生命周期。


Please note that the specific implementation details and configuration of Language Binding, Communication Binding and Network Binding made by the integrator affects the specific requirements for a given deployment.

> 请注意，集成商所做的语言绑定、通信绑定和网络绑定的具体实现细节和配置会影响特定部署的具体要求。

### Shutdown


Control over this state of the Communication Management functional cluster lifecycle should be handled by State Management and Execution Management. However, Communication Management provides the communication infrastructure used by State Management. Therefore, the Communication Management functional cluster should maintain the functionality required by State Management as long as it is necessary.

> 控制这种通信管理功能簇生命周期状态的控制应由状态管理和执行管理处理。但是，通信管理提供由状态管理使用的通信基础设施。因此，只要有必要，通信管理功能簇应保持状态管理所需的功能。


Please note that the specific implementation details and configuration of Language Binding, Communication Binding, and Network Binding affects the shutdown strategy for a particular deployment. It is the responsibility of the system integrator to carefully consider when the Communication Management elements will terminate to ensure the success of the system shutdown and notification of Applications. In particular the system integrator should provide a concept how to notify application processes still holding SamplePtr's to memory elements of communication management.

> 请注意，语言绑定、通信绑定和网络绑定的具体实现细节和配置会影响特定部署的关机策略。系统集成商负责仔细考虑何时终止通信管理元素，以确保系统关机和应用程序通知的成功。特别是系统集成商应提供一种概念，以便通知仍持有SamplePtr的应用程序进程以访问通信管理的内存元素。

## Communication Interfaces


ara::com is the interface that AUTOSAR Adaptive Applications use to interact with the Communication Management.

> AUTOSAR自适应应用使用ara::com作为与通信管理交互的界面。


In this chapter, the functional specifications for the communication interfaces of ara::com are described. The actual C++ APIs of ara::com are described in chapter [8](#communication-api-specification).

> 在本章中，将描述ara::com的通信接口的功能规格。ara::com的实际C++ API将在第8章（通信API规范）中描述。

### Offer service


For the service offering C++ API reference, see chapter [8.1.3.2](#offer-service-1).

> 对于提供C++ API参考的服务，请参见第8.1.3.2章节（#offer-service-1）。


**[SWS_CM_00102]**{DRAFT} **Uniqueness of offered service on local machine** *[*Upon a call to OfferService() the Communication Management shall check the offered service for uniqueness on the local machine using information available to the service discovery. If the implementation detects a duplication (i.e., a service with the same serviceInstanceId, serviceInterfaceId and majorVersion on the same VLAN (e.g.according to [constr_1723] of [6]) is already registered, the requested service offering shall not start, and the function shall return positively after error is logged._♩ (RS_CM_00200, RS_CM_00101, RS_CM_00108)_

> **[SWS_CM_00102]**{草案} **本地机器上提供的服务的唯一性** *[*调用OfferService（）时，通信管理应使用可用于服务发现的信息检查所提供的服务的唯一性。如果实现检测到重复（即，在相同VLAN上具有相同serviceInstanceId，serviceInterfaceId和majorVersion的服务（例如，根据[6]的[constr_1723]）已经注册，则不会启动请求的服务提供，并且在记录错误后，该函数将正面返回。_♩（RS_CM_00200，RS_CM_00101，RS_CM_00108）_

简体中文：**[SWS_CM_00102]**{草案} **本地机器上提供的服务的唯一性** *[*调用OfferService（）时，通信管理应使用可用于服务发现的信息检查所提供的服务的唯一性。如果实现检测到重复（即，在同一VLAN上具有相同serviceInstanceId，serviceInterfaceId和majorVersion的服务（例如，根据[6]的[constr_1723]）已经注册），则不会启动请求的服务提供，并且在记录错误后，该函数将正面返回。_♩（RS_CM_00200，RS_CM_00101，RS_CM_00108）_


**Note: System/vehicle-wide Uniqueness of offered service** (see [RS_CM_00108]); System/vehicle-wide uniqueness should be targeted in a best-effort way, i.e., if knowledge about a a remotely offered service is available, this knowledge shall be used in the uniqueness check.

> 注意：系统/车辆范围内的提供服务的唯一性（参见RS_CM_00108）；应尽最大努力实现系统/车辆范围内的唯一性，即，如果有关远程提供服务的知识可用，则应在唯一性检查中使用这些知识。


**[SWS_CM_00103] Network binding where a service is offered** *[*When a new service is offered by the application, the Communication Management shall check over which network binding this service shall be offered. This information is configured in the class of ServiceInterfaceDeployment referencing the offered ServiceInterface in the role serviceInterface. If the class is SomeipServiceInterfaceDeployment then the Some/IP network binding shall handle the OfferService call as described in [[SWS_CM_00203](#_bookmark45)]. If the class is DdsServiceInterfaceDeployment, then the DDS network binding shall handle the OfferService call as described in [[SWS_CM_11001](#_bookmark197)]. If the class is UserDefinedServiceInterfaceDeployment, the Communication Management implementer is responsible for implementing the OfferService method in an appropriate way._♩(RS_CM_00101)_

> 当应用程序提供新服务时，通信管理将检查此服务将通过哪种网络绑定提供。此信息配置在引用所提供的ServiceInterface角色serviceInterface的ServiceInterfaceDeployment类中。如果类是SomeipServiceInterfaceDeployment，则Some / IP网络绑定应按[[SWS_CM_00203]（＃_bookmark45）]中描述的方式处理OfferService调用。如果类是DdsServiceInterfaceDeployment，则DDS网络绑定应按[[SWS_CM_11001]（＃_bookmark197）]中描述的方式处理OfferService调用。如果类是UserDefinedServiceInterfaceDeployment，则通信管理实现者负责以适当的方式实现OfferService方法。_♩（RS_CM_00101）_


**[SWS_CM_00104]**{DRAFT} **Network binding for StopOfferService** *[*When a service calls StopOfferService, the Communication Management shall check over which network binding the offered service shall be stopped. This information is configured in the class of ServiceInterfaceDeployment referencing the offered ServiceInterface in the role serviceInterface. If the class is SomeipServiceInterfaceDeployment then the Some/IP network binding shall handle the mapping of the StopOfferService method as described in [[SWS_CM_00204](#_bookmark46)]. If the class is DdsServiceInterfaceDeployment, then the DDS network binding shall

> **[SWS_CM_00104]**{草案} **停止提供服务的网络绑定** *[*当服务调用StopOfferService时，通信管理应检查停止提供的服务的网络绑定。此信息配置在ServiceInterfaceDeployment类中，引用角色serviceInterface中提供的ServiceInterface。如果类是SomeipServiceInterfaceDeployment，则Some/IP网络绑定应按照[[SWS_CM_00204](#_bookmark46)]中描述的方式处理StopOfferService方法。如果类是DdsServiceInterfaceDeployment，则DDS网络绑定应处理


handle the mapping of the StopOfferService as described in [[SWS_CM_11005](#_bookmark207)]. If the class is UserDefinedServiceInterfaceDeployment, the Communication Management implementer is responsible for implementing the StopOfferService method in an appropriate way._♩(RS_CM_00101)_

> 处理根据[[SWS_CM_11005](#_bookmark207)]所描述的StopOfferService的映射。如果类是UserDefinedServiceInterfaceDeployment，那么通信管理实施者负责以适当的方式实现StopOfferService方法。♩(RS_CM_00101)

### Service skeleton creation


For the service skeleton creation C++ API reference, see chapter [8.1.3.3](#service-skeleton-creation-1).

> 对于C++ API参考服务骨架创建，请参见第8.1.3.3章节。


**[SWS_CM_10410] InstanceIdentifier check during the creation of service skeleton** *[*The Communication Management shall check the value of the InstanceIdentifier argument: the identifier shall be unique. If the same InstanceIdentifier is used for the creation of more than one skeleton instance of the same service shall be handled as violation according to [SWS_CORE_00003]._♩(RS_CM_00101)_

> 通信管理在创建服务骨架时应检查InstanceIdentifier参数的值：标识符应该是唯一的。如果为同一服务的多个骨架实例使用相同的InstanceIdentifier，则根据[SWS_CORE_00003]处理为违反。_♩（RS_CM_00101）_


**[SWS_CM_10450] InstanceSpecifier check during the creation of service skeleton** *[*The Communication Management shall check the value of the InstanceSpecifier argument: the specifier shall be unique, using the same instance specifier for the creation of more than one skeleton instance of the same service shall be handled as violation according to [SWS_CORE_00003]._♩(RS_CM_00101, RS_AP_00137)_

> 通信管理在创建服务骨架时应检查InstanceSpecifier参数的值：该指定符必须是唯一的，使用相同的实例指定符在同一服务中创建多个骨架实例将被视为违反[SWS_CORE_00003]的规定。♩（RS_CM_00101，RS_AP_00137）


**[SWS_CM_10451] InstanceIdentifierContainer check during the creation of service skeleton** *[*The Communication Management shall check the value of the InstanceIdentifierContainer argument:

> 通信管理在创建服务骨架时应检查InstanceIdentifierContainer参数的值。

- the container size shall be bigger than zero
- the identifiers of the container shall be unique
- the identifiers of the container shall correspond to the same instance specifier.


If there are failing checks, and the same InstanceIdentifier is used for the creation of more than one skeleton instance of the same service shall be handled as violation according to [SWS_CORE_00003]._♩(RS_CM_00101)_

> 如果检查失败，且使用同一个InstanceIdentifier为同一服务创建多个骨架实例，根据[SWS_CORE_00003]应将其视为违规行为。(RS_CM_00101)

### Send event


For the event sending C++ API reference, see chapter [8.1.3.4](#send-event-1).

> 对于发送 C++ API 参考，请参阅[8.1.3.4]章节(#send-event-1)。


To support sending of events where the data is owned by the application and continuously updated and the data is explicitly created for sending, the Send method shall be provided in two ways: One where the application is owner of the data and the Send method makes a copy for sending and one where Communication Management is responsible for the data and the application is not allowed to do anything with the data after sending.

> 为了支持发送事件，其中数据由应用程序拥有并不断更新，而且数据是明确为发送而创建的，发送方法应提供两种方式：一种是应用程序拥有数据，发送方法会制作副本发送；另一种是通信管理负责数据，发送后应用程序不得对数据做任何处理。


**[SWS_CM_99031] Send event where application is responsible for the data** *[*As defined in [[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)], the Send method of the specific Event class where the application is responsible for the data and the Communication Management creates a copy for sending shall be used whenever the application wants to work further with the data._♩(RS_CM_00201)_

> 根据[[SWS_CM_00162](#sws_cm_00162-send-event-where-application-is-responsible-for-the-data)的定义，应该使用特定事件类的发送方法，其中应用程序负责数据，通信管理创建一个副本用于发送，每当应用程序想要进一步处理数据时。♩(RS_CM_00201)


**[SWS_CM_99032] Send event where Communication Management is responsible for the data** *[*As defined in [[SWS_CM_90437](#_bookmark532)], the Send method of the specific Event class where the Communication Management is responsible for the data and the application is not allowed to access the data after sending shall be used whenever the data is created explicitly for sending and no further processing is happening afterward by the application itself.

> 根据[[SWS_CM_90437](#_bookmark532)]的定义，当数据是专门为发送而创建的，且应用程序在发送之后不允许访问数据时，应使用特定事件类别的发送方法，其中通信管理负责数据，而应用程序不允许访问数据。


Before sending the event, the corresponding data has to be requested from the Communication Management (see [[SWS_CM_99033](#_bookmark415)]) and filled with the respective data._♩ (RS_CM_00201)_

> 在发送事件之前，必须从通信管理（参见[[SWS_CM_99033](#_bookmark415)])请求相应的数据，并用相应的数据填充。(RS_CM_00201)


**[SWS_CM_99033] Allocating data for event transfer** *[*Data shall be requested by calling the Allocate method of the specific Event class as defined in [[SWS_CM_90438](#sws_cm_90438-allocate-data-when-communication-management-is-responsi--ble-for-the-data)]. By calling the Send method with the data, it is ensured that the data will be freed by the Communication Management._♩(RS_CM_00201)_

> **[SWS_CM_99033] 为事件传输分配数据** *[*数据应通过调用特定事件类的Allocate方法来请求，该特定事件类如[[SWS_CM_90438](#sws_cm_90438-allocate-data-when-communication-management-is-responsi--ble-for-the-data)]中所定义。通过调用带有数据的Send方法，可以确保通信管理将释放数据。_♩(RS_CM_00201)_


**[SWS_CM_99034]** *[*Since the SampleAllocateePtr pointer type behaves like a std::unique_ptr, the ownership of the pointer has to be transferred via std::move for utilizing zero-copy optimizations._♩(RS_CM_00201)_

> 由于SampleAllocateePtr指针类型的行为就像std::unique_ptr，因此必须通过std::move转移指针的所有权，以实现零拷贝优化。

### Processing of service methods


For the processing of service methods C++ API reference, see chapter [8.1.3.7](#processing-of-service-methods-1).

> 对于服务方法C++ API参考，请参见第8.1.3.7章节。


The _Method Call Processing Mode_ defined in [[SWS_CM_00198](#sws_cm_00198draft-set-service-method-processing-mode)] allows the implementation providing the service method to select how the incoming service method invocations are processed. The selection is valid for all the methods of the specific ServiceSkeleton instance.

> 在[[SWS_CM_00198](#sws_cm_00198draft-set-service-method-processing-mode)]中定义的_Method Call Processing Mode_允许提供服务方法的实现来选择如何处理传入的服务方法调用。此选择对特定ServiceSkeleton实例的所有方法有效。


**[SWS_CM_10411]**{DRAFT} **Service method processing modes** *[*The following service method processing modes shall be supported:

> **[SWS_CM_10411]**{草案} **服务方法处理模式** *[*以下服务方法处理模式应支持：


- **Polling**: Instead of calling a provided service method, the Communication Management software collects incoming service method invocations. The processing of each invocation is explicitly triggered by the implementation providing the service method using the mechanism defined in [[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)].

> **轮询**：通信管理软件不是调用提供的服务方法，而是收集传入的服务方法调用。每个调用的处理都是由提供服务方法的实现使用[[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)]中定义的机制显式触发的。

- **Event-driven, concurrent**: The Communication Management software activates the invoked service method when the invocation arrives. Consumer concurrent calls are allowed and will be processed concurrently on provider side by using different threads.

> 事件驱动、并发：当调用到达时，通信管理软件会激活被调用的服务方法。消费者的并发调用被允许，并且会在提供者端使用不同的线程进行并发处理。

This is the default mode.


- **Event-driven, sequential**: The Communication Management software activates the invoked service method when the invocation arrives. Consumer concurrent

> 事件驱动、顺序：当调用到达时，通信管理软件激活被调用的服务方法。消费者并发。


calls are allowed, but will not be processed concurrently on provider side, by instead executing them one after the other to avoid the need of synchronization mechanisms in the implementation providing the service method.

> 呼叫允许，但不会被同时在提供者端处理，而是按顺序执行，以避免在提供服务方法的实现中需要同步机制。

_♩(RS_CM_00211)_


The ProcessNextMethodCall defined in [[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)] allows the implementation providing the service method to trigger the execution of the next service consumer method call at a specific point of time if the processing mode is set to Polling.

> 这个在[SWS_CM_00199](#sws_cm_00199-process-service-method-invocation)中定义的ProcessNextMethodCall允许提供服务方法的实现在特定的时间点，如果处理模式设置为轮询，触发下一个服务消费者方法调用的执行。

### Registering get handlers for fields


For the registering get handlers for fields C++ API reference, see chapter [8.1.3.8](#registering-get-handlers-for-fields-1).

> 对于注册字段的C++ API参考，请参阅第8.1.3.8章。


**[SWS_CM_10412]**{DRAFT} **Invoking GetHandlers** *[*The registered GetHandler shall be called by the implementation whenever the Communication Management receives a Get._♩(RS_CM_00218)_

> **[SWS_CM_10412]**{草案} **调用GetHandlers** *[*当通信管理收到Get时，实现应调用已注册的GetHandler。_♩(RS_CM_00218)_

### Registering set handlers for fields


For the registering set handlers for fields C++ API reference, see chapter [8.1.3.9](#registering-set-handlers-for-fields-1).

> 对于注册字段的处理程序的C++ API参考，请参见第8.1.3.9章。


**[SWS_CM_10413]**{DRAFT} **Invoking SetHandlers** *[*The registered SetHandler shall be called by the implementation whenever the Communication Management receives a Set._♩(RS_CM_00218)_

> **[SWS_CM_10413]**{草案} **调用SetHandlers** *[*注册的SetHandler将由实现在收到Set时调用。_♩(RS_CM_00218)_


Note: Upon a call to the SetHandler, the Service Provider has to validate the received field value (it can accept, modify or reject it). After that, it sets the new value in the future object (see [[SWS_CM_00116](#_bookmark546)]). If the SetHandler needs to access the current field value to validate the new field value, the skeleton implementation has to provide a replica of the underlying field value that is accessible from application level.

> 注意：在调用SetHandler时，服务提供者必须验证接收到的字段值（可以接受、修改或拒绝它）。之后，它将新值设置在未来的对象中（参见[[SWS_CM_00116]（#_bookmark546）]）。如果SetHandler需要访问当前字段值来验证新字段值，则骨架实现必须提供可从应用程序级访问的基础字段值的副本。


**[SWS_CM_10415]**{DRAFT} **Notify the Field value after a call to the SetHandler function** *[*The Communication Management implementation shall take the effective field value returned by the SetHandler function, and send it back to the requester as return value of the set function (see [[SWS_CM_00113](#_bookmark591)]), and to all the other subscribed entities via notification (see [[SWS_CM_00119](#_bookmark548)])._♩(RS_CM_00218)_

> **[SWS_CM_10415]**{草案} **在调用SetHandler函数后通知字段值** *[*通信管理实现应当采用SetHandler函数返回的有效字段值，并将其作为set函数的返回值发送回请求者（参见[[SWS_CM_00113](#_bookmark591)），并通过通知发送给所有其他订阅实体（参见[[SWS_CM_00119](#_bookmark548)）。_♩(RS_CM_00218)_


**[SWS_CM_00128]**{DRAFT} **Ensuring the existence of valid Field values** *[*To ensure the existence of a valid field values upon a call to the Subscribe() method (see [[SWS_CM_00141](#_bookmark559)]) or to the Get() method (see [[SWS_CM_00112](#_bookmark588)]) the ara::com implementation shall do the following: If a service containing a Field is offered via a call to OfferService() (see [[SWS_CM_00101](#_bookmark522)]), if Update() has not been called yet and one or more of the following applies:

> **[SWS_CM_00128]**{草案} **确保有效字段值的存在** *[*为了确保在调用Subscribe()方法（参见[[SWS_CM_00141](#_bookmark559)）或Get()方法（参见[[SWS_CM_00112](#_bookmark588)）时存在有效的字段值，ara :: com实现应执行以下操作：如果通过调用OfferService（参见[[SWS_CM_00101](#_bookmark522)）提供包含字段的服务，如果尚未调用Update（），并且以下之一应用：

- hasNotifier = true

- hasGetter = true and a GetHandler (see [[SWS_CM_00114](#_bookmark543)]) has not yet been registered.

> 拥有Getter=true，但尚未注册GetHandler（参见[[SWS_CM_00114](#_bookmark543)])。


Then the error code ComErrc::kFieldValueIsNotValid shall be returned in the result type of OfferService(). The error shall be logged._♩(RS_CM_00218)_

> 然后，在OfferService()的结果类型中将返回错误代码ComErrc::kFieldValueIsNotValid。该错误将被记录。♩(RS_CM_00218)


**[SWS_CM_00129]**{DRAFT} **Ensuring the existence of SetHandler** *[*Upon a call to OfferService() in a skeleton implementation for a given service, the following error check shall be made: if for at least one contained Field having hasSetter = true no SetHandler (see [[SWS_CM_00116](#_bookmark546)]) has been registered yet, the error code ComErrc::kSetHandlerNotSet shall be returned in the result type of OfferService(). The error shall be logged._♩(RS_CM_00218)_

> **[SWS_CM_00129]**{草案} **确保SetHandler的存在** *[*在给定服务的骨架实现中调用OfferService()时，应执行以下错误检查：如果对于具有hasSetter = true的至少一个包含字段，尚未注册SetHandler（参见[[SWS_CM_00116](#_bookmark546)），则OfferService()的结果类型中将返回错误代码ComErrc::kSetHandlerNotSet。应记录该错误。_♩(RS_CM_00218)_

### Find service


For the find service C++ API reference, see chapter [8.1.3.10](#find-service-1).

> 对于C++ API参考的查找服务，请参见第8.1.3.10章节。


**[SWS_CM_00124]**{DRAFT} **Find service handler invocation** *[*After calling the StartFindService method, the FindServiceHandler shall be called by the Communication Management software to receive the found services. By the first call, the FindServiceHandler shall receive the initially known matches, if there are any. In following, the FindServiceHandler shall be called every time the availability of any of the services matching the given instance criteria changes._♩(RS_CM_00102)_

> **[SWS_CM_00124]**{草案} **查找服务处理程序调用** *[*调用StartFindService方法后，通信管理软件应调用FindServiceHandler来接收发现的服务。 通过第一次调用，如果有的话，FindServiceHandler应接收最初已知的匹配项。 在接下来的情况中，每当与给定实例条件匹配的任何服务的可用性发生变化时，FindServiceHandler都应被调用。_♩（RS_CM_00102）_


**[SWS_CM_10382]**{DRAFT} **Calling stop find service for already stopped finds** *[*Calls to the StopFindService method using a FindServiceHandle obtained from a StartFindService that already has been stopped shall be silently ignored._♩ (RS_CM_00102)_

> **[SWS_CM_10382]**{草案} **对已停止的查找服务调用停止查找服务** *[*使用从已停止的StartFindService获得的FindServiceHandle调用StopFindService方法将被静默忽略。_♩ (RS_CM_00102)_`

### Service proxy creation


For the service proxy creation C++ API reference, see chapter [8.1.3.11](#service-proxy-creation-1).

> 对于服务代理创建C++ API参考，请参见第8.1.3.11章节。


**[SWS_CM_10491]**{DRAFT} **Re-establishing service connection** *[*In case the service becomes temporarily unavailable (due to restart, network problem or so), or if an error occurs while establishing a connection to the service, the error shall be logged, and the Communication Management shall retry to establish the connection once the next offer is received._♩(RS_CM_00102, RS_CM_00107)_

> **[SWS_CM_10491]**{草案} **重新建立服务连接** *[*如果服务暂时不可用（由于重新启动、网络问题等），或者在建立到服务的连接时发生错误，则应记录错误，并在收到下一个报价时，通信管理将重试建立连接。_♩(RS_CM_00102, RS_CM_00107)_

### Service proxy destruction


**[SWS_CM_10446]**{DRAFT} **Destruction of service proxy** *[*The destructor of each specific ServiceProxy class shall destroy the Promise instances corresponding to the Future instances returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) or by the Get or Set method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)] and [[SWS_CM_00113](#_bookmark591)]) by explicitly or implicitly invoking the destructor of the Promise (see [SWS_CORE_00349]). This in turn will make the corresponding Future ready (if this is not already the case) with an ara::core::ErrorCode (see [SWS_CORE_00501]) where the error domain is set to ara::core::FutureErrorDomain (see [SWS_CORE_00421]) and the value is set to broken_promise (see [SWS_CORE_00400])._♩(RS_CM_00102, RS_AP_00114, RS_AP_00127, RS_AP_00145)_

> **[SWS_CM_10446]**{草案} **服务代理的销毁** *[*每个特定的ServiceProxy类的析构函数应当销毁由各自的Method类的函数调用操作符（operator()）（参见[[SWS_CM_00196](#_bookmark586)）或者由各自的Field类的Get或Set方法（参见[[SWS_CM_00112](#_bookmark588)]和[[SWS_CM_00113](#_bookmark591)]）返回的Future实例对应的Promise实例，通过显式或隐式地调用Promise的析构函数（参见[SWS_CORE_00349]）。这反过来会使相应的Future准备就绪（如果这还没有发生），其中的ara::core::ErrorCode（参见[SWS_CORE_00501]）将设置为ara::core::FutureErrorDomain（参见[SWS_CORE_00421]），其值被设置为broken_promise（参见[SWS_CORE_00400]）。_♩(RS_CM_00102, RS_AP_00114, RS_AP_00127, RS_AP_00145)_

每个特定的ServiceProxy类的析构函数应销毁由其函数调用操作符或者Get/Set方法返回的Future实例对应的Promise实例，以使相应的Future准备就绪，其中的ara::core::ErrorCode设置为ara::core::FutureErrorDomain，其值设置为broken_promise。

### Service event subscription


For the service event subscription C++ API reference, see chapter [8.1.3.12](#service-event-subscription-1).

> 对于服务事件订阅C++ API参考，请参阅第8.1.3.12章。


**[SWS_CM_00700]**{DRAFT} **Ensure memory allocation of maxSampleCount samples** *[*The Communication Management shall ensure, that after returning from method Subscribe sufficient memory resources are available, so that the number of samples given in parameter maxSampleCount can be concurrently accessed by application layer._♩(RS_CM_00103)_

> **[SWS_CM_00700]**{草案}**确保最大样本数量的内存分配** *[*通信管理应确保，从Subscribe方法返回后，可以提供足够的内存资源，以便应用层可以同时访问参数maxSampleCount中给出的样本数量。_♩(RS_CM_00103)_


**[SWS_CM_99035] Set Subscription State change handler** *[*The handler SetSubscriptionStateChangeHandler defined in [[SWS_CM_00333](#sws_cm_00333-set-subscription-state-change-handler)] shall be called by the Communication Management implementation as soon as the subscription state of this event has changed. Handler may be overwritten during runtime._♩(RS_CM_00106)_

> **[SWS_CM_99035] 设置订阅状态更改处理程序** *[*在[[SWS_CM_00333](#sws_cm_00333-set-subscription-state-change-handler)]中定义的处理程序SetSubscriptionStateChangeHandler应由通信管理实现在此事件的订阅状态更改后立即调用。可以在运行时覆盖处理程序。_♩(RS_CM_00106)_


**[SWS_CM_00313] Call SubscriptionStateChangeHandler with kSubscriptionPending** *[*The Communication Management shall call the SubscriptionStateChangeHandler with the value kSubscriptionPending in the following cases:

> **[SWS_CM_00313] 使用kSubscriptionPending调用SubscriptionStateChangeHandler** *[*以下情况下，通信管理将使用kSubscriptionPending值调用SubscriptionStateChangeHandler：


- the client subscribes to an event and the actual subscription does not happen immediately (e.g. due to a bus protocol)

> 客戶訂閱事件，但實際訂閱不會立即發生（例如由於汽車協議）

- the client is subscribed to an event and Communication Management has detected that the server instance is currently not available (due to restart, network problem or so)

> 客户已订阅事件，但通信管理检测到服务器实例目前无法使用（由于重启、网络问题等）

_♩(RS_CM_00103, RS_CM_00104, RS_CM_00106, RS_CM_00107)_


Note: Method Calls may lead to a kServiceNotAvailable error [[SWS_CM_11264](#_bookmark495)] at that time.

> 注意：此时，方法调用可能导致出现 kServiceNotAvailable 错误 [[SWS_CM_11264](#_bookmark495)]。


**[SWS_CM_00314] Call SubscriptionStateChangeHandler with kSubscribed** *[*The Communication Management shall call the SubscriptionStateChangeHandler with the value kSubscribed in the following cases:

> **[SWS_CM_00314] 调用SubscriptionStateChangeHandler以kSubscribed** *[*通信管理应在以下情况下以值kSubscribed调用SubscriptionStateChangeHandler：

- the client subscribes to an event and the actual subscription is established successfully

- the client is subscribed to an event and the actual subscription is re-established again after being temporarily unavailable (due to restart, network problem or so)

> 客户订阅了一个事件，经过重新启动、网络问题等暂时不可用后，订阅关系又被重新建立起来。

_♩(RS_CM_00103, RS_CM_00104, RS_CM_00106, RS_CM_00107)_


**[SWS_CM_00315] Re-establishing an active subscription** *[*The Communication Management shall re-establish the actual subscription again after the server service being temporarily unavailable (due to restart, network problem or so). This shall work independently of whether a network binding is involved or not. The reestablishment shall also provide a possible update of binding specific connection properties if needed._♩(RS_CM_00103, RS_CM_00104, RS_CM_00106, RS_CM_00107)_

> 管理通信应该在服务器服务暂时不可用（由于重新启动，网络问题等）后重新建立实际订阅。 这将独立于是否涉及网络绑定。 如果需要，重新建立还应提供可能的绑定特定连接属性更新。 （RS_CM_00103，RS_CM_00104，RS_CM_00106，RS_CM_00107）

### Receive event


For the event data access C++ API reference, see chapter [8.1.3.13](#receive-event-1).

> 对于事件数据访问C++ API参考，请参见第8.1.3.13章节。


**[SWS_CM_00703] Sequence of actions in GetNewSamples** *[*In the context of the GetNewSamples call, the Communication Management shall do the following steps repeatedly:

> 在GetNewSamples调用的上下文中，通信管理部门应重复执行以下步骤：

- get next received event data sample from underlying receive buffers.
- de-serialize the data, if needed.
- place the de-serialized data sample of type SampleType in the local cache.

- call user provided f with a SamplePtr (including ProfileCheckStatus) referencing the data sample located in local cache.

> 调用用户提供的f函数，传入一个指向本地缓存数据样本的SamplePtr（包括ProfileCheckStatus）。

until at least one of the following conditions is true:


- maxNumberOfSamples have already been fetched from the underlying receive buffers within this GetNewSamples call.

> 已经从本次GetNewSamples调用中的底层接收缓冲区获取了maxNumberOfSamples个样本。

- maxSampleCount reached. I.e. the application is currently holding exactly as many SamplePtrs provided by this Event class instance, than it has committed in call to Subscribe via maxSampleCount.

> 已达到最大样本数。即应用程序当前持有的由此Event类实例提供的SamplePtrs数量，正好等于通过maxSampleCount调用时所承诺的数量。
- no new data samples available from underlying receive buffers.

_♩(RS_CM_00202)_

### [SWS_CM_00707] Calculation of Free Sample Count _[_


- After call to Subscribe with parameter maxSampleCount set to N and _before_ any call to GetNewSamples on the same Event class instance, a call to GetFreeSampleCount shall return N.

> 在使用参数maxSampleCount设置为N调用Subscribe之后，在对同一个Event类实例调用GetNewSamples之前，调用GetFreeSampleCount应返回N。

- Each SamplePtr created by the Communication Middleware in the context of a call to GetNewSamples on the same Event class instance shall lead to a decrement of count of free samples.

> 每一个由通信中间件在同一个事件类实例上调用GetNewSamples创建的SamplePtr都将导致可用样本数量的减少。

- Each destruction or std::nullptr_t assignment (see [[SWS_CM_00306](#_bookmark478)]) of a SamplePtr instance created from this Event class instance shall lead to an increment of count of free samples.

> 每次销毁或将std::nullptr_t分配给从此Event类实例创建的SamplePtr实例（参见[[SWS_CM_00306](#_bookmark478)])都将导致空闲样本计数增加。

_♩(RS_CM_00202)_


**[SWS_CM_00709] FIFO semantics** *[*The Communication Management shall provide buffering with FIFO semantics between sender and receiver of events._♩(RS_CM_00203)_

> 通信管理应提供发送者和接收者之间的先进先出语义缓冲。


**[SWS_CM_00710]**{DRAFT} **No implicit context switches** *[*Reception of a new event shall not lead to an implicit context switch in the receiver process when polling behavior is employed (i.e. No ReceiveHandler has been set via SetReceiveHandler())_♩ (RS_CM_00203)_

> **[SWS_CM_00710]**{草案} **不允许隐式上下文切换** *[*当采用轮询行为时，接收新事件不应导致接收进程中的隐式上下文切换（即未通过SetReceiveHandler（）设置ReceiveHandler）_♩（RS_CM_00203）_

### Receive event by polling


For the polling access no additional APIs on top of [8.1.3.13](#receive-event-1) are needed.

> 对于投票访问，除了[8.1.3.13](#receive-event-1)之外，不需要其他额外的API。

### Receive event by getting triggered


For the receive event by getting triggered C++ API reference, see chapter [8.1.3.13.1](#receive-event-by-getting-triggered-1).

> 对于通过触发C++ API参考接收事件，请参见第[8.1.3.13.1]章（#接收触发的事件1）。


**[SWS_CM_00182]**{DRAFT} **Event Receive Handler call serialization** *[*The Communication Management shall serialize calls to the registered EventReceiveHandler function as it is not guaranteed that the callback function is re-entrant._♩(RS_CM_00203)_

> **[SWS_CM_00182]**{草案} **事件接收处理程序调用序列化** *[*通信管理应将调用序列化为已注册的EventReceiveHandler函数，因为不能保证回调函数是可重入的。_♩(RS_CM_00203)_


**[SWS_CM_00711]**{DRAFT} *[*After the Communication Management has called the registered EventReceiveHandler function for a specific Event class instance, the next call to GetNewSamples on the same instance shall provide at least one data sample as long as GetFreeSampleCount is not already returning 0 at the point in time of the call._♩(RS_CM_00203)_

> **[SWS_CM_00711]**{草案} *[*在通信管理已经为特定事件类实例调用注册的EventReceiveHandler函数后，对同一实例的GetNewSamples的下一次调用应提供至少一个数据样本，只要在调用时GetFreeSampleCount不已返回0。_♩(RS_CM_00203)_

### Service trigger subscription


For the service trigger subscription C++ API reference, see chapter [8.1.3.14](#service-trigger-subscription-1).

> 对于服务触发订阅C++ API参考，请参阅第8.1.3.14章。


Getting subscription state and set a subscription change handler for Trigger is the same as for Event. The following specification are also valid for Trigger:

> 获取订阅状态并设置触发器的订阅更改处理程序与事件相同。以下规范对触发器也有效:

```
- [[SWS_CM_00316](#_bookmark561)] Query Subscription State.
- [[SWS_CM_00024](#_bookmark562)] Reentrancy GetSubscriptionState.
- [[SWS_CM_00333](#sws_cm_00333-set-subscription-state-change-handler)] Set Subscription State change handler.
- [[SWS_CM_11354](#_bookmark564)] Execution Context for setting Subscription State change handler.
- [[SWS_CM_11355](#_bookmark565)] Error behavior of provided Execution Context for setting Subscription State change handler.
- [[SWS_CM_00025](#_bookmark566)] Reentrancy SetSubscriptionStateChangeHandler.
- [[SWS_CM_00334](#_bookmark567)] Unset Subscription State change handler.
- [[SWS_CM_00026](#_bookmark568)] Reentrancy UnsetSubscriptionStateChangeHandler.
- [[SWS_CM_00313](#_bookmark425)] Call SubscriptionStateChangeHandler with kSubscriptionPending.
- [[SWS_CM_00314](#_bookmark426)] Call SubscriptionStateChangeHandler with kSubscribed.
- [[SWS_CM_00315](#_bookmark427)] Re-establishing an active subscription.
```

1. ### Receive trigger


For the trigger data access C++ API reference, see chapter [8.1.3.15](#receive-trigger-1).

> 对于触发数据访问C++ API参考，请参见第8.1.3.15章。


**[SWS_CM_00227]**{DRAFT} **Sequence of actions in GetNewTriggers** *[*In the context of the GetNewTriggers (see [[SWS_CM_00226](#_bookmark582)]) call, the Communication Management shall get the number of triggers occurred since the last call of GetNewTriggers._♩(RS_CM_00202)_

> 在获取新触发器（参见[[SWS_CM_00226](#_bookmark582)）调用的上下文中，通信管理应获取自上次调用GetNewTriggers以来发生的触发器数量。♩（RS_CM_00202）

### Receive trigger by getting triggered


For the receive event by getting triggered C++ API reference, see chapter [8.1.3.15.1](#receive-trigger-by-getting-triggered-1). The following specification are also valid for Trigger

> 对于接收被触发的C++ API参考，请参见第8.1.3.15.1章节。以下规范也适用于触发器。

- [[SWS_CM_00028](#_bookmark575)] Reentrancy SetReceiveHandler
- [[SWS_CM_00183](#_bookmark576)] Disable service event trigger
- [[SWS_CM_00029](#_bookmark577)] Reentrancy UnsetReceiveHandler

  1. ### Call a service method


For the call a service method C++ API reference, see chapter [8.1.3.16](#call-a-service-method-1).

> 对于调用服务方法C++ API参考，请参阅第8.1.3.16章。


**[SWS_CM_10414]**{DRAFT} **Initiate a method call** *[*At the point of time when the caller calls the method (see [[SWS_CM_00196](#_bookmark586)]), the Communication Management software does not know yet if the result shall be returned with synchronous or asynchronous behavior. Therefore the Communication Management software shall instantiate the ara::core::Future object to be returned to the caller, but shall not perform actions which lead to uncontrolled context switches from the caller point of view, e.g. an asynchronous event-style mechanism for a wait-on-event._♩(RS_CM_00212, RS_CM_00213, RS_AP_00138)_

> 在调用者调用方法的时候（参见[[SWS_CM_00196](#_bookmark586)），通信管理软件还不知道结果是否应该以同步或异步方式返回。因此，通信管理软件应实例化ara :: core :: Future对象以返回给调用者，但不应执行会导致从调用者角度受控上下文切换的操作，例如用于等待事件的异步事件式机制。（RS_CM_00212，RS_CM_00213，RS_AP_00138）


**[SWS_CM_10371]**{DRAFT} **Context of return checked errors** *[*If during processing of a method call one of the checked errors occurs, the corresponding ara::core::ErrorCode shall be returned in the context of the ara::core::Future::GetResult()/ara::core::Future::get() call._♩(RS_CM_00211, RS_CM_00212, RS_CM_00213, RS_CM_00214)_

> **[SWS_CM_10371]**{草案} **返回检查错误的上下文** *[*如果在处理方法调用时发生一个检查错误，则相应的ara :: core :: ErrorCode应在ara :: core :: Future :: GetResult（）/ara :: core :: Future :: get（）调用的上下文中返回。_♩（RS_CM_00211，RS_CM_00212，RS_CM_00213，RS_CM_00214）_


See [subsubsection](#error-types) [8.1.2.7](#error-types)) for the definition of checked errors.

> 请参阅[子小节](#error-types) [8.1.2.7](#error-types)) 以获取检查错误的定义。


**[SWS_CM_90436]**{DRAFT} **No checked errors for Fire and Forget method calls** *[*There shall be no checked errors returned for Fire and Forget method calls._♩(RS_CM_00225)_

> 消息发送方式为"火箭发射"的方法调用不应返回任何检查错误。(RS_CM_00225)


**[SWS_CM_00194]**{DRAFT} **Cancel the method call** *[*The destructor of the returned ara::core::Future object shall be used by the caller to cancel the request after issuing a method call. Deleting the returned ara::core::Future object shall result in the abort of the method call and ensure that any related buffers are released and no result is returned to the caller._♩(RS_CM_00212, RS_CM_00213, RS_AP_00114, RS_AP_00127)_

> **[SWS_CM_00194]**{草案} **取消方法调用** *[*返回的ara :: core :: Future对象的析构函数应由调用者在发出方法调用后使用来取消请求。 删除返回的ara :: core :: Future对象将导致方法调用中止，并确保释放所有相关缓冲区，并且不会将结果返回给调用者。_♩(RS_CM_00212, RS_CM_00213, RS_AP_00114, RS_AP_00127)_


This is a mechanism on client side to tell the Communication Management software that the caller is not interested in the method result anymore. Cancellation of the method call is not propagated to the server side execution of the method.

> 这是一种客户端机制，用于告知通信管理软件，调用者不再对该方法的结果感兴趣。方法调用的取消不会传播到服务器端对该方法的执行。


**[SWS_CM_00195]**{DRAFT} **Retrieving results of the method call** *[*The method GetResult() of the returned ara::core::Future object shall be used to retrieve the result of the method call as ara::core::Result. The call of the method GetResult() will block if there is not yet a result available and will return after the result has been received returning an object of the respective Output or an error. As an alternative, get() returns the contained object of the result from GetResult(), or throws the contained error as exception, respectively._♩(RS_CM_00212, RS_AP_00114, RS_AP_00120, RS_AP_00138, RS_AP_00128, RS_AP_00127, RS_AP_00139)_

> **[SWS_CM_00195]**{草案}**检索方法调用的结果** *[*应使用返回的ara :: core :: Future对象的GetResult（）方法来检索方法调用的结果作为ara :: core :: Result。调用GetResult（）方法将会阻塞，如果尚无结果可用，并在收到结果后返回，返回相应的输出对象或错误。作为替代，get（）返回从GetResult（）中获取的结果对象，或分别抛出包含的错误作为异常。_♩（RS_CM_00212，RS_AP_00114，RS_AP_00120，RS_AP_00138，RS_AP_00128，RS_AP_00127，RS_AP_00139）_


**[SWS_CM_00192]**{DRAFT} **Synchronous behavior of method call** *[*To achieve synchronous behavior of the method call, the methods of ara::core::Future object with blocking behavior shall be used because they only return when the output of the method call according to [[SWS_CM_00196](#_bookmark586)] is available: get(), wait(), wait_for (), wait_until(). With the call of one of these methods and the result still pending, the Communication Management software is allowed to perform actions which lead to uncontrolled context switches from the caller point of view, e.g. an asynchronous event-style mechanism for a wait-on-event._♩(RS_CM_00212, RS_AP_00114, RS_AP_00120, RS_AP_00138, RS_AP_00128, RS_AP_00127, RS_AP_00138)_

> **[SWS_CM_00192]**{草稿} **方法调用的同步行为** *[*为了实现方法调用的同步行为，应使用ara::core::Future对象的带阻塞行为的方法，因为它们只有在根据[[SWS_CM_00196](#_bookmark586)]提供的方法调用的输出可用时才会返回：get（），wait（），wait_for（），wait_until（）。 在调用其中一个方法并且结果仍然未决的情况下，允许通信管理软件执行从调用者角度导致不受控制的上下文切换的操作，例如等待事件的异步事件式机制。_♩（RS_CM_00212，RS_AP_00114，RS_AP_00120，RS_AP_00138，RS_AP_00128，RS_AP_00127，RS_AP_00138）_

简体中文：**[SWS_CM_00192]**{草稿} **方法调用的同步行为** *[*为了实现方法调用的同步行为，应使用ara::core::Future对象的具有阻塞行为的方法，因为它们只有在根据[[SWS_CM_00196](#_bookmark586)]提供的方法调用的输出可用时才会返回：get（），wait（），wait_for（），wait_until（）。 在调用其中一个方法并且结果仍然未决的情况下，允许通信管理软件执行从调用者角度导致不受控制的上下文切换的操作，例如等待事件的异步事件式机制。_♩（RS_CM_00212，RS_AP_00114，RS_AP_00120，RS_AP_00138，RS_AP_00128，RS_AP_00127，RS_AP_00138）_


Note that there are situations where the methods of an ara::core::Future object with blocking behavior will block forever. The adaptive application will need to gracefully handle such a situation. Prominent examples for such situations are the following ones:

> 注意，有些情况下，具有阻塞行为的ara::core::Future对象的方法可能会永久阻塞。自适应应用程序需要优雅地处理这种情况。典型的例子有：

- the request message or the response message of the (remote) service method call gets lost

- the implementation for the service method in the subclass of the respective ServiceSkeleton (see [[SWS_CM_00194](#_bookmark436)]) does not return (i.e., hangs)

> 实现该服务方法的子类（参见[[SWS_CM_00194](#_bookmark436)])不会返回（即挂起）


ara::com will **not** internally perform some kind of timeout supervision in order to eventually unblock those blocking ara::core::Future methods. If such a timeout supervision is desired from the perspective of the adaptive application, it is up to the adaptive application to implement according mechanisms, e.g., by using the wait_for (), wait_until(), or the is_ready() methods of the ara::core::Future.

> ara::com不会在内部执行某种超时监督以最终解除阻塞ara::core::Future方法的情况。如果自适应应用程序需要此类超时监督，则有自适应应用程序来实现此类机制，例如通过使用ara::core::Future的wait_for（）、wait_until（）或is_ready（）方法。


On the other hand there are situations where the ara::com implementation on the client side **knows** that an issued (remote) service method call will not succeed and thus would block forever. Prominent examples for such situations are the following ones:

> 另一方面，有些情况下，客户端的ara :: com实现**知道**发出的（远程）服务方法调用不会成功，因此会永远阻塞。典型的例子包括：


- the sending of request message of the (remote) service method failed locally (i.e., the corresponding system or library call indicated an error)

> 发送远程服务方法请求消息失败（即相应的系统或库调用指示出错）

- the received response message partly contains malformed message content but contains sufficient correct information allowing to determine the method this response is targeted at (i.e., there is sufficient information available about who to notify/which ara::core::Future to fulfill) -in case of the SOME/IP network binding (see Section [7.5.1](#someip-network-binding)) this would be a response message where the layer 2 and layer 4 checksums are correct the SOME/IP header (which contains the method ID) is intact (e.g., in case of a SOME/IP response message, the checks described in [[SWS_CM_10313](#_bookmark85)] are passed ) the de-serialization of the payload fails though

> 收到的响应消息部分包含格式错误的消息内容，但包含足够的正确信息，可以确定该响应的方法（即，有关通知谁/哪个ara :: core :: Future来实现的足够信息可用）-在SOME / IP网络绑定的情况下（参见[7.5.1]（#someip-network-binding）），这将是一个响应消息，其中第2层和第4层校验和正确，SOME / IP头（其中包含方法ID）完好无损（例如，在SOME / IP响应消息的情况下，[[SWS_CM_10313]（#_bookmark85）]中描述的检查通过），但是有效负载的反序列化失败。


**[SWS_CM_10440]**{DRAFT} **Aborting method calls in case of locally detected failures** *[*To notify the adaptive application about locally detected failures which prevent an issued (remote) service method call from succeeding, the ara::com implementation shall make the Future returned by the function call operator (operator()) of the respective Method class (see [[SWS_CM_00196](#_bookmark586)]) or by the Get or Set method of the respective Field class (see [[SWS_CM_00112](#_bookmark588)] and [[SWS_CM_00113](#_bookmark591)]) ready by invoking the SetError (see [SWS_CORE_00353]) operation of the Promise corresponding to this Future with an ara::core::ErrorCode (see [SWS_CORE_00501]) where the error domain is set to ara::com::ComErrorDomain (see [[SWS_CM_11264](#_bookmark495)]) and the value is set to kNetworkBindingFailure (see [[SWS_CM_10432](#_bookmark496)]) as an argument._♩(RS_CM_00213, RS_CM_00214, RS_AP_00114, RS_AP_00119, RS_AP_00127)_

> 在本地检测到失败的情况下终止方法调用：ara::com实现应该通过调用相应的Promise的SetError操作（参见SWS_CORE_00353）来使得函数调用运算符（operator()）返回的Future（参见SWS_CM_00196）或者是Field类的Get或Set方法（参见SWS_CM_00112和SWS_CM_00113）变为就绪状态，其中的错误域被设置为ara::core::ErrorCode（参见SWS_CORE_00501），值被设置为kNetworkBindingFailure（参见SWS_CM_10432）作为参数。（RS_CM_00213，RS_CM_00214，RS_AP_00114，RS_AP_00119，RS_AP_00127）


**[SWS_CM_00193]**{DRAFT} **Asynchronous behavior of method call with polling** *[*To achieve asynchronous behavior of the method call with polling on the result availability, the non-blocking method is_ready() of ara::core::Future object shall be used. If is_ready() returns true, the next call of get() shall not block, but immediately return the valid value._♩(RS_CM_00213, RS_CM_00214, RS_AP_00114, RS_AP_00127)_

> **[SWS_CM_00193]**{草案} **方法调用的异步行为与轮询** *[*为了实现方法调用的异步行为，使用ara::core::Future对象的非阻塞方法is_ready()。如果is_ready()返回true，则下一次调用get()不会阻塞，而是立即返回有效值。_♩(RS_CM_00213, RS_CM_00214, RS_AP_00114, RS_AP_00127)_

### Note:


When the user just calls is_ready() of ara::core::Future and on positive response, finally GetResult()/get() of ara::core::Future, retrieving the result works polling-based without any overhead in the middleware and uncontrolled context switches due to asynchronous event-style mechanisms.

> 当用户只调用ara::core::Future的is_ready（）并且得到正面回应时，最终通过ara::core::Future的GetResult（）/get（）获取结果，可以通过轮询的方式而不需要中间件和由异步事件机制导致的不受控的上下文切换来实现。


**[SWS_CM_00197]**{DRAFT} **Asynchronous behavior of method call with notification** *[*To achieve asynchronous behavior of the method call with event-driven notification on the result availability, the non-blocking method then() of ara::core::Future object shall be used. It allows to register a function, which gets asynchronously called in case the future has a valid result._♩(RS_CM_00213, RS_CM_00215, RS_AP_00114, RS_AP_00127, RS_AP_00138)_

> **[SWS_CM_00197]**{草案} **方法调用的异步行为与通知** *[*为了实现方法调用的异步行为，以事件驱动的通知的结果可用性，应使用ara :: core :: Future对象的非阻塞方法then()。它允许注册一个函数，如果未来有一个有效的结果，则异步调用该函数。_♩（RS_CM_00213，RS_CM_00215，RS_AP_00114，RS_AP_00127，RS_AP_00138）_

### Update notification events for fields


**[SWS_CM_00120]**{DRAFT} **Provision of an update notification event for a Field** *[*If hasNotifier is true, update notification events for the Field shall be provided as of the following requirements:

> **[SWS_CM_00120]**{草案} **为字段提供更新通知事件** *[*如果hasNotifier为true，则按照以下要求为该字段提供更新通知事件：

- [[SWS_CM_00141](#_bookmark559)] Method to subscribe to a service event. This subscribe leads immediately to a service event that contains the initial field value send from provider side to the consumer.
- [[SWS_CM_00151](#_bookmark560)] Method to unsubscribe from a service event.
- [[SWS_CM_00316](#_bookmark561)] Method to query the subscription state.
- [[SWS_CM_00701](#_bookmark570)] Method to receive a service event using polling.
- [[SWS_CM_00181](#_bookmark573)] Method to enable service event trigger.
- [[SWS_CM_00182](#_bookmark431)] Event Receive Handler call serialization.
- [[SWS_CM_00183](#_bookmark576)] Method to disable service event trigger.
- [[SWS_CM_00333](#sws_cm_00333-set-subscription-state-change-handler)] Method to set a subscription state change handler.
- [[SWS_CM_00334](#_bookmark567)] Method to unset a subscription state change handler.


Except that the corresponding methods reside in the Field class instead of the Event class._♩(RS_CM_00218)_

> 除了相应的方法位于Field类而不是Event类中。

### Instance Specifier Translation


For the instance specifier translation C++ API reference, see chapter [8.1.3.19](#instance-specifier-translation-1).

> 对于实例规范翻译C++ API参考，请参阅第8.1.3.19章。


**[SWS_CM_10452]**{DRAFT} **InstanceSpecifier translation to InstanceIdentifiers** *[*The Communication Management shall translate an InstancSpecifier to InstanceIdentifiers. Based on the match there shall be zero, 1 or multiple InstanceIdentifiers ._♩(RS_CM_00200, RS_AP_00137)_

> 通信管理应将实例指定符转换为实例标识符。根据匹配，可能会有零个、一个或多个实例标识符。♩（RS_CM_00200，RS_AP_00137）

### API Data Types


This chapter describes the functionality of the data types used by the ara::com API, both the specific ones which are part of the standardized proxy and skeleton interfaces, and the ones derived from the description based on the AUTOSAR meta-model.

> 本章描述了ara::com API使用的数据类型的功能，既包括标准代理和骨架接口中的特定类型，也包括基于AUTOSAR元模型描述的类型。

### Service Identifier Data Types


For the Service Identifier Data Types C++ API reference, see chapter [8.1.2.1](#service-identifier-data-types-1).

> 对于服务标识符数据类型C++ API参考，请参见第8.1.2.1章。


The data types described in this chapter are used to identify a specific service or service instance.

> 本章描述的数据类型用于识别特定的服务或服务实例。


There might exist different instances of exactly the same service in the system. To handle this, an InstanceIdentifier or an InstanceSpecifier are used to identify a specific instance of a service.

> 在系统中可能存在完全相同的服务的不同实例。为了处理这个问题，使用实例标识符或实例指定符来标识特定服务的实例。


An InstanceIdentifier (see [[SWS_CM_00302](#sws_cm_00302draft-instance-identifier-class)]) is a unique identifier of a specific instance of a service, needed to distinguish different instances of exactly the same service in the system. It contains instance information and information about the service type. This will make the InstanceIdentifier unique for different instances.

> 一个实例标识符（见[[SWS_CM_00302](#sws_cm_00302draft-instance-identifier-class)]）是一项特定服务实例的唯一标识符，用于区分系统中完全相同的服务的不同实例。它包含实例信息和服务类型信息。这将使实例标识符对不同实例唯一。


A service can be identified at least by a fully qualified name and a version.

> 服务至少可以通过完全限定的名称和版本来识别。


**[SWS_CM_99029]**{DRAFT} **Service Contract Version** *[*The value of the service contract major version (serviceContractVersionMajor) shall be derived from the majorVersion attribute in the ServiceInterface. The value of the service contract minor version (serviceContractVersionMinor) shall be derived from the minorVersion attribute in the ServiceInterface._♩(RS_CM_00500)_

> **[SWS_CM_99029]**{草案} **服务合同版本** *[*服务合同的主要版本(serviceContractVersionMajor)的值应从ServiceInterface中的majorVersion属性中获取。服务合同的次要版本(serviceContractVersionMinor)的值应从ServiceInterface中的minorVersion属性中获取。_♩(RS_CM_00500)_


The following data types are used for the handling of services on the service consumer side.

> 以下数据类型用于处理服务消费者端的服务。


**[SWS_CM_99030]**{DRAFT} **Find Service Handle** *[*To identify a triggered request to find a service, the StartFindService method of [[SWS_CM_00123](#_bookmark552)] shall return a FindServiceHandle which is used as parameter to cancel this request with StopFindService as described in [[SWS_CM_00125](#_bookmark555)]._♩(RS_CM_00102, RS_AP_00122, RS_AP_00119)_

> **[SWS_CM_99030]**{草案} **查找服务句柄** *[*为了识别触发的查找服务请求，[[SWS_CM_00123](#_bookmark552)]的StartFindService方法应该返回一个FindServiceHandle，它作为参数使用，以按照[[SWS_CM_00125](#_bookmark555)]中描述的方式取消此请求。_♩(RS_CM_00102, RS_AP_00122, RS_AP_00119)_


The usage of the API to find service instances, as defined in [[SWS_CM_00122](#_bookmark550)] and [[SWS_CM_00123](#_bookmark552)], provides a _handle container_ (see [[SWS_CM_00319](#_bookmark469)]) holding a list of *handle*s. Each _handle_ represents an existing service instance and by passing the _handle_ as parameter to the proxy constructor [[SWS_CM_00131](#_bookmark557)], it allows the ara::com API user to create a proxy instance to access this service instance.

> 使用API来查找服务实例，如[[SWS_CM_00122](#_bookmark550)]和[[SWS_CM_00123](#_bookmark552)]中定义的，提供了一个_handle容器_（参见[[SWS_CM_00319](#_bookmark469)），其中包含一个*handle*列表。每个_handle_代表一个现有的服务实例，通过将_handle_作为参数传递给代理构造函数[[SWS_CM_00131](#_bookmark557)，ara :: com API用户可以创建一个代理实例来访问此服务实例。

### Event Related Data Types


For the Event Related Data Types C++ API reference, see chapter [8.1.2.2](#event-related-data-types-1).

> 对于事件相关数据类型C++ API参考，请参见第8.1.2.2章节。


Event handling on receiver side is based on queued communication with configurable cache sizes. The cache size for a specific event of a proxy instance is determined by the Communication Management, when subscribing to a specific event by [[SWS_CM_00141](#_bookmark559)].

> 事件接收端的处理基于具有可配置缓存大小的队列通信。代理实例的特定事件的缓存大小由通信管理确定，当通过[[SWS_CM_00141](#_bookmark559)]订阅特定事件时。


After the receiver subscribed to an event, the method GetNewSamples, as defined in [[SWS_CM_00701](#_bookmark570)], is used to retrieve the _data samples_ of that event. In the context of GetNewSamples application provided callback functions are called by the Communication Management, where _Sample Pointer_ s to the data samples retrieved from underlying queues are passed in. A _Sample Pointer_ (see [[SWS_CM_00306](#_bookmark478)]) is an alias for an event data type pointer.

> 在接收者订阅事件后，将使用定义在[[SWS_CM_00701](#_bookmark570)]中的GetNewSamples方法来检索该事件的数据样本。在GetNewSamples应用程序提供的回调函数中，通信管理将传递从底层队列检索的样本指针。样本指针（参见[[SWS_CM_00306](#_bookmark478)）是事件数据类型指针的别名。


On the event provider side, it is possible to let the Communication Management allocate the memory for the storage of the data before sending it as defined in [[SWS_CM_90438](#sws_cm_90438-allocate-data-when-communication-management-is-responsi--ble-for-the-data)]. A _Sample Allocatee Pointer_ (see [[SWS_CM_00308](#_bookmark480)]) is an alias for an event data type pointer used both for allocation and data sending.

> 在事件提供方侧，可以让通信管理在发送数据之前为数据存储分配内存，如[[SWS_CM_90438](#sws_cm_90438-allocate-data-when-communication-management-is-responsi--ble-for-the-data)]中定义。_示例分配指针_（参见[[SWS_CM_00308](#_bookmark480)])是一种用于分配和数据发送的事件数据类型指针的别名。


The event receiver can register an _Event Receive Handler_ (see [[SWS_CM_00309](#_bookmark481)]) as a callback to get notified if new event data has arrived. The callback function itself is defined in the event consumer implementation; the _Event Receive Handler_ type is just an general purpose function alias for the use in the method SetReceiveHandler as defined by [[SWS_CM_00181](#_bookmark573)].

> 事件接收器可以注册一个_事件接收处理器_（参见[[SWS_CM_00309](#_bookmark481)）作为回调，以便在有新的事件数据到达时得到通知。回调函数本身由事件消费者实现定义；_事件接收处理器_类型只是用于根据[[SWS_CM_00181](#_bookmark573)]定义的SetReceiveHandler方法的通用函数别名。


The event receiver can monitor the state of a service event subscription by requesting or getting a notification of the _Subscription State_ (see [[SWS_CM_00310](#_bookmark482)], [[SWS_CM_00316](#_bookmark561)] and [[SWS_CM_00311](#_bookmark483)]), as the real process of subscription might happen at a later point in time than the return of the call to Subscribe. The _Subscription State_ related ara::com API methods require the definitions of a _Subscription State_ enumeration ([[SWS_CM_00310](#_bookmark482)]) and a _Subscription State Changed Handler_ function wrapper.

> 接收器可以通过请求或获取订阅状态的通知来监视服务事件订阅的状态（参见[[SWS_CM_00310](#_bookmark482)，[[SWS_CM_00316](#_bookmark561)]和[[SWS_CM_00311](#_bookmark483)），因为订阅的实际过程可能比调用Subscribe返回的时间稍晚。与_Subscription State_相关的ara :: com API方法需要定义_Subscription State_枚举（[[SWS_CM_00310](#_bookmark482)）和_Subscription State Changed Handler_函数包装器。

### Trigger Related Data Types


For the Trigger Related Data Types C++ API reference, see chapter [8.1.2.3](#trigger-related-data-types-1).

> 对于触发器相关的C++ API参考，请参见第8.1.2.3章节。


The trigger receiver can register a _Trigger Receive Handler_ (see [[SWS_CM_00351](#_bookmark485)]) as a callback to get notified if new trigger has arrived. The callback function itself is defined in the trigger consumer implementation; the _Trigger Receive Handler_ type is just an general purpose function alias for the use in the method SetReceiveHandler as defined by [[SWS_CM_00249](#_bookmark584)].

> 触发器接收器可以注册一个触发器接收处理程序（参见[[SWS_CM_00351]（＃_bookmark485）]）作为回调，以便在新触发到达时得到通知。 回调函数本身在触发器消费者实现中定义； _Trigger Receive Handler_ 类型只是用于方法SetReceiveHandler中定义的通用函数别名[[SWS_CM_00249]（＃_bookmark584）]。


The trigger receiver can monitor the state of a service trigger subscription by requesting or getting a notification of the _Subscription State_ (see [[SWS_CM_00310](#_bookmark482)], [[SWS_CM_00316](#_bookmark561)] and [[SWS_CM_00311](#_bookmark483)]), as the real process of subscription might happen at a later point in time than the return of the call to Subscribe. The _Subscription State_ related ara::com API methods require the definitions of a _Subscription State_ enumeration ([[SWS_CM_00310](#_bookmark482)]) and a _Subscription State Changed Handler_ function wrapper.

> 触发器接收器可以通过请求或接收_订阅状态_（参见[[SWS_CM_00310](#_bookmark482)，[[SWS_CM_00316](#_bookmark561)]和[[SWS_CM_00311](#_bookmark483)]）来监视服务触发订阅的状态，因为订阅的实际过程可能会在调用订阅后的晚一点发生。与_订阅状态_相关的ara :: com API方法需要定义_订阅状态_枚举（[[SWS_CM_00310](#_bookmark482)）和_订阅状态更改处理程序_函数包装器。


The [[SWS_CM_00310](#_bookmark482)] and [[SWS_CM_00311](#_bookmark483)] are also valid for triggers as well.

> [[SWS_CM_00310](#_bookmark482)]和[[SWS_CM_00311](#_bookmark483)]也适用于触发器。

### Method Related Data Types


For the Method Related Data Types C++ API reference, see chapter [8.1.2.4](#method-related-data-types-1).

> 对于C++ API参考中的方法相关数据类型，请参阅第8.1.2.4章节。


Service method invocation on provider side can be executed in different processing modes, where the _Method Call Processing Mode_ (see [[SWS_CM_00301](#_bookmark487)]) is set as a parameter of the ServiceSkeleton constructor defined by [[SWS_CM_00130](#_bookmark525)].

> 服务提供者端的服务方法调用可以以不同的处理模式执行，其中_Method Call Processing Mode_（参见[[SWS_CM_00301](#_bookmark487)])被设置为由[[SWS_CM_00130](#_bookmark525)]定义的ServiceSkeleton构造函数的一个参数。


The expected behavior of each processing mode is described in [[SWS_CM_00198](#sws_cm_00198draft-set-service-method-processing-mode)].

> 预期的每种处理模式的行为都在[[SWS_CM_00198](#sws_cm_00198draft-set-service-method-processing-mode)]中描述。

# Communication API specification


While the primary focus of ara::com is targeted towards an implementation in the C++ programming language, the following chapter structures of the document allow for future versions to add further Language Bindings.

> ara::com 的主要重点是针对 C++ 编程语言的实现，本文档的章节结构允许未来版本添加更多的语言绑定。

1. ## C++ language binding

   1. ### API Header files


This chapter specifies those C++ header files used directly in the API implementation of the ServiceInterface in an Adaptive Application. As part of the Adaptive Platform Methodology, these C++ header files are generated by a workflow tool directly from the ServiceInterface ARXML configuration either as part of the i) _Service/Common/Types Header file_ generation, or the ii) _Implementation Types header file_ generation [24].

> 本章节规定了在自适应应用程序中，在ServiceInterface的API实现中直接使用的C++头文件。作为自适应平台方法论的一部分，这些C++头文件是由一个工作流工具直接从ServiceInterface ARXML配置生成的，要么是i）_Service/Common/Types头文件_生成，要么是ii）_Implementation Types头文件_生成[24]。


The following requirements are applicable for all header files; requirements which are specific for a header file are described in own sub-chapters.

> 以下要求适用于所有头文件；特定于头文件的要求在各自的子章节中描述。


**[SWS_CM_01020]**{DRAFT} **Common/Service header files directory structure** *[*The *Service header file*s defined by [[SWS_CM_01002](#_bookmark451)] and the *Common header file*s defined by [[SWS_CM_01012](#_bookmark459)] shall be located within the folder:

> **[SWS_CM_01020]**{草案} **公共/服务头文件目录结构** *[*由[[SWS_CM_01002](#_bookmark451)]定义的*服务头文件*和由[[SWS_CM_01012](#_bookmark459)]定义的*公共头文件*应放置在以下文件夹中：

\<namespace[0]\>/\<namespace[1]\>/\.../\<namespace[n]\>/

where:


\<namespace[0]\> \... \<namespace[n]\> are the namespace names as defined in [[SWS_CM_01005](#_bookmark452)]._♩(RS_CM_00001, RS_AP_00114)_

> \<命名空间[0]\> \... \<命名空间[n]\> 是在[[SWS_CM_01005](#_bookmark452)]中定义的命名空间名称。_♩(RS_CM_00001, RS_AP_00114)_


**[SWS_CM_12000]**{DRAFT} **Implementation types header files directory structure** *[*The communication management expects the *Implementation Types header file*s generated according to [[SWS_CM_12001](#_bookmark463)] shall be located within the directory according to [SWS_LBAP_00034]._♩(RS_CM_00001, RS_AP_00114)_

> **[SWS_CM_12000]**{草案}**实施类型头文件目录结构** *[*根据[[SWS_CM_12001](#_bookmark463)]生成的*实施类型头文件*应该放置在[SWS_LBAP_00034]指定的目录中。_♩（RS_CM_00001，RS_AP_00114）_

### Service header files


The *Service header file*s are the central definition of the ara::com API and any associated data structures that are required by the AdaptiveApplication software components to use the communication management.

> 服务头文件是ara::com API和任何被自适应应用软件组件所需的相关数据结构的中央定义，用于管理通信。


**[SWS_CM_01002]**{DRAFT} **Service header files existence** *[*The communication management shall provide one _Proxy header file_ and one _Skeleton header file_ for each ServiceInterface defined in the input by using the file name \<name\>\_proxy.h for the _Proxy header file_ and \<name\>\_skeleton.h for the _Skeleton header file_, where \<name\> is the ServiceInterface.shortName converted to lower-case letters._♩(RS_CM_00001, RS_AP_00114, RS_AP_00116)_

> **[SWS_CM_01002]**{草案} **服务头文件存在性** *[*通信管理应提供一个_代理头文件_和一个_骨架头文件_，每个在输入中定义的ServiceInterface使用文件名\<name\>\_proxy.h作为_代理头文件_和\<name\>\_skeleton.h作为_骨架头文件_，其中\<name\>是转换为小写字母的ServiceInterface.shortName。_♩(RS_CM_00001, RS_AP_00114, RS_AP_00116)_


**[SWS_CM_01004]**{DRAFT} **Inclusion of common header file** *[*The _Proxy_ and _Skeleton header file_ shall include the _Common header file_:

> **[SWS_CM_01004]**{草案} **包含公共头文件** *[*_代理_和_骨架头文件_应包含_公共头文件_：

```
1 #include \"\<namespace[0]\>/\<namespace[1]\>/\.../\<namespace[n]\>/\<name\>
```

\_common.h\"

where:


\<namespace[0]\> \... \<namespace[n]\> are the namespace names as defined in [[SWS_CM_01005](#_bookmark452)] and [SWS_LBAP_00035]. \<name\> is the the ServiceInterface.shortName converted to lower-case letters._♩(RS_CM_00001, RS_AP_00114)_

> 命名空间[0] ... 命名空间[n]是在[[SWS_CM_01005](#_bookmark452)]和[SWS_LBAP_00035]中定义的命名空间名称。\<name\>是ServiceInterface.shortName转换为小写字母的名称。_♩(RS_CM_00001, RS_AP_00114)_


Namespaces are used to separate the definition of services from each other to prevent name conflicts and they allow to use reasonably short names.

> 命名空间用于将服务定义彼此分离，以防止名称冲突，并允许使用合理短的名称。


**[SWS_CM_01005]**{DRAFT} **Namespace of Service header files** *[*Based on the symbol attributes of the ordered SymbolProps aggregated by PortInterface in role namespace, the C++ namespace of the _Service header file_ shall be:

> **[SWS_CM_01005]**{草案} **服务头文件的命名空间** *[*基于按角色命名空间中PortInterface聚合的有序SymbolProps的符号属性，_服务头文件_的C++命名空间应为：

```
1 namespace \<ServiceInterface.namespace[0].symbol\> {

2 namespace \<ServiceInterface.namespace[1].symbol\> {

3 namespace \<\...\> {

4 namespace \<ServiceInterface.namespace[n].symbol\> {

5 \...

6 } // namespace \<ServiceInterface.namespace[n].symbol\>

7 } // namespace \<\...\>

8 } // namespace \<ServiceInterface.namespace[1].symbol\>

9 } // namespace \<ServiceInterface.namespace[0].symbol\>
```


with all namespace names converted to lower-case letters._♩(RS_CM_00002, RS_AP_00114)_

> 所有命名空间名称都转换为小写字母。♩（RS_CM_00002，RS_AP_00114）


Note: In order to avoid name clashes between Events, Fields, and Methods of different ServiceInterfaces in situation where the Events (ServiceInterface.event), Fields (ServiceInterface.field), and Methods (ServiceInterface.method) of the different ServiceInterfaces carry the same shortName, it is highly recommend to place different ServiceInterfaces into dedicated unique C++ namespaces. This is achieved by attaching corresponding ordered SymbolProps to the ServiceInterfaces where the ordered SymbolProps differ in at least one of their symbol attributes.

> 为了避免不同服务接口中的事件（ServiceInterface.event），字段（ServiceInterface.field）和方法（ServiceInterface.method）具有相同的短名称而发生的名称冲突，强烈建议将不同的服务接口放置到专用的C++命名空间中。这可以通过为服务接口附加相应的排序符号属性来实现，其中排序符号属性在其中一个符号属性上至少不同。


Starting from the innermost namespace as defined by [[SWS_CM_01005](#_bookmark452)], there are additional C++ namespaces for the proxy or the skeleton and for the events and methods. These namespaces are used for the declarations and definitions as described in chapter [8.1.3](#api-reference).

> 从[SWS_CM_01005](#_bookmark452)定义的最内层命名空间开始，还有额外的C++命名空间用于代理或骨架以及事件和方法。这些命名空间用于[8.1.3]（#api-reference）章节中描述的声明和定义。


**[SWS_CM_01006]**{DRAFT} **Service skeleton namespace** *[*The C++ namespace for a specific service skeleton class shall be:

> **[SWS_CM_01006]**{草案} **服务骨架命名空间** *[*特定服务骨架类的C++命名空间应为：

```
1 namespace skeleton {

2 \...

3 } // namespace skeleton
```

_♩(RS_CM_00002, RS_AP_00114)_


**[SWS_CM_01007]**{DRAFT} **Service proxy namespace** *[*The C++ namespace for a specific service proxy class shall be:

> **[SWS_CM_01007]**{草稿} **服务代理命名空间** *[*特定服务代理类的C++命名空间应该是：

```
1 namespace proxy {

2 \...

3 } // namespace proxy
```

_♩(RS_CM_00002, RS_AP_00114)_


**[SWS_CM_01009]**{DRAFT} **Service events namespace** *[*The _Proxy_ and _Skeleton header file_ shall provide a C++ namespace for the definition of events within the namespace defined by [[SWS_CM_01006](#_bookmark453)] and [[SWS_CM_01007](#_bookmark454)] respectively:

> **[SWS_CM_01009]**{草案} **服务事件命名空间** *[*代理和骨架头文件应该提供一个C++命名空间，用于根据[[SWS_CM_01006](#_bookmark453)]和[[SWS_CM_01007](#_bookmark454)]定义的命名空间来定义事件：

```
1 namespace events {

2 \...

3 } // namespace events
```

_♩(RS_AP_00114, RS_CM_00002)_


**[SWS_CM_01015]**{DRAFT} **Service methods namespace** *[*The _Proxy_ and _Skeleton header file_ shall provide a C++ namespace for the definition of methods within the namespace defined by [[SWS_CM_01006](#_bookmark453)] and [[SWS_CM_01007](#_bookmark454)] respectively:

> **[SWS_CM_01015]**{草案}**服务方法命名空间** *[*代理和骨架头文件应提供一个C++命名空间，用于定义[[SWS_CM_01006](#_bookmark453)]和[[SWS_CM_01007](#_bookmark454)]中定义的命名空间中的方法：

```
1 namespace methods {

2 \...

3 } // namespace methods
```

_♩(RS_CM_00002, RS_AP_00114)_


**[SWS_CM_01031]**{DRAFT} **Service fields namespace** *[*The _Proxy_ and _Skeleton header file_ shall provide a C++ namespace for the definition of fields within the namespace defined by [[SWS_CM_01006](#_bookmark453)] and [[SWS_CM_01007](#_bookmark454)] respectively:

> **[SWS_CM_01031]**{草案} **服务字段命名空间** *[*代理和骨架头文件应为[[SWS_CM_01006](#_bookmark453)]和[[SWS_CM_01007](#_bookmark454)]定义的命名空间提供一个C++命名空间，用于定义字段：

```
1 namespace fields {

2 \...

3 } // namespace fields
```

_♩(RS_CM_00002, RS_CM_00216, RS_AP_00114)_


As a summary of the C++ namespace requirements [[SWS_CM_01005](#_bookmark452)], [[SWS_CM_01006](#_bookmark453)], and [[SWS_CM_01009](#_bookmark455)], the namespace hierarchy in the _Skeleton header file_ looks like:

> 按照C++命名空间要求 [[SWS_CM_01005](#_bookmark452)], [[SWS_CM_01006](#_bookmark453)], 和 [[SWS_CM_01009](#_bookmark455)] 的总结，骨架头文件中的命名空间层次结构如下：

```
1 namespace \<ServiceInterface.namespace[0].symbol\> {

2 namespace \<ServiceInterface.namespace[1].symbol\> {

3 namespace \<\...\> {

4 namespace \<ServiceInterface.namespace[n].symbol\> {

5 namespace skeleton {

6

7 namespace events {

8 \...

9 } // namespace events

10

11 namespace methods {

12 \...

13 } // namespace methods

14

15 namespace fields {

16 \...

17 } // namespace fields

18

19 \...

20 } // namespace skeleton

21 } // namespace \<ServiceInterface.namespace[n].symbol\>

22 } // namespace \<\...\>

23 } // namespace \<ServiceInterface.namespace[1].symbol\>

24 } // namespace \<ServiceInterface.namespace[0].symbol\>
```


As a summary of the C++ namespace requirements [[SWS_CM_01005](#_bookmark452)], [[SWS_CM_01007](#_bookmark454)], [[SWS_CM_01009](#_bookmark455)], and [[SWS_CM_01015](#_bookmark456)], the namespace hierarchy in the _Proxy header file_ looks like:

> 总结C++命名空间要求[[SWS_CM_01005](#_bookmark452)], [[SWS_CM_01007](#_bookmark454)], [[SWS_CM_01009](#_bookmark455)], 和 [[SWS_CM_01015](#_bookmark456)], 代理头文件中的命名空间层次结构如下：

```
+----+-----------------------------------------------------------------+---+
| 1  | namespace \<ServiceInterface.namespace[0].symbol\>            | { |
+====+=================================================================+===+
| 2  | namespace \<ServiceInterface.namespace[1].symbol\>            | { |
+----+-----------------------------------------------------------------+---+
| 3  | namespace \<\...\> {                                            |   |
+----+-----------------------------------------------------------------+---+
| 4  | namespace \<ServiceInterface.namespace[n].symbol\>            | { |
+----+-----------------------------------------------------------------+---+
| 5  | namespace proxy {                                               |   |
+----+-----------------------------------------------------------------+---+
| 6  | namespace events {                                              |   |
|    |                                                                 |   |
| 7  |                                                                 |   |
+----+-----------------------------------------------------------------+---+
| 8  | \...                                                            |   |
+----+-----------------------------------------------------------------+---+
| 9  | } // namespace events                                           |   |
+----+-----------------------------------------------------------------+---+
| 10 |                                                                 |   |
+----+-----------------------------------------------------------------+---+
| 11 | namespace methods {                                             |   |
+----+-----------------------------------------------------------------+---+
| 12 | \...                                                            |   |
+----+-----------------------------------------------------------------+---+
| 13 | } // namespace methods                                          |   |
+----+-----------------------------------------------------------------+---+
| 14 |                                                                 |   |
+----+-----------------------------------------------------------------+---+
| 15 | namespace fields {                                              |   |
+----+-----------------------------------------------------------------+---+
| 16 | \...                                                            |   |
+----+-----------------------------------------------------------------+---+
| 17 | } // namespace fields                                           |   |
+----+-----------------------------------------------------------------+---+
| 18 |                                                                 |   |
+----+-----------------------------------------------------------------+---+
| 19 | \...                                                            |   |
+----+-----------------------------------------------------------------+---+

20 } // namespace proxy

21 } // namespace \<ServiceInterface.namespace[n].symbol\>

22 } // namespace \<\...\>

23 } // namespace \<ServiceInterface.namespace[1].symbol\>

24 } // namespace \<ServiceInterface.namespace[0].symbol\>
```

### Common header file


The _Common header file_ includes the ara::com specific type declarations derived from the ApApplicationErrors composed by a particular ServiceInterface as well Service Identifier type declarations related to a particular ServiceInterface.

> 通用头文件包括ara::com特定类型的声明，这些声明源自由特定服务接口组成的ApApplicationErrors，以及与特定服务接口相关的服务标识符类型声明。


**[SWS_CM_01012]**{DRAFT} **Common header file existence** *[*The communication management shall provide a _Common header file_ for each ServiceInterface defined in the input by using the file name \<name\>\_common.h, where \<name\> is the ServiceInterface.shortName converted to lower-case letters._♩(RS_CM_00001, RS_AP_00114, RS_AP_00116)_

> **[SWS_CM_01012]**{草案} **通用头文件存在性** *[*通信管理应为输入中定义的每个ServiceInterface提供以文件名\<name\>\_common.h命名的_Common header file_，其中\<name\>是ServiceInterface.shortName转换为小写字母。_♩(RS_CM_00001, RS_AP_00114, RS_AP_00116)_


As a minimal requirement, the _Types header file_ and the _Implementation Types header files_ need to be included.

> 作为最低要求，需要包含_Types头文件_和_实现Types头文件_。


**[SWS_CM_01001]**{DRAFT} **Inclusion of Types header file** *[*The _Common header file_ shall include the _Types header file_:

> **[SWS_CM_01001]**{草案} **包含类型头文件** *[*通用头文件_应该包含_类型头文件_：

```
1 #include \"ara/com/types.h\"
```

_♩(RS_CM_00001, RS_AP_00114)_


**[SWS_CM_10372]**{DRAFT} **Inclusion of Implementation Types header files** *[*The _Common header file_ shall include the _Implementation Types header files_ of those CppImplementationDataTypes that are actually _used_ by the particular ServiceInterface:

> **[SWS_CM_10372]**{草案} **包含实现类型头文件** *[*公共头文件必须包含那些实际被特定服务接口_使用_的CppImplementationDataTypes的_实现类型头文件_:

```
1 #include \"\<namespace[0]\>/\<namespace[1]\>/\.../\<namespace[n]\>/impl_type_\< symbol\>.h\"
```


where \<namespace[0..n]\> is the namespace hierarchy defined in [SWS_LBAP_00035], and \<symbol\> is the Cpp Implementation Data Type symbol according to [24] converted to lower-case letters._♩(RS_CM_00001, RS_AP_00114)_

> 在[SWS_LBAP_00035]中定义的命名空间层次结构\<namespace[0..n]\>，以及根据[24]转换为小写字母的Cpp实现数据类型符号\<symbol\>，请参考(RS_CM_00001, RS_AP_00114)。


It is not mandatory that all declarations and definitions are located directly in the _Common header file_. A Communication Management implementation might also distribute the declarations and definitions into different header files, but at least all those header files need to be included into the _Common header file_.

> 不是所有的声明和定义都必须直接位于_Common头文件_中。通信管理实现也可以将声明和定义分布到不同的头文件中，但是至少所有这些头文件都需要包含在_Common头文件_中。


**[SWS_CM_10370]**{DRAFT} **Common header file for Application Errors** *[*The _Common header file_ shall include the class definitions for all ApApplicationErrorDomains for the ApApplicationErrors of a ServiceInterface according to [[SWS_CM_11266](#_bookmark500)]._♩(RS_CM_00001)_

> **[SWS_CM_10370]**{草稿} **应用错误的通用头文件** *[*_通用头文件_应该包含根据[[SWS_CM_11266](#_bookmark500)]所有ApApplicationErrorDomains的服务接口的ApApplicationErrors的类定义。_♩(RS_CM_00001)_


**[SWS_CM_01017]**{DRAFT} **Service Identifier Type definitions in Common header file** *[*The _Common header file_ shall include the information to identify the service type according to the requirement [[SWS_CM_01010](#_bookmark467)]._♩(RS_CM_00001)_

> **[SWS_CM_01017]**{草案} **公共头文件中的服务标识符类型定义** *[*根据要求[[SWS_CM_01010](#_bookmark467)]，_公共头文件_应包含用于识别服务类型的信息。_♩(RS_CM_00001)_


**[SWS_CM_01008]**{DRAFT} **Namespace for Service Identifier Type definitions** *[*The declarations and definitions according to [[SWS_CM_01017](#_bookmark460)] shall be located in the C++ namespace as defined by [[SWS_CM_01005](#_bookmark452)] to match to the namespace of the related skeleton and proxy header file._♩(RS_CM_00002)_

> **[SWS_CM_01008]**{草案} **服务标识符类型定义的命名空间** *[*根据[[SWS_CM_01017](#_bookmark460)] 的声明和定义应该放置在C++命名空间中，以匹配与相关的骨架和代理头文件的命名空间。_♩(RS_CM_00002)_

### Types header file


The _Types header file_ includes the data type definitions which are specific for the ara::com API. Such data type definitions are used in the standardized proxy and skeleton interfaces defined in chapter [8.1.3](#api-reference).

> 文件_Types_包含特定于ara::com API的数据类型定义。这些数据类型定义用于第[8.1.3](#api-reference)节中定义的标准代理和骨架接口。


**[SWS_CM_01013]**{DRAFT} **Types header file existence** *[*The communication management shall provide a _Types header file_ by using the file name types.h._♩(RS_CM_00001, RS_AP_00114, RS_AP_00116)_

> **[SWS_CM_01013]**{草案} **类型头文件存在性** *[*通信管理应使用文件名types.h提供一个_类型头文件_。♩(RS_CM_00001, RS_AP_00114, RS_AP_00116)_


**[SWS_CM_01018]**{DRAFT} **Types header file namespace** *[*The C++ namespace for the data type definitions included by the _Types header file_ shall be:

> **[SWS_CM_01018]**{草案} **数据类型头文件的命名空间** *[*_Types header file_ 所包含的数据类型定义的 C++ 命名空间应为：

```
1 namespace ara {

2 namespace com {

3 \...

4 } // namespace com

5 } // namespace ara
```

_♩(RS_CM_00002, RS_AP_00114)_


It is not mandatory that all data type definitions are located directly in the _Types header file_. A Communication Management implementation might also distribute the definitions into different header files, but at least all those header files need to be included into the _Types header file_.

> 不是所有数据类型定义都必须直接位于_Types头文件中。通信管理实现也可能将定义分发到不同的头文件中，但至少所有这些头文件都需要包含在_Types头文件中。


**[SWS_CM_01019]**{DRAFT} **Data Type declarations in Types header file** *[*The _Types header file_ shall include the data type definitions according to [[SWS_CM_00301](#_bookmark487)], [[SWS_CM_00302](#sws_cm_00302draft-instance-identifier-class)], [[SWS_CM_00303](#_bookmark470)], [[SWS_CM_00304](#_bookmark475)], [[SWS_CM_00383](#_bookmark476)], [[SWS_CM_00306](#_bookmark478)], [[SWS_CM_00308](#_bookmark480)], [[SWS_CM_00309](#_bookmark481)], [[SWS_CM_00310](#_bookmark482)], and [[SWS_CM_00311](#_bookmark483)]._♩(RS_CM_00001)_

> **[SWS_CM_01019]**{草案} **类型头文件中的数据类型声明** *[*_类型头文件_应根据[[SWS_CM_00301](#_bookmark487)], [[SWS_CM_00302](#sws_cm_00302draft-instance-identifier-class)], [[SWS_CM_00303](#_bookmark470)], [[SWS_CM_00304](#_bookmark475)], [[SWS_CM_00383](#_bookmark476)], [[SWS_CM_00306](#_bookmark478)], [[SWS_CM_00308](#_bookmark480)], [[SWS_CM_00309](#_bookmark481)], [[SWS_CM_00310](#_bookmark482)], 和 [[SWS_CM_00311](#_bookmark483)] 之中的定义，包含数据类型定义。_♩(RS_CM_00001)_

### Implementation Types header files


As part of the Adaptive Application methodology, all referenced CppImplementationDataTypes in all modeled ServiceInterfaces for a given Adaptive Application, must be processed by an ARA generator to generate the respective C++ language binding representation [29].

> 根据自适应应用方法，所有在所给自适应应用中模型化的服务接口中引用的CppImplementationDataTypes必须由ARA生成器处理，以生成相应的C++语言绑定表示[29]。


The processing rules which specify how an ARA generator shall create the _Implementation Types header files_ are specified in detail in [24]. The role of communication management is as a 'consumer' of the respective generated _Implementation Types header files_.

> 处理规则指定ARA生成器如何创建_实施类型头文件_，详情参见[24]。通信管理的作用是“消费者”，消费相应的生成的_实施类型头文件_。


**[SWS_CM_12001]**{DRAFT} **C++ Implementation Data Types files** *[*The communication management shall use the generated *C++ Implementation Types header file*s produced according to:

> **[SWS_CM_12001]**{草案} **C++ 实现数据类型文件** *[*通信管理应按照以下标准使用生成的*C++ 实现类型头文件*：

- [SWS_LBAP_00032] (header file generation),
- [SWS_LBAP_00033] (header file naming),
- [SWS_LBAP_00034] (directory naming),

_♩()_

### Raw Data Stream header file


The _Raw data stream header file_ includes the data type definitions specific for the ara::com::raw API for Raw Data Streams.

> 原始数据流头文件包括专门为ara::com::raw API提供的原始数据流的数据类型定义。


**[SWS_CM_10488] Raw data stream header file existence** *[*The communication management shall provide a _Raw data stream header file_ by using the file name raw_data_stream.h._♩(RS_CM_00001)_

> 通信管理应使用文件名raw_data_stream.h提供原始数据流头文件。 (RS_CM_00001)


**[SWS_CM_10489] Raw data stream header file namespace** *[*The C++ namespace for the data type definitions included by the _Raw data stream header file_ shall be:

> **[SWS_CM_10489]原始数据流头文件命名空间** *[*_原始数据流头文件_所包含的数据类型定义的C++命名空间应为：

```
1 namespace ara {

2 namespace com {

3 namespace raw {

4 \...

5 } // namespace raw

6 } // namespace com

7 } // namespace ara
```

_♩(RS_CM_00002)_


**[SWS_CM_10490] Data Type declarations in Raw data stream header file** *[*The _Raw data stream header file_ shall include the class definitions according to [SWS_CM_10481], [SWS_CM_10482], [SWS_CM_10483], [SWS_CM_10484], [SWS_CM_10485], [SWS_CM_10486] and [SWS_CM_10487]._♩(RS_CM_00001)_

> **[SWS_CM_10490]原始数据流标头文件中的数据类型声明** *[*_原始数据流标头文件_应根据[SWS_CM_10481]，[SWS_CM_10482]，[SWS_CM_10483]，[SWS_CM_10484]，[SWS_CM_10485]，[SWS_CM_10486]和[SWS_CM_10487]包括类定义。_♩(RS_CM_00001)_*

### API Data Types


This chapter describes the data types used by the ara::com API, both the specific ones which are part of the standardized proxy and skeleton interfaces, and the ones derived from the description based on the AUTOSAR meta-model.

> 本章节描述了ara::com API使用的数据类型，包括作为标准代理和骨架接口的一部分的特定类型，以及基于AUTOSAR元模型描述而派生的类型。

### Service Identifier Data Types


For the functional description of the Service Identifier Data Types, see chapter [7.9.17.1](#service-identifier-data-types). The data types described in this chapter are derived from the ara::com API design.

> 对于服务标识符数据类型的功能描述，请参见第7.9.17.1章节（服务标识符数据类型）。本章所描述的数据类型是基于ara :: com API设计而派生的。


The serviceIdentifier is not visible in the ara::com API, as the specific service skeleton and proxy class itself represent the service type, but the serviceIdentifier is needed for the implementation of the Communication Management software. It is defined here to guarantee a minimum amount of information.

> 服务标识符不在ara::com API中可见，因为特定的服务骨架和代理类本身代表服务类型，但通信管理软件的实现需要服务标识符。它在这里定义以保证最低限度的信息。


**[SWS_CM_01010]**{DRAFT} **Service Identifier and Service Contract Version** *[*The Communication Management shall provide a C++ class named ServiceInterface.shortName. The class contains at least a fully qualified name identifier (serviceIdentifier) , a service contract major (serviceContractVersionMajor) and minor (serviceContractVersionMinor) version number.

> **[SWS_CM_01010]**{草案} **服务标识符和服务合同版本** *[*通信管理应提供一个名为ServiceInterface.shortName的C++类。该类至少包含一个完全限定名标识符（serviceIdentifier）、服务合同主（serviceContractVersionMajor）和次（serviceContractVersionMinor）版本号。


The exact type of serviceIdentifier is specific to the Communication Management software provider. Its concrete realization is implementation defined. To allow for logging and for storing and managing in C++ container classes by the using application, however, the type of the class shall satisfy the EqualityComparable requirements according to table 17, the LessThanComparable requirements according to table 18, and the CopyAssignable requirements according to table 23 of section 17.6.3.1 of [30]. These requirements are fulfilled if the operators operator==, operator\<, and operator= as well as a toString() method is provided.

> 服务标识符的确切类型取决于通信管理软件提供商。其具体实现是实现定义的。为了允许日志记录，以及使用应用程序在C++容器类中存储和管理，但是，类的类型应满足[30]的17.6.3.1节中表17中的相等可比较要求，表18中的小于可比较要求以及表23中的复制可赋值要求。如果提供了运算符operator==，operator<和operator=以及toString（）方法，则这些要求就得到满足。

```
1 class \<ServiceInterface.shortName\> {

2 public:

3 static const serviceIdentifierType serviceIdentifier;

4

5 static std::uint32_t serviceContractVersionMajor;

6 static std::uint32_t serviceContractVersionMinor;

7 };

8

9 class serviceIdentifierType {

10 bool operator==(const serviceIdentifierType& other) const;

11 bool operator\<(const serviceIdentifierType& other) const;

12 serviceIdentifierType& operator=(const serviceIdentifierType& other);

13 ara::core::StringView ToString() const;

14 };
```

_♩(RS_CM_00200, RS_CM_00500)_


InstanceIdentifier or InstanceSpecifier are a necessary parameter of the API defined for both the skeleton and proxy side:

> 实例标识符或实例指定符是为骨架和代理端定义的API所必需的参数。


- on service skeleton side, it types the parameter needed to identify the service instance when creating an instance by [[SWS_CM_00130](#_bookmark525)],[[SWS_CM_00152](#_bookmark527)],[[SWS_CM_00153](#_bookmark529)].

> 在服务骨架端，当使用[[SWS_CM_00130](#_bookmark525)],[[SWS_CM_00152](#_bookmark527)],[[SWS_CM_00153](#_bookmark529)]创建实例时，它会输入用于识别服务实例所需的参数。

- on service proxy side, it types the parameter needed to identify the service instance when searching for a specific instance by [[SWS_CM_00122](#_bookmark550)] or [[SWS_CM_00123](#_bookmark552)].

> 在服务代理端，当使用[[SWS_CM_00122](#_bookmark550)]或[[SWS_CM_00123](#_bookmark552)]搜索特定实例时，它会输入需要识别服务实例的参数。

### [SWS_CM_00302] {DRAFT} Instance Identifier Class _[_


The Communication Management shall provide a class InstanceIdentifier. The definition of the InstanceIdentifier can be extended by the Communication Management software provider, but at least the given Named Constructor Create (), the class constructor and the class method signatures must be preserved. InstanceIdentifier shall further satisfy the EqualityComparable requirements according to table 17, the LessThanComparable requirements according to table 18, and the CopyAssignable requirements according to table 23 of section 17.6.3.1 of [30] to allow for logging of InstanceIdentifiers as well as storing and managing InstanceIdentifiers in C++ container classes by the using application. These requirements are fulfilled if the operators operator==, operator\<, and operator= as well as a ToString() method is provided.

> 管理通信将提供一个类实例标识符。实例标识符的定义可以由通信管理软件提供商扩展，但至少必须保留给定的命名构造函数Create（），类构造函数和类方法签名。实例标识符还应满足表17中的等价可比要求，表18中的小于可比要求以及表23中的复制可分配要求，以便使用应用程序可以记录实例标识符，并在C ++容器类中存储和管理实例标识符。如果提供了operator ==，operator <和operator =以及ToString（）方法，则满足这些要求。

管理通信将提供一个类实例标识符。实例标识符的定义可以由通信管理软件提供商扩展，但至少必须保留给定的命名构造函数Create（），类构造函数和类方法签名。实例标识符还应满足[30]第17.6.3.1节中表17，18和23所列的等价可比，小于可比和复制可分配要求，以便使用应用程序可以记录实例标识符，并在C ++容器类中存储和管理实例标识符。如果提供了operator ==，operator <和operator =以及ToString（）方法，则满足这些要求。


The format of the string passed to the constructor, or returned by the ToString() method is specific to the Communication Management software provider, and not standardized.

> 传递给构造函数或由ToString（）方法返回的字符串格式取决于通信管理软件供应商，而不是标准化的。


In case the format of the string representation provided to Create() is corrupted, or not compliant to the software provider specification, an error code ComErrc::kInvalidInstanceIdentifierString shall be returned in the Result type.

> 如果提供给Create()的字符串表示格式损坏或不符合软件提供商规范，则Result类型中将返回错误代码ComErrc::kInvalidInstanceIdentifierString。


The class constructor shall throw a ComException in case the format of the string provided is corrupted, or not compliant to the software provider specification.

> 类构造函数应该在提供的字符串格式损坏或者不符合软件提供者规范时抛出ComException。

```
1 class InstanceIdentifier {

2 public:

3

4 static ara::core::Result\<InstanceIdentifier\> Create(StringView serializedFormat) noexcept;

5 explicit InstanceIdentifier( ara::core::StringView serializedFormat);

6 ara::core::StringView ToString() const;

7 bool operator==(const InstanceIdentifier& other) const;

8 bool operator\<(const InstanceIdentifier& other) const;

9 InstanceIdentifier& operator=(const InstanceIdentifier& other);

10 };
```

_♩(RS_CM_00101, RS_CM_00102, RS_AP_00114, RS_AP_00122, RS_AP_00127)_


**[SWS_CM_00319]**{DRAFT} **Instance Identifier Container Class** *[*The Communication Management shall provide the definition of a InstanceIdentifierContainer. The container holds a list of [render=InstanceIdentifier]ara::com::InstanceIdentifier. The assigned data type is allowed to be changed by the Communication Management software provider, but must adhere to the _general container requirements_ according to table 96 of section 23.2.1 and the _sequence container requirements_ according to table 100 of section 23.2.3 of [30]. A ara::core::Vector for example fulfills these requirements.

> **[SWS_CM_00319]**{草案} **实例标识符容器类** *[*通信管理应提供实例标识符容器的定义。该容器保存[render=InstanceIdentifier]ara::com::InstanceIdentifier的列表。允许通信管理软件提供商更改分配的数据类型，但必须遵守根据第23.2.1节的表96和根据第23.2.3节表100的_通用容器要求_ [30]的要求。例如，ara::core::Vector满足这些要求。


1 using InstanceIdentifierContainer = ara::core::Vector\<InstanceIdentifier\>;

> 使用InstanceIdentifierContainer = ara::core::Vector<InstanceIdentifier>;

_♩(RS_CM_00101, RS_CM_00102, RS_AP_00114, RS_AP_00122)_


The following data types are used for the handling of services on the service consumer side, therefore they are part of the API defined for the proxy side.

> 以下数据类型用于处理服务消费者端的服务，因此它们是代理端定义的API的一部分。


**[SWS_CM_00303]**{DRAFT} **Find Service Handle** *[*The Communication Management shall provide the definition of an opaque FindServiceHandle with exactly this name. FindServiceHandle shall satisfy the EqualityComparable requirements according to table 17, the LessThanComparable requirements according to table 18, and the CopyAssignable requirements according to table 23 of section 17.6.3.1 of [30] to allow storing and managing FindServiceHandles in C++ container classes by the using application. These requirements are fulfilled if the following operators are provided: operator==, operator\<, and operator=. The exact definition of FindServiceHandle is communication management implementation specific._♩(RS_CM_00102, RS_AP_00122)_

> **[SWS_CM_00303]**{草案} **查找服务句柄** *[*通信管理应提供此名称的不透明查找服务句柄的定义。根据[30]第17.6.3.1节的表17，表18的相等可比要求和表23的小于可比要求，FindServiceHandle应满足相等可比要求。这些要求可以通过提供以下运算符来满足：operator==，operator<和operator=。FindServiceHandle的确切定义是通信管理实现特定的。_♩（RS_CM_00102，RS_AP_00122）_

For example, a definition of FindServiceHandle could look like this:

```
1 struct FindServiceHandle {

2 internal::ServiceId serviceIdentifier;

3 internal::InstanceId instanceIdentifier;

4 std::uint32_t uid;

5

6 bool operator==(const FindServiceHandle& other) const;

7 bool operator\<(const FindServiceHandle& other) const;

8 FindServiceHandle& operator=(const FindServiceHandle& other);

9 \...

10 };
```


**[SWS_CM_00312]**{DRAFT} **Handle Type Class** *[*The Communication Management shall provide the definition of HandleType. It types the handle for a specific service instance and shall contain the information that is needed to create a ServiceProxy. The definition of the HandleType can be extended by the Communication Management software provider, but at least the given class and class method signatures must be preserved.

> **[SWS_CM_00312]**{草案}**处理类型类** *[*通信管理应提供HandleType的定义。它为特定服务实例分配类型的句柄，并包含创建ServiceProxy所需的信息。HandleType的定义可由通信管理软件提供商扩展，但至少必须保留给定的类和类方法签名。


HandleType shall satisfy the EqualityComparable requirements according to table 17 and the LessThanComparable requirements according to table 18 of section 17.6.3.1 of [30]. These requirements are fulfilled if the following operators are provided: operator== and operator\<. This, together with [[SWS_CM_00317](#_bookmark472)] and [[SWS_CM_00318](#_bookmark473)], allows storing and managing HandleTypes in C++ container classes by the using application.

> 处理类型应满足[30]17.6.3.1表17中的EqualityComparable要求和表18中的LessThanComparable要求。如果提供了operator==和operator<运算符，则这些要求就得到满足。这与[[SWS_CM_00317](#_bookmark472)]和[[SWS_CM_00318](#_bookmark473)]一起，允许使用应用程序将处理类型存储和管理在C++容器类中。


The definition of the HandleType class shall be located inside the ServiceProxy class defined by [[SWS_CM_00004](#_bookmark516)]. This allows the Communication Management software to provide handles with different implementation dependent on the binding to the represented service.

> 类HandleType的定义将位于由[[SWS_CM_00004](#_bookmark516)]定义的ServiceProxy类内。这样，通信管理软件就可以根据表示服务的绑定提供具有不同实现的句柄。

```
1 class HandleType {

2 public:

3 bool operator==(const HandleType& other) const;

4 bool operator\<(const HandleType& other) const;

5 const ara::com::InstanceIdentifier& GetInstanceId() const;

6 };
```

_♩(RS_CM_00102, RS_AP_00114, RS_AP_00122)_


Since the Communication Management software is responsible for creation of handles and the application just uses instances of it, the constructor signature is not part of the HandleType specification.

> 由于通信管理软件负责创建句柄，而应用程序只使用它的实例，因此构造函数签名不是HandleType规范的一部分。


**[SWS_CM_00820]**{DRAFT} **Binding information** *[*HandleType class shall have embedded information to determine how the ServiceProxy shall react to different service discovery mechanism._♩()_

> **[SWS_CM_00820]**{草案} **绑定信息** *[*HandleType 类应具有嵌入信息，以确定服务代理如何对不同的服务发现机制做出反应。_♩()_


**[SWS_CM_00317]**{DRAFT} **Copy semantics of handle Type Class** *[*The Communication Management shall provide the possibility to copy construct and copy assign a HandleType instance from another instance.

> **[SWS_CM_00317]**{草案}**复制句柄类型类的语义** *[*通信管理应提供从另一个实例复制构造和复制分配HandleType实例的可能性。

HandleType(const HandleType&); HandleType& operator=(const HandleType&);

_♩(RS_CM_00102, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_00318]**{DRAFT} **Move semantics of handle Type Class** *[*The Communication Management shall provide the possibility to move construct and move assign a HandleType instance from another instance.

> **[SWS_CM_00318]**{草案} **句柄类型类的移动语义** *[*通信管理应提供从另一个实例移动构造和移动赋值句柄类型实例的可能性。

HandleType(HandleType &&); HandleType& operator=(HandleType &&);

_♩(RS_CM_00102, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_11371]**{DRAFT} **HandleType destructor** *[*The Communication Management shall provide a destructor for the the HandleType.

> 通信管理应提供HandleType的析构函数。

\~HandleType() noexcept;

_♩(RS_AP_00114, RS_AP_00145, RS_AP_00132)_


**[SWS_CM_00304]**{DRAFT} **Service Handle Container** *[*The Communication Management shall provide the definition of a ServiceHandleContainer. The container holds a list of service handles and is used as a return value of the FindService methods. The assigned data type is allowed to be changed by the Communication Management software provider, but must adhere to the _general container requirements_

> **[SWS_CM_00304]**{草案} **服务句柄容器** *[*通信管理应提供ServiceHandleContainer的定义。该容器保存着服务句柄的列表，并作为FindService方法的返回值使用。分配的数据类型可以由通信管理软件提供商更改，但必须符合_一般容器要求_。


according to table 96 of section 23.2.1 and the _sequence container requirements_ according to table 100 of section 23.2.3 of [30]. A ara::core::Vector for example fulfills these requirements.

> 根据第23.2.1节的表96和_序列容器要求_根据第23.2.3节的表100 [30]，例如ara::core::Vector可以满足这些要求。

```
1 template \<typename T\>

2 using ServiceHandleContainer = ara::core::Vector\<T\>;
```

_♩(RS_CM_00102, RS_AP_00114, RS_AP_00122)_


The possibility to continuously find services by registering a _handler function_ as defined in [[SWS_CM_00123](#_bookmark552)] requires a definition of such a _handler function_. The function implementation itself is to be provided by the proxy user.

> 参照[SWS_CM_00123]（#_bookmark552）中定义的处理函数（_handler function_），连续查找服务的可能性需要定义这样一个处理函数。函数的实现本身将由代理用户提供。


**[SWS_CM_00383]**{DRAFT} **Find Service Handler** *[*The Communication Management shall provide the definition of FindServiceHandler as a function wrapper for the handler function that gets called by the Communication Management software in case the service availability changes. It takes as input parameter a handle container containing handles for all matching service instances and a FindServiceHandle which can be used to invoke StopFindService (see [[SWS_CM_00125](#_bookmark555)]) from within the FindServiceHandler.

> **[SWS_CM_00383]**{草案} **查找服务处理器** *[*通信管理应提供FindServiceHandler的定义，作为一个函数包装器，当通信管理软件调用时，该处理程序函数将被调用，以改变服务可用性。它以包含所有匹配服务实例的句柄容器和FindServiceHandle作为输入参数，可用于从FindServiceHandler中调用StopFindService（参见[[SWS_CM_00125](#_bookmark555)])。

```
1 template \<typename T\>

2 using FindServiceHandler =

3 std::function\<void(ServiceHandleContainer\<T\>, FindServiceHandle)\>;
```

_♩(RS_CM_00102, RS_AP_00114, RS_AP_00120)_


See [[SWS_CM_00304](#_bookmark475)] for the type definition of ServiceHandleContainer.

> 见[[SWS_CM_00304](#_bookmark475)] 以获取ServiceHandleContainer的类型定义。

### Event Related Data Types


For the functional description of the Event Related Data Types, see chapter [7.9.17.2](#event-related-data-types).

> 对于事件相关数据类型的功能描述，请参见第7.9.17.2章（事件相关数据类型）。


SamplePtr behaves similar to std::unique_ptr but it may be implemented with a subset of features. It also contains an additional method GetProfileCheckStatus to access the E2E results provided by ProfileCheckStatus of the referred sample.

> SamplePtr 的行为类似于 std::unique_ptr，但它可能只实现其中的一些特性。它还包含一个额外的方法 GetProfileCheckStatus 来访问所引用样本的 ProfileCheckStatus 提供的 E2E 结果。


**[SWS_CM_00306]**{DRAFT} **Sample Pointer** *[*The Communication Management shall provide a SamplePtr template which provides a pointer to a managed data object. The implementation shall at least contain the following constructors, assign operators and methods:

> **[SWS_CM_00306]**{草案} **样本指针** *[*通信管理应提供一个SamplePtr模板，它指向一个受管理的数据对象。实现至少应包括以下构造函数、赋值运算符和方法：

```
template\< typename T \> class SamplePtr {

// Default constructor constexpr SamplePtr() noexcept;

// semantically equivalent to Default constructor constexpr SamplePtr(std::nullptr_t) noexcept;

// Copy constructor is deleted SamplePtr ( const SamplePtr& ) = delete;

// Move constructor

SamplePtr( SamplePtr&& ) noexcept;

// Destructor

\~SamplePtr() noexcept;

// Default copy assignment operator is deleted SamplePtr& operator=( const SamplePtr& ) = delete;

// Assignment of nullptr_t

SamplePtr& operator=(std::nullptr_t) noexcept;

// Move assignment operator

SamplePtr& operator=( SamplePtr&& ) noexcept;

// Dereferences the stored pointer T& operator\*() const noexcept;

T\* operator-\>() const noexcept;

//Checks if the stored pointer is null explicit operator bool () const noexept;

// Swaps the managed object

void Swap ( SamplePtr& ) noexcept;

//Replaces the managed object

void Reset (std::nullptr_t) noexcept;

//Returns the stored object T\* Get () const noexcept;

// Returns the end 2 end protection check result ara::com::e2e::ProfileCheckStatus GetProfileCheckStatus() const noexcept;

};
```


_♩(RS_CM_00202, RS_CM_00203, RS_AP_00114, RS_AP_00122, RS_AP_00132, RS_AP_00135, RS_AP_00145)_

> ♩（RS_CM_00202，RS_CM_00203，RS_AP_00114，RS_AP_00122，RS_AP_00132，RS_AP_00135，RS_AP_00145）


**[SWS_CM_90420]**{DRAFT} **E2E ProfileCheckStatus of a sample** *[*The SamplePtr shall provide the access to the ProfileCheckStatus of each sample by means of the method GetProfileCheckStatus:

> **[SWS_CM_90420]**{草案}**一个样本的E2E ProfileCheckStatus** *[*SamplePtr应通过GetProfileCheckStatus方法提供对每个样本的ProfileCheckStatus的访问。

```
1 ara::com::e2e::ProfileCheckStatus GetProfileCheckStatus() const noexcept;

2
```

_♩(RS_E2E_08534, RS_AP_00114, RS_AP_00120, RS_AP_00132)_


**[SWS_CM_00308]**{DRAFT} **Sample Allocatee Pointer** *[*The Communication Management shall provide the definition of SampleAllocateePtr as a pointer to a data sample allocated by the Communication Management implementation. The implementation is allowed to be changed by the Communication Management software provider.

> **[SWS_CM_00308]**{草案}**样本分配者指针** *[*通信管理应提供SampleAllocateePtr作为指向由通信管理实现分配的数据样本的定义。允许通信管理软件提供商更改实现。

```
1 template \<typename T\>

2 using SampleAllocateePtr = std::unique_ptr\<T\>;
```

_♩(RS_CM_00201, RS_AP_00114, RS_AP_00122, RS_AP_00135)_


**[SWS_CM_00309]**{DRAFT} **Event Receive Handler** *[*The Communication Management shall provide the definition of EventReceiveHandler as a function wrapper without parameters for the handler function that gets called by the Communication Management software in case new event data arrives for an event. The event receiver must provide the function implementation which is not required to be re-entrant.

> **[SWS_CM_00309]**{草案} **事件接收处理器** *[*通信管理必须提供EventReceiveHandler的定义，作为一个没有参数的函数包装器，用于当新的事件数据到达时被通信管理软件调用的处理函数。接收器必须提供函数实现，不需要重入。


The symbolic name is set; for the alias it is recommended to use the C++ generalpurpose polymorphic function wrapper std::function, but this is not mandatory and is allowed to be changed by the Communication Management software provider.

> 符号名称已设置；建议使用C++通用多态函数包装器std :: function为别名，但这不是强制性的，并允许通信管理软件提供商进行更改。

```
1 using EventReceiveHandler = std::function\<void()\>;
```

_♩(RS_AP_00114, RS_CM_00203, RS_AP_00120)_


**[SWS_CM_00310]**{DRAFT} **Subscription State** *[*The Communication Management shall provide an enumeration SubscriptionState which defines the subscription state of an event.

> **[SWS_CM_00310]**{草稿} **订阅状态** *[*通信管理应提供一个枚举SubscriptionState，它定义了事件的订阅状态。

```
1 enum class SubscriptionState : std::uint8_t {

2 kSubscribed,

3 kNotSubscribed,

4 kSubscriptionPending

5 };
```


_♩(RS_CM_00103, RS_CM_00104, RS_CM_00106, RS_AP_00114, RS_AP_00125, RS_AP_00119)_

> _♩（RS_CM_00103，RS_CM_00104，RS_CM_00106，RS_AP_00114，RS_AP_00125，RS_AP_00119）_


**[SWS_CM_00311]**{DRAFT} **Subscription State Changed Handler** *[*The Communication Management shall provide the definition of SubscriptionStateChangeHandler as a function wrapper for the handler function that gets called by the Communication Management software in case the subscription state of an event has changed.

> **[SWS_CM_00311]**{草案} **订阅状态更改处理程序** *[*通信管理应提供SubscriptionStateChangeHandler的定义，作为一个函数包装器，用于处理函数，该处理函数在事件的订阅状态发生变化时由通信管理软件调用。

```
1 using SubscriptionStateChangeHandler =

2 std::function\<void(SubscriptionState)\>;
```

_♩(RS_CM_00103, RS_CM_00104, RS_CM_00106, RS_AP_00114, RS_AP_00120)_

### Trigger Related Data Types


For the functional description of the Trigger Related Data Types, see chapter [7.9.17.3](#trigger-related-data-types).

> 对于触发器相关数据类型的功能描述，请参阅第7.9.17.3章节。


**[SWS_CM_00351]**{DRAFT} **Trigger Receive Handler** *[*The definition of _Trigger Receive Handler_ is the same as _Trigger Receive Handler_ defined in [[SWS_CM_00309](#_bookmark481)]

> **[SWS_CM_00351]**{草案} **触发接收处理程序** *[*触发接收处理程序的定义与[[SWS_CM_00309](#_bookmark481)]中定义的触发接收处理程序相同。

```
1 using TriggerReceiveHandler = std::function\<void()\>;
```

_♩(RS_AP_00114, RS_CM_00203, RS_AP_00120)_

### Method Related Data Types


For the functional description of the Method Related Data Types, see chapter [7.9.17.4](#method-related-data-types).

> 对于方法相关数据类型的功能描述，请参见第7.9.17.4章。


**[SWS_CM_00301]**{DRAFT} **Method Call Processing Mode** *[*The Communication Management shall provide an enumeration MethodCallProcessingMode which defines the processing modes for the service implementation side.

> **[SWS_CM_00301]**{草案} **方法调用处理模式** *[*通信管理应提供一个枚举MethodCallProcessingMode，它定义了服务实现端的处理模式。

```
1 enum class MethodCallProcessingMode : std::uint8_t {

2 kPoll,

3 kEvent,

4 kEventSingleThread

5 };
```

_♩(RS_CM_00211, RS_AP_00114, RS_AP_00125)_

### Service Related Data Types [SWS_CM_01071] {DRAFT} _[_

_♩()_

**[SWS_CM_01072]**{DRAFT} _[_

_♩()_

5. ### Generic Data Types

   1. **Invalid Value**


**[SWS_CM_10453]**{DRAFT} **Implementation of invalidValue** *[*For AUTOSAR data types which have an invalidValue specified, header file shall also contain the following definition in the same namespace as type declaration:

> **[SWS_CM_10453]**{草案} **无效值的实施** *[*对于拥有无效值指定的AUTOSAR数据类型，头文件中也应包含与类型声明相同命名空间中的以下定义：


constexpr static \<SourceDataType\> kInvalidValue\<DataType\> = \<InvalidValue\>;

> constexpr static \<SourceDataType\> kInvalidValue\<DataType\> = \<InvalidValue\>;

constexpr 静态 \<SourceDataType\> kInvalidValue\<DataType\> = \<InvalidValue\>;

where

- \<DataType\> is the short name of the data type

- \<SourceDataType\> is data type, implicitly convertible to \<DataType\>; In simplest case \<DataType\> itself.

> - \<SourceDataType\> 是一种数据类型，可以隐式转换为\<DataType\>；在最简单的情况下，\<DataType\>本身就是这种类型。
- \<InvalidValue\> is the value defined as invalidValue for the data type

_♩(RS_CM_00001)_


**Note:** invalidValues are only applicable to CppImplementationDataType of category TYPE_REFERENCE and STRING.

> **注意：** invalidValues 仅适用于类别为TYPE_REFERENCE和STRING的CppImplementationDataType。

### Future and Promise

The Future and Promise class templates are described in [16].

### Optional Data Types


The Optional class template ara::core::Optional used in ara::com to provide access to optional record elements of a Structure Cpp Implementation Data Type is described in [16].

> 类模板ara::core::Optional用于ara::com，用于提供对结构Cpp实现数据类型的可选记录元素的访问，其详情见[16]。

### Variant Data Types


The class template ara::core::Variant is used to provide a type-save union representation is described in [16]. Whenever there is a mention of the standard C++17 Item std::variant, the implied source material is [31].

> 类模板ara :: core :: Variant被用来提供类型安全的联合表示法，详情见[16]。每当提到标准C++17项目std :: variant时，隐含的源材料是[31]。


The class template std::variant at a given time either holds a value of one of its alternative types, or in the case of an error, no value.

> 在给定的时间，std::variant类模板要么保存其备选类型中的一个值，要么在出现错误时不保存任何值。


**[SWS_CM_01050]**{DRAFT} **Variant Class Template** *[*The Communication Management shall at least provide an Variant class template which provides a type-save union representation.

> **[SWS_CM_01050]**{草案} **变体类模板** *[*通信管理至少应提供一个变体类模板，用于提供类型安全的联合表示。

```
template\< class\... Types \> class Variant {

// Default constructor Variant() noexcept;

// Move constructor

Variant( Variant&& ) noexcept;

// Copy constructor Variant( const Variant& );

// Converting constructor template\< class T \> Variant ( T&& ) noexcept;

// Explicit converting constructors template\< class T, class\... Args \>

explicit Variant ( std::in_place_type_t\<T\> , Arg&&\... ); template\< class T, class U, class\... Args \>

explicit Variant ( std::in_place_type_t\<T\> , std::initializer_list\<U\> , Arg&&\... );

template\< std::size_t I, class\... Args \>

explicit Variant ( std::in_place_index_t\<I\> , Arg&&\... ); template\< std::size_t I, class U, class\... Args \>

explicit Variant ( std::in_place_index_t\<I\> , std::initializer_list\<U\> , Arg&&\... );

// Destructor

\~Variant() noexcept;

// Move assignment operator

Variant& operator=( Variant&& ) noexcept;

// Default copy assignment operator Variant& operator=( const Variant& );

// Converting assignment operator template \< class T \>

Variant& operator=( T&& ) noexcept;

// Returns the zero-based index of the alternative std::size_t index();

// Checks if the Variant is an invalid state bool valueless_by_exception() const noexcept;

// Modifiers

template \< class T, class\... Args \> void emplace( Args&&\... );

template \< class T, class U, class\... Args \>

void emplace( std::initializer_list\<U\> , Args&&\... ); template \< std::size_t I, class\... Args \>

void emplace( Args&&\... );

template \<std::size_t I, class U, class\... Args\>

void emplace( initializer_list\<U\> , Args&&\... );

// Swap

void swap( Variant& ) noexcept;

};
```


_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00122, RS_AP_00132, RS_AP_00127, RS_AP_00134, RS_AP_00145)_

> _♩（RS_CM_00205，RS_SOMEIP_00050，RS_AP_00114，RS_AP_00122，RS_AP_00132，RS_AP_00127，RS_AP_00134，RS_AP_00145）_


**[SWS_CM_01051]**{DRAFT} **Variant default constructor** *[*The Variant constructor

> **[SWS_CM_01051]**{草稿} **变体默认构造函数** *[*变体构造函数

1 Variant();

behaves as the std::variant constructor

1 variant();

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_01052]**{DRAFT} **Variant move constructor** *[*The Variant move constructor

> **[SWS_CM_01052]**{草案} **变体移动构造函数**

1 Variant( Variant&&) noexcept;

behaves as the std::variant move constructor

1 constexpr variant( variant&& other ) noexcept;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132, RS_AP_00145)_


**[SWS_CM_01053]**{DRAFT} **Variant copy constructor** *[*The Variant copy constructor

> **[SWS_CM_01053]**{草案} **变体拷贝构造函数** *[*变体拷贝构造函数

1 Variant( const Variant& );

behaves as the std::variant copy constructor

1 constexpr variant( const variant& other );

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_01054]**{DRAFT} **Variant converting constructor** *[*The Variant converting constructor

> **[SWS_CM_01054]**{草稿} **变量转换构造函数** *[*变量转换构造函数

1 template\< class T \>

2 Variant ( T&& ) noexcept;

behaves as the std::variant converting constructor

1 template\< class T \>

2 constexpr variant( TT& t ) noexcept;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132, RS_AP_00145)_


**[SWS_CM_01055]**{DRAFT} **Variant explicit converting constructor with specified alternative** *[*The Variant explicit converting constructor with specified alternative

> **[SWS_CM_01055]**{草案} **具有指定替代方案的Variant显式转换构造函数**

1 template\< class T, class\... Args \>

2 explicit Variant ( std::in_place_type_t\<T\> , Arg&&\... );


behaves as the std::variant explicit converting constructor with specified alternative

> 表现为std::variant的显式转换构造函数，指定了可选项。

1 template\< class T, class\... Args \>


2 constexpr explicit variant ( std::in_place_type_t\<T\> , Arg&&\... args );

> 2 个常量表达式显式变体（std::in_place_type_t<T>，Arg&&…参数）；

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132, RS_AP_00145)_


**[SWS_CM_01056]**{DRAFT} **Variant explicit converting constructor with specified alternative and initializer list** *[*The Variant explicit converting constructor with specified alternative and initializer list

> **[SWS_CM_01056]**{草案} **带有指定替代和初始化列表的Variant显式转换构造函数**

1 template\< class T, class U, class\... Args \>


2 explicit Variant ( std::in_place_type_t\<T\> , std::initializer_list\<U\> , Arg&&\... );

> 2 显式变体（std::in_place_type_t\<T\>，std::initializer_list\<U\>，Arg&&\...）；


behaves as the std::variant explicit converting constructor with specified alternative and initializer list

> 表现为std::variant显式转换构造函数，带有指定的替代选项和初始化列表。

1 template\< class T, class U, class\... Args \>


2 constexpr explicit variant ( std::in_place_type_t\<T\> , std:: initializer_list\<U\> il, Arg&&\... args );

> 2个 constexpr 显式变体（std::in_place_type_t<T>，std::initializer_list<U> il，Arg&&… args）;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_01057]**{DRAFT} **Variant explicit converting constructor with alternative specified by index** *[*The Variant explicit converting constructor with alternative specified by index

> **[SWS_CM_01057]**{草案} **带有按索引指定的替代方案的变体显式转换构造函数**

1 template\< std::size_t I, class\... Args \>

2 explicit Variant ( std::in_place_index_t\<I\> , Arg&&\... );

behaves as the std::variant with alternative specified by index

1 template\< std::size_t I, class\... Args \>


2 constexpr explicit variant ( std::in_place_index_t\<I\> , Arg&&\... args )

> 2 个 constexpr 显式变体（std::in_place_index_t<I>，Arg&& …… 参数）

;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_01058]**{DRAFT} **Variant explicit converting constructor with alternative specified by index and initializer list** *[*The Variant explicit converting constructor with alternative specified by index and initializer list

> **[SWS_CM_01058]**{草案}**使用索引和初始化列表指定的变体显式转换构造函数**

1 template\< std::size_t I, class U, class\... Args \>


2 explicit Variant ( std::in_place_index_t\<I\> , std::initializer_list\<U\>

> 2 明确变体（std::in_place_index_t<I>，std::initializer_list<U>）

, Arg&&\... );


behaves as the std::variant with alternative specified by index and initializer list

> 行为类似于std::variant，由索引和初始化列表指定的替代选项。

1 template\< std::size_t I, class U, class\... Args \>


2 constexpr explicit variant ( std::in_place_index_t\<I\> , std:: initializer_list\<U\> il, Arg&&\... args );

> 2个constexpr显式变体(std::in_place_index_t<I>, std::initializer_list<U> il, Arg&&... args);

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_01059]**{DRAFT} **Variant destructor** *[*The Variant destructor

> **[SWS_CM_01059]**{草案} **变体析构函数** *[*变体析构函数

1 \~Variant() noexcept;

behaves as the std::variant destructor with noexcept specifier

1 \~variant() noexcept;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00134, RS_AP_00145)_


**[SWS_CM_01060]**{DRAFT} **Variant move assignment operator** *[*The Variant

> **[SWS_CM_01060]**{草案} **变体移动赋值运算符** *[*Variant

move assignment operator

1 Variant& operator=( Variant&& ) noexcept;

behaves as the std::variant move assignment operator

1 constexpr variant( variant&& rhs ) noexcept

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132, RS_AP_00145)_

### [SWS_CM_01061] {DRAFT} Variant default copy assignment operator *[*The

Variant default copy assignment operator

1 Variant& operator=(const Variant&);

behaves as the std::variant default copy assignment operator

1 variant& operator=( const variant& rhs );

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00145)_


**[SWS_CM_01062]**{DRAFT} **Variant converting assignment operator** *[*The Variant converting assignment operator

> **[SWS_CM_01062]**{草案} **变体转换赋值运算符** *[*变体转换赋值运算符

1 template \< class T \>

2 Variant& operator=( T&& ) noexcept;

behaves as the std::variant converting assignment operator

1 template \< class T \>

2 variant& operator=( T&& t ) noexcept;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132)_


**[SWS_CM_01063]**{DRAFT} **Variant function to return the zero-based index of the alternative** *[*The Variant function returns the zero-based index of the alternative

> **[SWS_CM_01063]**{草稿}**变体函数返回替代方案的从零开始的索引** *[*变体函数返回替代方案的从零开始的索引

1 std::size_t index();


behaves as the std::variant function to return the zero-based index of the alternative

> 表现为std::variant函数，以返回基于零的替代项的索引

1 constexpr std::size_t index();

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114)_


**[SWS_CM_01064]**{DRAFT} **Variant function to check if the Variant is in invalid state** *[*The Variant function checks if the Variant is in invalid state

> **[SWS_CM_01064]**{草案} **检查变体是否处于无效状态的变体功能** *[*变体功能用于检查变体是否处于无效状态。

1 bool valueless_by_exception() const noexcept;


behaves as the std::variant function to return false if the variant holds a value, else true

> 行为类似std::variant函数，如果variant保存了一个值，则返回false，否则返回true。

1 constexpr bool valueless_by_exception() const noexcept;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132)_


**[SWS_CM_01066]**{DRAFT} **Variant function to create a new value in-place, in an existing Variant object** *[*The Variant creates a new value in-place, in an existing Variant object

> **[SWS_CM_01066]**{草案} **在现有Variant对象中创建新值的变量函数** *[*Variant在现有Variant对象中创建新值

1 template \< class T, class\... Args \>

2 void emplace( Args&&\... );


behaves as the std::variant emplace function to create a new value in-place, in an existing Variant object

> 行为类似std::variant的emplace函数，在现有Variant对象中创建新的值。

1 template \< class T, class\... Args \>

2 void emplace( Args&&\... args );

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114)_


**[SWS_CM_01067]**{DRAFT} **Variant function to create a new value in-place, in an existing Variant object using an initializer list** *[*The Variant creates a new value in-place, in an existing Variant object using initializer list

> **[SWS_CM_01067]**{草案}**使用初始化列表在现有Variant对象中创建一个新值** *[*Variant使用初始化列表在现有的Variant对象中创建一个新值

1 template \< class T, class U, class\... Args \>

2 void emplace( std::initializer_list\<U\> , Args&&\... );


behaves as the std::variant emplace function to create a new value in-place, in an existing Variant object using an initializer list

> 行为类似于std::variant的emplace函数，可以使用初始化列表在现有Variant对象中创建新值。

1 template \< class T, class U, class\... Args \>

2 void emplace( std::initializer_list\<U\> il , Args&&\... args );

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114)_


**[SWS_CM_01068]**{DRAFT} **Variant function to create a new value in-place, in an existing Variant object by destoying and initializing the contained value** *[*The Variant creates a new value in-place, in an existing Variant object by destroying and initializing the contained value

> **[SWS_CM_01068]**{草案} **变体函数，通过销毁和初始化所包含的值，在现有变体对象中创建新值** *[*变体通过销毁和初始化所包含的值，在现有变体对象中创建新值。

1 template \< std::size_t I, class\... Args \>

2 void emplace( Args&&\... );


behaves as the std::variant emplace function to create a new value in-place, in an existing Variant object by destroying and initializing the contained value

> 行为类似std::variant的emplace函数，通过销毁和初始化已存在的Variant对象中的值，在原处创建新的值。

1 template \< std::size_t I, class\... Args \>

2 void emplace( Args&&\... args );


The behavior is undefined if I is not less than sizeof\...(Types)_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114)_

> 行为如果I不小于sizeof(类型)就是未定义的。


**[SWS_CM_01069]**{DRAFT} **Variant function to create a new value in-place, in an existing Variant object by destoying and initializing the contained value using an initializer list** *[*The Variant creates a new value in-place, in an existing Variant object by destroying and initializing the contained value using an initializer list

> **[SWS_CM_01069]**{草案} **在现有Variant对象中通过使用初始化列表摧毁和初始化包含的值来创建一个新值的Variant函数** *[*Variant通过使用初始化列表摧毁和初始化包含的值在现有的Variant对象中创建一个新值。

1 template \<std::size_t I, class U, class\... Args\>

2 void emplace( initializer_list\<U\> , Args&&\... );


behaves as the std::variant emplace function to create a new value in-place, in an existing Variant object by destroying and initializing the contained value using an initializer list

> 行为类似于std::variant的emplace函数，通过使用初始化列表销毁和初始化已有的Variant对象中的值，来在其中创建新的值。

1 template \<std::size_t I, class U, class\... Args\>

2 void emplace( initializer_list\<U\> il , Args&&\... args );


The behavior is undefined if I is not less than sizeof\...(Types)_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114)_

> 行为如果I不小于sizeof(类型)_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114)_就是未定义的。


**[SWS_CM_01065]**{DRAFT} **Variant function to swap two Variants** *[*The Variant

> **[SWS_CM_01065]**{草案} **变体函数交换两个变体** *[*变体

function swaps two Variants

1 void swap( Variant& ) noexcept;

behaves as the std::variant function to swap two Variants

1 void swap( Variant& rhs ) noexcept;

_♩(RS_CM_00205, RS_SOMEIP_00050, RS_AP_00114, RS_AP_00132)_

### Error Types


**[SWS_CM_11265]**{DRAFT} **Use of general ara::com errors** *[*Any Checked Error of a service interface shall be reported via the return type as specified in [16]._♩(RS_CM_00211, RS_AP_00119)_

> **[SWS_CM_11265]**{草稿}**使用一般ara :: com错误** *[*任何服务接口的检查错误都应按照[16]中指定的返回类型进行报告。_♩（RS_CM_00211，RS_AP_00119）_

In ara::com, there are the following types of Checked Errors:


1. General ara::com errors: These errors can occur in a call of a service interface method but are not specific to a certain service interface. They are defined in the error domain ara::com::ComErrorDomain.

> 一般ara::com错误：这些错误可以在调用服务接口方法时发生，但不是特定于某个服务接口。它们定义在ara::com::ComErrorDomain错误域中。

2. E2E errors: These errors are specific to E2E checks. They are defined in the error domain ara::com::e2e::E2EErrorDomain (see chapter [8.1.2.8](#e2e-related-data-types))

> 2. E2E 错误：这些错误专门用于E2E检查。它们在错误域ara::com::e2e::E2EErrorDomain中定义（参见[8.1.2.8](#e2e-related-data-types)章节）。

3. Application Errors: These errors are specific to a certain service interface call. They are defined as ApApplicationError in the meta-model.

> 3. 应用程序错误：这些错误是特定于某个服务接口调用的。它们在元模型中被定义为ApApplicationError。

4. Communication Group Errors: These errors are specific to communication groups. They are defines in the error domain ara::com::cg::CgErrorDomain

> 这些错误是特定于通信组的。它们在ara :: com :: cg :: CgErrorDomain错误域中定义。


Errors can also occur in a call to a RawDataStreamClientInterface or RawDataStreamServerInterface instance method. These errors are defined in the error domain ara::com::raw::RawErrorDomain

> 错误也可以在调用RawDataStreamClientInterface或RawDataStreamServerInterface实例方法时发生。这些错误定义在错误域ara::com::raw::RawErrorDomain中。


**[SWS_CM_11264]**{DRAFT} **Definition general ara::com errors** *[*General ara::com errors shall be defined in the error domain ara::com::ComErrorDomain in accordance with [16]._♩(RS_CM_00102, RS_AP_00115, RS_AP_00119)_

> **[SWS_CM_11264]**{草案} **一般ara::com错误的定义** *[*根据[16]，一般ara::com错误应在错误域ara::com::ComErrorDomain中定义。_♩(RS_CM_00102, RS_AP_00115, RS_AP_00119)_


**[SWS_CM_11267]**{DRAFT} **General errors domain** *[*Error domain to describe general ara::com errors ara::com::ComErrorDomain shall be defined. It shall have the shortname Com and the identifier 0x8000'0000'0000'1267._♩(RS_AP_00130)_

> **[SWS_CM_11267]**{草案} **一般错误域** *[*为描述ara::com错误，将定义ara::com::ComErrorDomain。它的简称为Com，标识符为0x8000'0000'0000'1267。_♩(RS_AP_00130)_

**[SWS_CM_10432]**{DRAFT} _[_

_♩(RS_AP_00120, RS_AP_00121, RS_AP_00130, RS_AP_00132)_


**[SWS_CM_11266]**{DRAFT} **Definition of Application Errors** *[*Each ApApplicationError references an ApApplicationErrorDomain. The error domain corresponding ApApplicationErrorDomain shall be defined as specified in [16]. The corresponding enumeration shall contain an entry for each ApApplicationError referencing this ApApplicationErrorDomain using the shortName of the ApApplicationError as symbol and the errorCode of the ApApplicationError as value:

> **[SWS_CM_11266]**{草案} **应用错误定义** *[*每个ApApplicationError引用一个ApApplicationErrorDomain。相应的ApApplicationErrorDomain应按照[16]中的规定进行定义。相应的枚举应包含引用此ApApplicationErrorDomain的每个ApApplicationError的条目，使用ApApplicationError的shortName作为符号，ApApplicationError的errorCode作为值：

```

1

2 enum class \<ApApplicationErrorDomain.SN\>Errc : ara::core::ErrorDomain:: CodeType

3 {

4 \<ApApplicationError.SN\> = \<ApApplicationError.errorCode\>,

5

6 };
```

_♩(RS_CM_00211, RS_AP_00114, RS_AP_00119, RS_AP_00127)_


**[SWS_CM_11268] Definition general ara::com::raw errors** *[*General ara::com::raw errors shall be defined in the error domain ara::com::raw::RawErrorDomain in accordance with [16].

> **[SWS_CM_11268] 将ara::com::raw错误的定义一般化::：com::raw* [*根据[16]，将ara::com::raw错误定义为ara::com::raw::RawErrorDomain中的错误域。*

_♩(RS_AP_00130)_


**[SWS_CM_99025]**{DRAFT} **Raw errors domain** *[*Error domain to describe ara::com errors related to the RawDataStreamInterface ara::com::raw::RawErrorDomain shall be defined. It shall have the shortname Raw and the identifier 0x8000'0000'0000'1280._♩(RS_AP_00130)_

> **[SWS_CM_99025]**{草稿} **原始错误域** *[*要描述ara::com错误与RawDataStreamInterface有关的ara::com::raw::RawErrorDomain，必须定义一个错误域。它的简称为Raw，标识符为0x8000'0000'0000'1280._♩(RS_AP_00130)_

### [SWS_CM_12367] _[_

_♩(RS_AP_00130)_


**[SWS_CM_99027]**{DRAFT} **Cg errors domain** *[*Error domain to describe ara::com errors related to the Communication Groups ara::com::cg::CgErrorDomain shall be defined. It shall have the shortname Cg and the identifier 0x8000'0000'0000'1270._♩ (RS_AP_00130)_

> **[SWS_CM_99027]**{草案} **Cg 错误域** *[*为描述ara::com错误，相关于Communication Groups ara::com::cg::CgErrorDomain，应定义一个错误域。它应具有简称Cg和标识符0x8000'0000'0000'1270。_♩ (RS_AP_00130)_

### E2E Related Data Types


Some data types are used only in context of e2e-protected communication of events.

> 一些数据类型只在端到端受保护的事件通信上下文中使用。


**[SWS_CM_90421]**{DRAFT} **ara::com::e2e::ProfileCheckStatus** *[*The Communication Management shall provide an enumeration ara::com::e2e::ProfileCheckStatus which represents the results of the check of a single sample:

> **[SWS_CM_90421]**{草案} **ara::com::e2e::ProfileCheckStatus** *[*通信管理应提供枚举ara::com::e2e::ProfileCheckStatus，用于表示单个样本检查的结果：

- kOk: The checks of the sample in this cycle were successful (including counter check).
- kRepeated: sample has a repeated counter.

- kWrongSequence: The checks of the sample in this cycle were successful, with the exception of counter jump, which changed more than the allowed delta.

> 样品在本周期的检查均成功，但计数器跳变超出了允许的增量。
- kError: Error not related to counters occurred (e.g. wrong crc, wrong length, wrong Data ID).

- kCheckDisabled: No E2E check status available. Return value of function GetProfileCheckStatus if EndToEndTransformationComSpecProps. disableEndToEndCheck is set to TRUE

> 检查禁用：没有可用的E2E检查状态。如果EndToEndTransformationComSpecProps.disableEndToEndCheck设置为TRUE，则返回函数GetProfileCheckStatus的值。

```
1 enum class ProfileCheckStatus : std::uint8_t

2 {

3 kOk,

4 kRepeated,

5 kWrongSequence,

6 kError,

7 kCheckDisabled

8 };
```


Results of E2E are described in [PRS_E2E_00322] and [PRS_E2E_00677] of [4]._♩_

> 结果的E2E在[4]的[PRS_E2E_00322]和[PRS_E2E_00677]中描述。

_(RS_E2E_08534, RS_AP_00114, RS_AP_00115, RS_AP_00119)_


**[SWS_CM_90426]**{DRAFT} **Mapping of ProfileCheckStatus** *[*The E2E profile independent results according to [PRS_E2E_00677] shall be mapped to the enumeration literals of ara::com::e2e::ProfileCheckStatus as described in [Table](#_bookmark509) [8.1](#_bookmark509)._♩ (RS_E2E_08534, RS_AP_00114, RS_AP_00115, RS_AP_00119)_

> **[SWS_CM_90426]**{草案} **ProfileCheckStatus的映射** *[*根据[PRS_E2E_00677]的E2E独立结果将按照[表8.1](#_bookmark509)中描述的ara::com::e2e::ProfileCheckStatus的枚举文字进行映射。_♩ (RS_E2E_08534, RS_AP_00114, RS_AP_00115, RS_AP_00119)_

**Table 8.1: Mapping of ProfileCheckStatus**


The E2E state machine SMState is determined by checking a history of ProfileCheckStatuses. The current value of SMState mirrors the current state of the E2E supervision, but is not necessarily applicable to all samples received during the last update.

> 状态机SMState的状态由检查ProfileCheckStatuses的历史记录来确定。SMState的当前值反映了E2E监督的当前状态，但不一定适用于上次更新期间收到的所有样本。


**[SWS_CM_90422]**{DRAFT} **ara::com::e2e::SMState** *[*The Communication Management shall provide an enumeration ara::com:e2e::SMState which represents in what state is the E2E supervision after the most recent check of the sample(s) of a received sample of the event. If SMState is Valid, and the GetProfileCheckStatus did not result in Error then the last checked sample can be used.

> **[SWS_CM_90422]**{草稿} **ara::com::e2e::SMState** *[*通信管理应提供一个枚举ara::com:e2e::SMState，用于表示在最近检查事件接收样本后，E2E监督处于何种状态。如果SMState是有效的，并且GetProfileCheckStatus的结果没有出错，那么可以使用最后一个检查过的样本。


- kValid: Communication of the samples of this event functioning properly according to E2E checks, sample(s) _can_ be used.

> 根据端到端检查，本次事件的样本通信正常，可以使用样本。
- kNoData: No data have been received from the publisher at all.

- kInit: Not enough data where the E2E check yielded OK from the publisher is available since the initialization, sample(s) cannot be used.

> 由于初始化时，发布者的端到端检查获得OK的数据不足，因此无法使用样本。

- kInvalid: Too few data where the E2E check yielded OK or to many data where the E2E check yielded ERROR were received within the E2E time window -communication of the sample of this event not functioning properly, sample(s) _cannot_ be used.

> 无效：在E2E时间窗口内收到的E2E检查结果为OK的数据太少或者结果为ERROR的数据太多，此事件的样本通信不正常，无法使用样本。

- kStateMDisabled: No E2E state machine available. Return value of function GetE2EStateMachineState if EndToEndTransformationComSpecProps. disableEndToEndStateMachine is set to TRUE.

> - kStateMDisabled：没有可用的E2E状态机。如果EndToEndTransformationComSpecProps.disableEndToEndStateMachine设置为TRUE，则函数GetE2EStateMachineState的返回值。

```

1 enum class SMState : std::uint8_t

2 {

3 kValid,

4 kNoData,

5 kInit,

6 kInvalid,

7 kStateMDisabled

8 };
```


Results of E2E state machine are described in [PRS_E2E_00322] and [PRS_E2E_00678] of [4]._♩(RS_E2E_08534, RS_AP_00114, RS_AP_00115, RS_AP_00119)_

> 结果的E2E状态机描述在[4]中的[PRS_E2E_00322]和[PRS_E2E_00678]（RS_E2E_08534，RS_AP_00114，RS_AP_00115，RS_AP_00119）。


**[SWS_CM_90427]**{DRAFT} **Mapping of SMState** *[*The communication channel status according to [PRS_E2E_00678] shall be mapped to the enumeration literals of SMState as described in [Table](#_bookmark510) [8.2](#_bookmark510)._♩(RS_E2E_08534, RS_AP_00114, RS_AP_00115, RS_AP_00119)_

> **[SWS_CM_90427]**{草案} **SMState映射** *[*根据[PRS_E2E_00678]的规定，沟通渠道状态应映射到[Table](#_bookmark510) [8.2]中描述的SMState枚举文字。_♩(RS_E2E_08534, RS_AP_00114, RS_AP_00115, RS_AP_00119)_

**Table 8.2: Mapping of SMState**

### Raw Data Stream Data Type [SWS_CM_11300] {DRAFT} _[_

_♩(RS_CM_00410,_ _RS_CM_00411, RS_CM_00412)_

**[SWS_CM_11301]**{DRAFT} _[_

_♩(RS_CM_00410, RS_CM_00411, RS_CM_00412)_

### API Reference


The ServiceInterface description is the input for the generation of the service API header files content.

> 服务接口描述是生成服务API头文件内容的输入。


The proxy and skeleton header files contain different classes representing the ServiceInterface itself and its elements event, method and field.

> 代理和骨架头文件包含不同的类，代表服务接口本身及其元素事件、方法和字段。


**[SWS_CM_00002]**{DRAFT} **Service skeleton class** *[*The Communication Management shall provide the definition of a C++ class named \<name\>Skeleton in the service skeleton header file within the namespace defined by [[SWS_CM_01006](#_bookmark453)], where

> **[SWS_CM_00002]**{草稿} **服务骨架类** *[*通信管理必须在[[SWS_CM_01006](#_bookmark453)]定义的命名空间中，在服务骨架头文件中提供名为\<name\>Skeleton的C++类的定义。

\<name\> is the ServiceInterface.shortName in upper camel case format.

```
1 class UpperCamelCase(\<ServiceInterface.shortName\>)Skeleton {

2 \...

3 };

```

_♩(RS_CM_00101, RS_AP_00114, RS_AP_00122)_


**[SWS_CM_00003]**{DRAFT} **Service skeleton Event class** *[*For each VariableDataPrototype defined in the ServiceInterface in the role event the definition of a C++ class using the shortName in upper camel case format of the VariableDataPrototype shall be provided in the service skeleton header file within the namespace defined by [[SWS_CM_01009](#_bookmark455)].

> **[SWS_CM_00003]**{草案} **服务骨架事件类** *[*在服务接口中定义的每个VariableDataPrototype，都应在服务骨架头文件中，使用[[SWS_CM_01009](#_bookmark455)]定义的命名空间，提供VariableDataPrototype的短名称（大驼峰格式）的C++类的定义。

```
1 class UpperCamelCase(\<VariableDataPrototype.shortName\>) {

2 \...

3 };
```

_♩(RS_CM_00201, RS_AP_00114)_


**[SWS_CM_11400]**{DRAFT} **Service skeleton SampleType type alias** *[*Each service skeleton Event class (according to [[SWS_CM_00003](#_bookmark514)]) shall provide a type alias named SampleType for the CppImplementationDataType of the Event (i.e., for the CppImplementationDataType which is either referenced by the VariableDataPrototype in role type directly or via the indirection of a DataTypeMap.

> **[SWS_CM_11400]**{草案}**服务骨架SampleType类型别名** *[*每个服务骨架事件类（根据[[SWS_CM_00003](#_bookmark514)））应提供一个名为SampleType的类型别名，用于该事件的CppImplementationDataType（即，对于直接由角色类型的VariableDataPrototype引用或通过DataTypeMap间接引用的CppImplementationDataType）。

```
1 using SampleType = \<name\>;
```


where \<name\> is the Cpp Implementation Data Type symbol of the CppImplementationDataType of the event._♩(RS_CM_00201, RS_AP_00114)_

> 在哪里\<name\>是事件的CppImplementationDataType的Cpp实现数据类型符号？♩(RS_CM_00201, RS_AP_00114)


**[SWS_CM_00007]**{DRAFT} **Service skeleton Field class** *[*For each Field defined in the ServiceInterface in the role field the definition of a C++ class using the shortName in upper camel case format of the Field shall be provided in the service skeleton header file within the namespace defined by [[SWS_CM_01031](#_bookmark457)].

> **[SWS_CM_00007]**{草案} **服务骨架字段类** *[*在服务接口中定义的每个字段，都应在服务骨架头文件中以字段的短名称大写驼峰格式提供一个C++类，并且在[[SWS_CM_01031](#_bookmark457)]定义的命名空间中。

```
1 class UpperCamelCase(\<Field.shortName\>) {

2 \...

3 };
```

_♩(RS_CM_00219, RS_AP_00114)_


**[SWS_CM_11402]**{DRAFT} **Service skeleton FieldType class** *[*Each skeleton Field class (according to [[SWS_CM_00007](#_bookmark515)]) shall provide a type alias named FieldType for the CppImplementationDataType of the Field (i.e., for the CppImplementationDataType which is either referenced by the VariableDataPrototype in role type or via indirection of a DataTypeMap).

> **[SWS_CM_11402]**{草案}**服务骨架FieldType类** *[*每个骨架Field类（根据[[SWS_CM_00007](#_bookmark515)））应提供一个类型别名FieldType，用于Field的CppImplementationDataType（即，用于角色类型中引用的CppImplementationDataType或通过DataTypeMap间接引用的CppImplementationDataType）。

```
1 using FieldType = \<name\>;
```


where \<name\> is the Cpp Implementation Data Type symbol of the CppImplementationDataType of the Field._♩(RS_CM_00219, RS_AP_00114)_

> 在哪里\<name\>是Field的Cpp实现数据类型符号(RS_CM_00219, RS_AP_00114)？


**[SWS_CM_00004]**{DRAFT} **Service proxy class** *[*The Communication Management shall provide the definition of a C++ class named \<name\>Proxy in the service proxy header file within the namespace defined by [[SWS_CM_01007](#_bookmark454)], where \<name\> is the ServiceInterface.shortName in upper camel case format.

> **[SWS_CM_00004]**{草案} **服务代理类** *[*通信管理应在[[SWS_CM_01007](#_bookmark454)]定义的命名空间中，在服务代理头文件中提供名为\<name\>Proxy的C++类的定义，其中\<name\>是ServiceInterface.shortName以大写驼峰格式表示的。

```
1 class UpperCamelCase(\<ServiceInterface.shortName\>)Proxy {

2 \...

3 };
```

_♩(RS_CM_00102, RS_AP_00114, RS_AP_00122)_


**[SWS_CM_00005]**{DRAFT} **Service proxy Event class** *[*For each VariableDataPrototype defined in the ServiceInterface in the role event the definition of a C++ class using the shortName in upper camel case format of the VariableDataPrototype shall be provided in the service proxy header file within the namespace defined by [[SWS_CM_01009](#_bookmark455)].

> **[SWS_CM_00005]**{草案} **服务代理事件类** *[*在服务接口中定义的每个 VariableDataPrototype 在事件角色中，应在 [[SWS_CM_01009](#_bookmark455) 定义的命名空间内，提供 VariableDataPrototype 的短名称大写驼峰格式的 C++ 类的定义，以便在服务代理头文件中使用。

1 class UpperCamelCase(\<VariableDataPrototype.shortName\>) {

2 \...

3 };

_♩(RS_CM_00103, RS_AP_00114)_


**[SWS_CM_11401]**{DRAFT} **Service proxy SampleType type alias** *[*Each service proxy Event class (according to [[SWS_CM_00005](#_bookmark517)]) shall provide a type alias named SampleType for the CppImplementationDataType of the Event (i.e., for the CppImplementationDataType which is either referenced by the VariableDataPrototype in role type directly or via the indirection of a DataTypeMap).

> **[SWS_CM_11401]** {草案} **服务代理示例类型类型别名** *[*每个服务代理事件类（根据[[SWS_CM_00005](#_bookmark517)））应该为事件（即CppImplementationDataType，直接通过角色类型引用VariableDataPrototype或通过DataTypeMap间接引用）提供一个名为SampleType的类型别名。

1 using SampleType = \<name\>;


where \<name\> is the Cpp Implementation Data Type symbol of the CppImplementationDataType of the event._♩(RS_CM_00103, RS_AP_00114)_

> 在哪里\<name\>是事件的CppImplementationDataType的Cpp实现数据类型符号？♩(RS_CM_00103, RS_AP_00114)


**[SWS_CM_00006]**{DRAFT} **Service proxy Method class** *[*For each ClientServerOperation defined in the ServiceInterface in the role method the definition of a C++ class using the shortName in upper camel case format of the ClientServerOperation shall be provided in the service proxy header file within the namespace defined by [[SWS_CM_01015](#_bookmark456)].

> **[SWS_CM_00006]**{草案}**服务代理方法类** *[*对于在角色方法中定义在ServiceInterface中的每个ClientServerOperation，应在服务代理头文件中提供使用[[SWS_CM_01015](#_bookmark456)]定义的命名空间中的ClientServerOperation的短名称的大驼峰格式的C++类的定义。

1 class UpperCamelCase(\<ClientServerOperation.shortName\> {

2 \...

3 };

_♩(RS_CM_00212, RS_CM_00213, RS_AP_00114)_


**[SWS_CM_00008]**{DRAFT} **Service proxy Field class** *[*For each Field defined in the ServiceInterface in the role Field the definition of a C++ class using the shortName in upper camel case format of the Field shall be provided in the service proxy header file within the namespace defined by [[SWS_CM_01031](#_bookmark457)].

> **[SWS_CM_00008]**{草案} **服务代理字段类** *[*在角色字段中定义的每个服务接口中，应在[[SWS_CM_01031](#_bookmark457)]定义的命名空间中，在服务代理头文件中提供使用字段的短名称的大写驼峰格式的类的定义。

1 class UpperCamelCase(\<Field.shortName\>) {

2 \...

3 };

_♩(RS_CM_00216, RS_AP_00114)_


**[SWS_CM_11403]**{DRAFT} **Service proxy FieldType alias** *[*Each service proxy Field class (according to [[SWS_CM_00008](#_bookmark518)]) shall provide a type alias named FieldType for the CppImplementationDataType of the Field (i.e., for the CppImplementationDataType which is either referenced by the VariableDataPrototype in role type directly or via the indirection of a DataTypeMap).

> **[SWS_CM_11403]**{草案} **服务代理字段类型别名** *[*每个服务代理字段类（根据[[SWS_CM_00008](#_bookmark518)））应提供一个名为FieldType的类型别名，用于字段的CppImplementationDataType（即，用于角色类型中直接引用的VariableDataPrototype或通过DataTypeMap间接引用的CppImplementationDataType）。

1 using FieldType = \<name\>;


where \<name\> is the Cpp Implementation Data Type symbol of the CppImplementationDataType of the Field._♩(RS_CM_00216, RS_AP_00114)_

> 在哪里\<name\>是字段的Cpp实现数据类型符号？♩(RS_CM_00216, RS_AP_00114)


**[SWS_CM_99028]**{DRAFT} **Types of APIs Communication and Service Discovery APIs** *[*There are two categories of APIs: Service Discovery API and Communication API.

> **[SWS_CM_99028]**{草案} **服务发现和通信API的类型** *[*API可以分为两类：服务发现API和通信API。


Service Discovery API : These APIs are used in service discovery process. The following APIs are Service Discovery APIs:

> 服务发现API：这些API用于服务发现过程。以下API是服务发现API：

- OfferService()
- StopOfferService()
- RegisterGetHandler()
- RegisterSetHandler()
- FindService()
- StartFindService()
- StopFindService()
- GetHandle()
- Subscribe()
- Unsubscribe()
- GetSubscriptionState()
- SetSubscriptionStateChangeHandler()
- UnsetSubscriptionStateChangeHandler()
- SetReceiveHandler()
- UnsetReceiveHandler()


Communication API : These APIs are used in communication between Client and Server. The following APIs are Communication APIs:

> 通信 API：这些 API 用于客户端和服务器之间的通信。以下是通信 API：

- Send()
- Allocate()
- Update()
- GetNewSamples()
- GetFreeSampleCount()
- Method call operator()
- Get()
- Set()

_♩()_


**[SWS_CM_00009]**{DRAFT} **Re-entrancy and thread-safety General** *[*The concurrent invocation of communication APIs shall be allowed irrespective of the class instance. I.e., concurrent invocation of _different_ member functions shall be allowed for the same class instance and for _different_ class instances.

> **[SWS_CM_00009]**{草案} **重入和线程安全性一般** *[*不管是哪个类实例，都应允许并发调用通信API。也就是说，应允许对同一个类实例和不同的类实例进行不同成员函数的并发调用。


The concurrent invocation of service discovery APIs shall be allowed for _different_ class instances and shall not be allowed for same class instances.

> 允许对不同类实例的服务发现API同时调用，而不允许对相同类实例调用。


Only communication APIs shall be thread-safe against each other (for same class instance).

> 只有通信 API 才能在彼此之间线程安全（对于同一个类实例）。


Service Discovery APIs shall be NOT thread-safe against each other, or against Communication APIs (for same proxy/skeleton instance)._♩(RS_Main_00050)_

> 服务发现API不得在彼此之间或与同一代理/骨架实例的通信API之间是线程不安全的。


The following sub-chapters describe the content of the previously defined classes.

> 以下子章节描述了先前定义的类的内容。

### Object Creation via Named Constructor Approach

